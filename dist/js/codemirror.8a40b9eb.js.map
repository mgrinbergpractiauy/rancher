{"version":3,"file":"js/codemirror.8a40b9eb.js","mappings":"uHAGA,IAAIA,EAAU,EAAQ,OACnBA,EAAQC,aAAYD,EAAUA,EAAQE,SACnB,kBAAZF,IAAsBA,EAAU,CAAC,CAACG,EAAOC,GAAIJ,EAAS,MAC7DA,EAAQK,SAAQF,EAAOG,QAAUN,EAAQK,QAE5C,IAAIE,EAAM,WACGA,EAAI,WAAYP,GAAS,EAAM,CAAC,WAAY,EAAM,YAAa,G,gVCN5E,SAAUQ,GAENA,EAAI,EAAQ,OAKf,EAPD,CAOG,SAASC,GACV,aAEA,IAAIC,EAAOD,EAAWE,SAClBC,EAAMH,EAAWG,IACrB,SAASC,EAAMC,EAAGC,GAAK,OAAOD,EAAEE,MAAQD,EAAEC,MAAQF,EAAEG,IAAMF,EAAEE,EAAI,CAIhE,IAAIC,EAAW,GACf,SAASC,EAAUC,GACjBF,EAASG,KAAKD,GACVF,EAASI,OAAS,IAAIJ,EAASK,OACrC,CACA,SAASC,EAAYJ,GACnB,IAAKF,EAASI,OAAQ,OAAOH,EAAUC,GACvCF,EAASA,EAASI,OAAS,IAAMF,CACnC,CACA,SAASK,EAAYC,GAAK,OAAOR,EAASA,EAASI,QAAUI,EAAIC,KAAKC,IAAIF,EAAG,GAAK,KAAO,EAAI,CAC7F,SAASG,IAAyD,OAArCX,EAASI,OAAS,GAAGJ,EAASY,MAAcL,GAAe,CAExF,IAAIM,EAAW,KAGf,SAASC,EAAMC,EAAIC,EAAMC,EAAIC,EAAMC,GACrB,MAARA,IAAcA,EAAOJ,EAAGK,SAASJ,EAAMC,IAE/B,QAARC,GAAkBL,GAAYA,EAASE,IAAMA,GAAMpB,EAAMqB,EAAMH,EAASQ,MAAQN,EAAGO,QAAQT,EAASU,KACtGjB,EAAYa,IACI,IAATD,GACPjB,EAAUkB,GACZJ,EAAGS,aAAa,GAAIR,EAAMC,EAAI,WAEVJ,EAAR,QAARK,EAA2B,CAACH,GAAIA,EAAIM,IAAKL,EAAMO,IAAKR,EAAGU,oBAC3C,IAClB,CAIA,SAASC,EAAOX,EAAIM,EAAKM,GACvB,OAAOZ,EAAGa,SAASP,EAAKM,EAAK,QAAQ,EACvC,CAEA,SAASE,EAAOd,EAAIM,EAAKM,GACvB,OAAOZ,EAAGa,SAASP,EAAKM,EAAK,QAAQ,EACvC,CAEA,SAASG,EAAOf,EAAIM,EAAKM,GACvB,OAAOZ,EAAGgB,SAASV,EAAKM,EAAK,OAAQZ,EAAGiB,IAAIC,IAAIC,WAClD,CAEA,SAASC,EAAOpB,EAAIM,EAAKM,GACvB,OAAOZ,EAAGgB,SAASV,EAAKM,EAAK,OAAQZ,EAAGiB,IAAIC,IAAIC,WAClD,CAEA,SAASE,EAAYrB,EAAIM,EAAKM,GAI5B,IAHA,IAAIU,EAAKhB,EAAIvB,KAAMA,EAAOiB,EAAGuB,QAAQD,GACjCE,EAAU,KAAKC,KAAKb,EAAM,EAAI7B,EAAK2C,MAAM,EAAGpB,EAAItB,IAAMD,EAAK2C,MAAMpB,EAAItB,KACrE2C,EAAM3B,EAAG4B,YAAaC,EAAM7B,EAAG8B,aAC1B,CAEP,GADAR,GAAMV,EACFU,EAAKK,GAAOL,EAAKO,EACnB,OAAO7B,EAAG+B,QAAQpD,EAAI2C,EAAKV,EAAKA,EAAM,EAAI,EAAI,OAChD7B,EAAOiB,EAAGuB,QAAQD,GAClB,IAAIU,EAAU,KAAKP,KAAK1C,GACxB,GAAIiD,EAASR,GAAU,OAClB,GAAIA,EAAS,OAAO7C,EAAI2C,EAAI,EACnC,CACF,CAEA,SAASW,EAAWjC,EAAIM,EAAKM,GAG3B,IAFA,IAAI7B,EAAOuB,EAAIvB,KAAMC,EAAKsB,EAAItB,GAC1BoB,EAAOJ,EAAGuB,QAAQjB,EAAIvB,MAAOmD,GAAU,IAClC,CACP,IAAIC,EAAO/B,EAAKgC,OAAOpD,GAAM4B,EAAM,GAAK,EAAI,IAC5C,GAAKuB,EAAL,CAQA,GAAID,GAAW,QAAQT,KAAKU,GAAO,OAAOxD,EAAII,EAAMC,GAAM4B,EAAM,EAAI,EAAI,IACnEsB,IAASA,EAAU,KAAKT,KAAKU,IAClCnD,GAAM4B,CAHN,KAPA,CACE,GAAI7B,IAAS6B,EAAM,EAAIZ,EAAG4B,YAAc5B,EAAG8B,YAAa,OAAOnD,EAAII,EAAMC,GAEzE,GADAoB,EAAOJ,EAAGuB,QAAQxC,EAAO6B,IACpB,KAAKa,KAAKrB,GAAO,OAAOzB,EAAII,EAAMC,GACvCD,GAAQ6B,EACR5B,EAAK4B,EAAM,EAAIR,EAAKf,OAAS,CAE/B,CAIF,CACF,CAEA,SAASgD,EAAOrC,EAAIM,EAAKM,GACvB,IAAI0B,EACJ,GAAItC,EAAGuC,sBAAwBD,EAAOtC,EAAGuC,oBAAoBjC,EAAK,CAACkC,QAAQ,MACpEF,EAAKG,QAAUH,EAAKI,QAAU,GAAK,IAAM9B,EAC9C,OAAOA,EAAM,EAAIjC,EAAI2D,EAAKpC,GAAGnB,KAAMuD,EAAKpC,GAAGlB,GAAK,GAAKsD,EAAKpC,GAE5D,IAAK,IAAIyC,GAAQ,GAAOA,GAAQ,EAAO,CACrC,IAAIC,EAAQ5C,EAAG6C,WAAWvC,GACtBwC,EAAQnE,EAAI2B,EAAIvB,KAAM6B,EAAM,EAAIgC,EAAMG,MAAQH,EAAMI,KACxD,KAAIL,GAAS/B,EAAM,GAAKgC,EAAMI,KAAO1C,EAAItB,KAAO,KAAKyC,KAAKmB,EAAMK,QAK9D,OAAOH,EAJP,IAAII,EAASlD,EAAGa,SAASiC,EAAOlC,EAAK,QACrC,GAAIhC,EAAMkE,EAAOI,GAAS,OAAO5C,EAC5BA,EAAM4C,CAIf,CACF,CAIA,SAASC,EAAUnD,EAAIoD,GACrB,IAAIC,EAASrD,EAAGsD,MAAMC,YACtB,OAAKF,GACLG,EAAYxD,GACK,KAAVqD,GAAiB,EAAII,OAAOJ,IAFfD,EAAU,KAAO,CAGvC,CAEA,SAASM,EAASC,GAChB,IAAIC,EAAkB,iBAAPD,EAAkB,SAAS3D,GAAMA,EAAG6D,YAAYF,EAAM,EAAIA,EACzE,OAAO,SAAS3D,GACd,IAAI8D,EAASX,EAAUnD,GACvB4D,EAAE5D,GACF,IAAK,IAAI+D,EAAI,EAAGA,EAAID,IAAUC,EAAGH,EAAE5D,EACrC,CACF,CAEA,SAASgE,EAAQhE,EAAIM,EAAK2D,EAAIrD,GAC5B,IAAIkD,EAASX,EAAUnD,GACnB8D,EAAS,IAAKlD,GAAOA,EAAKkD,GAAUA,GACxC,IAAK,IAAIC,EAAI,EAAGA,EAAID,IAAUC,EAAG,CAC/B,IAAIb,EAASe,EAAGjE,EAAIM,EAAKM,GACzB,GAAIhC,EAAMsE,EAAQ5C,GAAM,MACxBA,EAAM4C,CACR,CACA,OAAO5C,CACT,CAEA,SAAS4D,EAAKD,EAAIrD,GAChB,IAAIgD,EAAI,SAAS5D,GACfA,EAAGmE,gBAAgBH,EAAQhE,EAAIA,EAAGoE,YAAaH,EAAIrD,GACrD,EAEA,OADAgD,EAAES,QAAS,EACJT,CACT,CAEA,SAASU,EAAOtE,EAAIiE,EAAIrD,EAAKT,GAC3B,IAAsCoE,EAAlCC,EAAaxE,EAAGyE,iBAChBV,EAAIS,EAAWnF,OACnB,MAAO0E,IACLQ,EAASC,EAAWT,GAAGW,KACvB3E,EAAMC,EAAIuE,EAAQP,EAAQhE,EAAIuE,EAAQN,EAAIrD,GAAMT,EAEpD,CAEA,SAASwE,EAAY3E,EAAIG,GACvB,GAAIH,EAAG4E,oBAAqB,CAC1B,IAAsCC,EAAlCL,EAAaxE,EAAGyE,iBAChBV,EAAIS,EAAWnF,OACnB,MAAO0E,IACLc,EAAYL,EAAWT,GACvBhE,EAAMC,EAAI6E,EAAUC,OAAQD,EAAUH,KAAMvE,GAE9C,OAAO,CACT,CACF,CAEA,SAAS4E,EAAU/E,EAAIgF,GACjBhF,EAAGsD,MAAMC,YACE,KAATyB,IAAchF,EAAGsD,MAAMC,aAAeyB,IAI5ChF,EAAGsD,MAAMC,YAAcyB,EACvBhF,EAAGiF,GAAG,aAAcC,GACpBlF,EAAGiF,GAAG,YAAaE,GACrB,CAEA,IAAIC,EAAuB,CAAC,SAAS,EAAM,UAAU,EAAM,UAAU,EAAM,UAAU,GAErF,SAASF,EAAiBlF,EAAIqF,GACvBrF,EAAGsD,MAAMgC,gBAAmBF,EAAqBG,eAAeF,IACnE7B,EAAYxD,EAChB,CAEA,SAASwD,EAAYxD,GACnBA,EAAGsD,MAAMC,YAAc,KACvBvD,EAAGwF,IAAI,aAAcN,GACrBlF,EAAGwF,IAAI,YAAaL,EACtB,CAEA,SAASA,EAAoBnF,EAAIyF,GAC/B,IAAIC,EAAMvC,EAAUnD,GACpB,GAAI0F,EAAM,GAAqB,UAAhBD,EAAME,OAAoB,CAEvC,IADA,IAAIC,EAAMH,EAAMrF,KAAKyF,KAAK,MAAOC,EAAM,GAC9B/B,EAAI,EAAGA,EAAI2B,IAAO3B,EAAG+B,GAAOF,EACrC5F,EAAG+F,iBAAiBD,EACtB,CACF,CAEA,SAASE,EAAqBhG,EAAIqF,IACd,iBAAPA,IAAoB,OAAO5D,KAAK4D,IAAe,UAAPA,KACnDrF,EAAGiG,aAAaC,GAChBlG,EAAGsD,MAAMgC,gBAAiB,EAC1BtF,EAAGwF,IAAI,aAAcQ,GACrBhG,EAAGwF,IAAI,YAAaQ,GACtB,CAUA,SAASG,EAAUnG,GACjBA,EAAGoG,cAAa,GAChBpG,EAAGqG,UAAUrG,EAAGoE,YAClB,CAEA,SAASkC,EAAWC,GAClB,IAAIC,EAAWC,SAASC,yBACpBC,EAAQF,SAASG,cAAc,SAKnC,OAJAD,EAAME,aAAa,OAAQ,QAC3BF,EAAMG,MAAMC,MAAQ,OACpBP,EAASQ,YAAYP,SAASQ,eAAeV,EAAM,OACnDC,EAASQ,YAAYL,GACdH,CACT,CAEA,SAASU,EAASlH,EAAIuG,EAAK3C,GACrB5D,EAAGmH,WACLnH,EAAGmH,WAAWb,EAAWC,GAAM3C,EAAG,CAACwD,QAAQ,IAE3CxD,EAAEyD,OAAOd,EAAK,IAClB,CAEA,SAASe,EAActH,EAAIuH,GACzB,IAAIxE,EAAQ/C,EAAGoE,YAAapB,EAAMhD,EAAGa,SAASkC,EAAO,EAAG,QACxD/C,EAAGS,aAAa8G,EAAGvH,EAAGK,SAAS0C,EAAOC,IAAOD,EAAOC,GACpDhD,EAAGqG,UAAUrD,EACf,CAEA,SAASwE,EAAgBxH,GACvB,IAAIM,EAAMN,EAAGoE,YAAarF,EAAOuB,EAAIvB,KAAMC,EAAKsB,EAAItB,GAChDyI,EAAQ,GACZ,MAAO1I,GAAQiB,EAAG4B,YAAa,CAE7B,IADA,IAAIxB,EAAOJ,EAAGuB,QAAQxC,GACbgF,EAAU,MAAN/E,EAAaoB,EAAKf,OAASL,EAAI+E,EAAI,GAAI,CAC9C/E,EAAKoB,EAAKgC,SAAS2B,GACvB,GAAU,KAAN/E,EACFyI,EAAMrI,KAAK,UACR,GAAU,KAANJ,EACPyI,EAAMrI,KAAK,UACR,GAAU,KAANJ,EACPyI,EAAMrI,KAAK,UACR,GAAI,WAAWqC,KAAKzC,MAASyI,EAAMpI,QAAUoI,EAAM5H,OAASb,GAC/D,OAAOgB,EAAGmE,gBAAgBxF,EAAII,EAAMgF,GACxC,GACEhF,EAAMC,EAAK,IACf,CACF,CApDAP,EAAKiJ,QAAU,SAAU1H,GACvBA,EAAGqG,UAAUrG,EAAGoE,aAChBpE,EAAGoG,cAAcpG,EAAG2H,gBACpB3H,EAAGiF,GAAG,SAAU,WAAajF,EAAGoG,cAAa,EAAQ,EACvD,EAqDA3H,EAAKmJ,WAAa,SAAS5H,GACzBD,EAAMC,EAAIA,EAAGoE,UAAU,SAAUpE,EAAGoE,UAAU,QAAQ,EACxD,EAGA3F,EAAKoJ,cAAgBnE,EAAS,SAAS1D,GACrC,IAAI+C,EAAQ/C,EAAGoE,YAAapB,EAAMhD,EAAG+B,QAAQpD,EAAIoE,EAAMhE,OACnDqB,EAAOJ,EAAGK,SAAS0C,EAAOC,GACzB,KAAKvB,KAAKrB,KACbA,GAAQ,KACR4C,EAAMrE,EAAIoE,EAAMhE,KAAO,EAAG,IAE5BgB,EAAMC,EAAI+C,EAAOC,EAAK,OAAQ5C,EAChC,GAEA3B,EAAKqJ,aAAe,SAAS9H,GAC3Bd,EAAUc,EAAG+H,gBACb5B,EAAUnG,EACZ,EAEAvB,EAAKuJ,KAAO,SAAShI,GACnB,IAAI+C,EAAQ/C,EAAGoE,YACfpE,EAAGS,aAAajB,EAAY2D,EAAUnD,IAAM+C,EAAOA,EAAO,SAC1D/C,EAAGiI,aAAalF,EAAO/C,EAAGoE,YAC5B,EAEA3F,EAAKyJ,QAAU,SAASlI,GACtBA,EAAG+F,iBAAiBnG,IAAe,SAAU,QAC/C,EAEAnB,EAAK0J,YAAcjE,EAAKvD,EAAQ,GAEhClC,EAAK2J,aAAelE,EAAKvD,GAAS,GAElClC,EAAK4J,WAAa,SAASrI,GAAMsE,EAAOtE,EAAIW,EAAQ,GAAG,EAAQ,EAE/DlC,EAAK6J,kBAAoB,SAAStI,GAChC2E,EAAY3E,GAAI,IAAUsE,EAAOtE,EAAIW,EAAQ,GAAG,EAClD,EAEAlC,EAAK8J,mBAAqB,SAASvI,GACjC2E,EAAY3E,GAAI,IAAUsE,EAAOtE,EAAIW,GAAS,GAAG,EACnD,EAEAlC,EAAK+J,YAActE,EAAKpD,EAAQ,GAEhCrC,EAAKgK,aAAevE,EAAKpD,GAAS,GAElCrC,EAAKiK,SAAW,SAAS1I,GAAMsE,EAAOtE,EAAIc,EAAQ,EAAG,OAAS,EAE9DrC,EAAKkK,iBAAmB,SAAS3I,GAAMsE,EAAOtE,EAAIc,GAAS,EAAG,OAAS,EAEvErC,EAAKmK,SAAW1E,EAAKnD,EAAQ,GAE7BtC,EAAKoK,aAAe3E,EAAKnD,GAAS,GAElCtC,EAAKqK,kBAAoB5E,EAAK9C,GAAS,GAEvC3C,EAAKsK,gBAAkB7E,EAAK9C,EAAQ,GAEpC3C,EAAKuK,kBAAoB9E,EAAK7C,GAAc,GAE5C5C,EAAKwK,iBAAmB/E,EAAK7C,EAAa,GAE1C5C,EAAKyK,iBAAmBhF,EAAKjC,GAAa,GAE1CxD,EAAK0K,gBAAkBjF,EAAKjC,EAAY,GAExCxD,EAAK2K,aAAe,SAASpJ,GAAMsE,EAAOtE,EAAIiC,EAAY,EAAG,OAAS,EAEtExD,EAAK4K,qBAAuB,SAASrJ,GACnCD,EAAMC,EAAIA,EAAGoE,YAAanC,EAAWjC,EAAIA,EAAGoE,YAAa,GAAI,OAC/D,EAEA3F,EAAK6K,SAAW,SAAStJ,GAAMsE,EAAOtE,EAAIqC,EAAQ,EAAG,OAAS,EAE9D5D,EAAK8K,iBAAmB,SAASvJ,GAAMsE,EAAOtE,EAAIqC,GAAS,EAAG,OAAS,EAEvE5D,EAAK+K,YAActF,EAAK7B,EAAQ,GAEhC5D,EAAKgL,aAAevF,EAAK7B,GAAS,GAElC5D,EAAKiL,SAAW,SAAS1J,GACvB,IAAIuE,EAASvE,EAAGoE,YAChBpE,EAAGiI,aAAajE,EAAQhE,EAAIuE,EAAQlC,EAAQ,GAAIkC,EAClD,EAEA9F,EAAKkL,eAAiB,SAAS3J,GAC7B,IAAI4J,EAAYvH,EAAOrC,EAAIA,EAAGoE,aAAc,GACxCyF,EAAUxH,EAAOrC,EAAI4J,EAAW,GAChCE,EAAWzH,EAAOrC,EAAI6J,EAAS,GAC/BE,EAAa1H,EAAOrC,EAAI8J,GAAW,GACvC9J,EAAGS,aAAaT,EAAGK,SAAS0J,EAAYD,GACxB9J,EAAGK,SAASwJ,EAASE,GACrB/J,EAAGK,SAASuJ,EAAWC,GAAUD,EAAWE,EAC9D,EAEArL,EAAKuL,eAAiBtG,EAAS8D,GAE/B/I,EAAKwL,aAAe,SAASjK,GAC3B,IAAIM,EAAMN,EAAGoE,YAAanE,EAAOK,EAAItB,GACjCkB,EAAKI,EAAItB,GAAIoB,EAAOJ,EAAGuB,QAAQjB,EAAIvB,MACvC,MAAOkB,GAAQ,KAAKwB,KAAKrB,EAAKgC,OAAOnC,EAAO,MAAOA,EACnD,MAAOC,EAAKE,EAAKf,QAAU,KAAKoC,KAAKrB,EAAKgC,OAAOlC,MAAQA,EACzDF,EAAGS,aAAa,IAAK9B,EAAI2B,EAAIvB,KAAMkB,GAAOtB,EAAI2B,EAAIvB,KAAMmB,GAC1D,EAEAzB,EAAKyL,SAAWxG,EAAS,SAAS1D,GAChCA,EAAG+F,iBAAiB,KAAM,QAC5B,GAGAtH,EAAK0L,yBAA2BzG,EAAS,SAAS1D,GAChDA,EAAG6D,YAAY,iBACjB,GAEApF,EAAK2L,eAAiB1G,EAAS,SAAS1D,GACtCsH,EAActH,EAAI,SAASqK,GACzB,IAAIC,EAASD,EAAEE,OAAO,MACtB,OAAe,GAAXD,EAAqBD,EAClBA,EAAE3I,MAAM,EAAG4I,GAAUD,EAAEjI,OAAOkI,GAAQE,cACzCH,EAAE3I,MAAM4I,EAAS,GAAGG,aAC1B,EACF,GAEAhM,EAAKiM,WAAahH,EAAS,SAAS1D,GAClCsH,EAActH,EAAI,SAASqK,GAAK,OAAOA,EAAEG,aAAe,EAC1D,GAEA/L,EAAKkM,aAAejH,EAAS,SAAS1D,GACpCsH,EAActH,EAAI,SAASqK,GAAK,OAAOA,EAAEI,aAAe,EAC1D,GAGAhM,EAAKmM,eAAiBlH,EAAS,QAE/BjF,EAAKoM,aAAe,SAAS7K,GAC3BA,EAAG6D,YAAY,eACfsC,EAAUnG,EACZ,EAEAvB,EAAKqM,QAAUpH,EAAS,SAAS1D,GAAMA,EAAG+F,iBAAiB,KAAM,MAAQ,GAEzEtH,EAAKsM,SAAW,SAAS/K,GACvB,IAAI8D,EAASX,EAAUnD,GAAI,GAC3B,GAAc,MAAV8D,GAAkBA,EAAS,EAAG,OAAO9D,EAAGqG,UAAUvC,EAAS,GAE/DoD,EAASlH,EAAI,YAAa,SAASb,GACjC,IAAI6L,EACA7L,IAAQ8L,MAAMD,EAAMvH,OAAOtE,KAAS6L,IAAY,EAAJA,IAAUA,EAAM,GAChEhL,EAAGqG,UAAU2E,EAAM,EACrB,EACF,EAEAvM,EAAKyM,cAAgB,SAASlL,GAC5BA,EAAGmL,gBAAgBhI,EAAUnD,GAAI,IAASA,EAAGoL,UAAU,cACzD,EAEA3M,EAAK4M,qBAAuB,SAASrL,GACnCA,EAAGiI,aAAajI,EAAGoE,UAAU,QAASpE,EAAGoE,UAAU,UACrD,EAEA3F,EAAK6M,gBAAkB5H,EAAS,aAEhCjF,EAAK8M,kBAAoB,SAAsBvL,GAC7CA,EAAGsD,MAAMgC,gBAAiB,EAC1BtF,EAAGwL,UAAUtF,GACblG,EAAGiF,GAAG,aAAce,GACpBhG,EAAGiF,GAAG,YAAae,EACrB,EAEAxH,EAAWiN,MAAQ,CAACC,KAAM3L,EAAO6H,WAAYjD,EAAajB,SAAUA,GAGpE,IAAIiI,EAASnN,EAAWmN,OAAOF,MAAQjN,EAAWoN,gBAAgB,CAChE,SAAU,aACV,SAAU,gBACV,QAAS,eACT,SAAU,OACV,QAAS,UACT,aAAc,UACd,eAAgB,UAChB,SAAU,cACV,SAAU,eACV,MAAS,cACT,KAAQ,eACR,SAAU,aACV,OAAU,oBACV,SAAU,qBACV,UAAa,qBACb,QAAS,cACT,QAAS,eACT,YAAa,cACb,WAAY,eACZ,QAAS,WACT,gBAAiB,mBACjB,SAAU,WACV,SAAU,eACV,KAAQ,WACR,GAAM,eACN,SAAU,cACV,SAAU,YACV,IAAO,YACP,KAAQ,cACR,QAAS,oBACT,SAAU,kBACV,OAAU,oBACV,SAAY,kBACZ,UAAW,oBACX,YAAa,mBACb,QAAS,oBACT,QAAS,mBACT,QAAS,mBACT,QAAS,kBACT,QAAS,eACT,gBAAiB,uBACjB,aAAc,WACd,qBAAsB,mBACtB,aAAc,cACd,aAAc,eACd,mBAAoB,WACpB,aAAc,iBACd,aAAc,iBACd,YAAa,eACb,SAAU,WACV,SAAU,2BACV,QAAS,iBACT,QAAS,aACT,QAAS,eACT,QAAS,gBACT,SAAU,iBACV,eAAgB,iBAChB,SAAU,iBACV,QAAS,iBACT,WAAY,iBACZ,eAAgB,OAChB,cAAe,aACf,cAAe,WACf,SAAU,qBACV,SAAU,qBACV,SAAU,eACV,cAAe,UACf,QAAS,eACT,MAAS,mBACT,SAAU,UACV,IAAO,aACP,UAAW,WACX,aAAc,gBACd,gBAAiB,uBACjB,gBAAiB,OACjB,gBAAiB,OACjB,WAAY,UACZ,WAAY,OACZ,WAAY,QACZ,WAAY,YACZ,aAAc,kBACd,SAAU,oBACV,YAAe,YAGb1F,EAAY,CAAC,SAAU1C,GAC3B,SAASqI,EAAUC,GACjB5F,EAAU4F,GAAK,SAAS9L,GAAM+E,EAAU/E,EAAI8L,EAAI,EAChDH,EAAO,QAAUG,GAAK,SAAS9L,GAAM+E,EAAU/E,EAAI8L,EAAI,EACvD1G,EAAqB,QAAU0G,IAAK,CACtC,CACA,IAAK,IAAI/H,EAAI,EAAGA,EAAI,KAAMA,EAAG8H,EAAUE,OAAOhI,IAC9C8H,EAAU,IACZ,E,2HC5hBIG,EAAgC,IAAIC,IAAI,cACxCC,EAAgC,IAAID,IAAI,cACxCE,EAAgC,IAAIF,IAAI,cACxCG,EAAgC,IAAIH,IAAI,aACxCI,EAAgC,IAAIJ,IAAI,cACxCK,EAA0B,IAA4B,KACtDC,EAAqC,IAAgCP,GACrEQ,EAAqC,IAAgCN,GACrEO,EAAqC,IAAgCN,GACrEO,EAAqC,IAAgCN,GACrEO,EAAqC,IAAgCN,GAEzEC,EAAwBlN,KAAK,CAAClB,EAAOC,GAAI,0jBAA0jBoO,uDAAwFC,0WAA2YC,wFAAyHC,4DAA6FC,0NAA4P,KAExhD,S,kBCZA,SAAUpO,GAENA,EAAI,EAAQ,OAAsB,EAAQ,OAAiC,EAAQ,OAKtF,EAPD,CAOG,SAASC,GACV,aAEA,IAAIC,EAAOD,EAAWE,SAClBC,EAAMH,EAAWG,IAGrB,SAASiO,EAAe3L,EAAK8B,EAAOnC,GAClC,GAAIA,EAAM,GAAiB,GAAZmC,EAAM/D,GAAS,OAAOiC,EAAIc,QAAQpD,EAAIoE,EAAMhE,KAAO,IAClE,IAAIA,EAAOkC,EAAIM,QAAQwB,EAAMhE,MAC7B,GAAI6B,EAAM,GAAKmC,EAAM/D,IAAMD,EAAKM,OAAQ,OAAO4B,EAAIc,QAAQpD,EAAIoE,EAAMhE,KAAO,EAAG,IAE/E,IADA,IAAqB8N,EAAjBvJ,EAAQ,QAAewJ,EAAW/J,EAAM/D,GACnCsB,EAAMwM,EAAUC,EAAInM,EAAM,EAAI,EAAI7B,EAAKM,OAAQ0E,EAAI,EAAGzD,GAAOyM,EAAGzM,GAAOM,EAAKmD,IAAK,CACxF,IAAI5B,EAAOpD,EAAKqD,OAAOxB,EAAM,EAAIN,EAAM,EAAIA,GACvC0M,EAAc,KAAR7K,GAAe3D,EAAWyO,WAAW9K,GAAQ,IAAM,IAE7D,GADW,KAAP6K,GAAc7K,EAAKqI,eAAiBrI,IAAM6K,EAAM,KACvC,SAAT1J,EACS,KAAP0J,GAAc1J,EAAQ,KAAMuJ,EAAOG,GAClCF,EAAWxM,EAAMM,OACjB,GAAa,MAAT0C,GACLuJ,GAAQG,EAAK,CAEf,GADY,KAARH,GAAsB,KAAPG,GAAcpM,EAAM,GAAGN,IAC9B,KAARuM,GAAsB,KAAPG,GAAcpM,EAAM,EAAG,CACxC,GAAIN,GAAOwM,EAAW,EAAG,CAAED,EAAO,IAAK,QAAU,CAC5CvM,GACP,CACA,KACF,CAEJ,CACA,OAAO3B,EAAIoE,EAAMhE,KAAMuB,EACzB,CAEA,SAAS4M,EAAYlN,EAAIY,GACvBZ,EAAGmN,mBAAmB,SAASC,GAC7B,OAAIpN,EAAGqN,QAAQ/N,OAASU,EAAGiB,IAAIqM,QAAUF,EAAMG,QACtCX,EAAe5M,EAAGiB,IAAKmM,EAAM1I,KAAM9D,GAEnCA,EAAM,EAAIwM,EAAMnN,OAASmN,EAAMlN,IAC1C,EACF,CAmDA,SAASsN,EAAWxN,EAAIyN,GACtB,GAAIzN,EAAG0N,aAAc,OAAOlP,EAAWmP,KACvC3N,EAAG4N,UAAU,WAEX,IADA,IAAIC,EAAM7N,EAAGyE,iBAAiBpF,OAAQyO,EAAe,GAAIC,GAAQ,EACxDhK,EAAI,EAAGA,EAAI8J,EAAK9J,IAAK,CAC5B,IAAIW,EAAO1E,EAAGyE,iBAAiBV,GAAGW,KAClC,KAAIA,EAAK3F,MAAQgP,GAAjB,CACA,IAAIC,EAAKrP,EAAI+F,EAAK3F,MAAQ0O,EAAQ,EAAI,GAAI,GAC1CzN,EAAGS,aAAa,KAAMuN,EAAI,KAAM,eAChChO,EAAGiO,WAAWD,EAAGjP,KAAM,MAAM,GAC7B+O,EAAa1O,KAAK,CAACsF,KAAMsJ,EAAIlJ,OAAQkJ,IACrCD,EAAOrJ,EAAK3F,KAAO,CALY,CAMjC,CACAiB,EAAGkO,cAAcJ,EACnB,GACA9N,EAAG6D,YAAY,aACjB,CAMA,SAASsK,EAAOnO,EAAIM,GAClB,IAAIyC,EAAQzC,EAAItB,GAAIgE,EAAMD,EAAOhE,EAAOiB,EAAGuB,QAAQjB,EAAIvB,MACvD,MAAOgE,GAASvE,EAAWyO,WAAWlO,EAAKqD,OAAOW,EAAQ,MAAOA,EACjE,MAAOC,EAAMjE,EAAKM,QAAUb,EAAWyO,WAAWlO,EAAKqD,OAAOY,MAASA,EACvE,MAAO,CAAC/C,KAAMtB,EAAI2B,EAAIvB,KAAMgE,GAAQ7C,GAAIvB,EAAI2B,EAAIvB,KAAMiE,GAAMoL,KAAMrP,EAAK2C,MAAMqB,EAAOC,GACtF,CAqCA,SAASqL,EAAqBrO,EAAIY,GAEhC,IADA,IAAI0N,EAAStO,EAAGyE,iBAAkB8J,EAAY,GACrCxK,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IAAK,CACtC,IAAIqJ,EAAQkB,EAAOvK,GACfyK,EAAYxO,EAAGgB,SACfoM,EAAMtI,OAAQlE,EAAK,OAAQwM,EAAMtI,OAAO3D,YACxCsN,EAAUzO,EAAGgB,SACboM,EAAM1I,KAAM9D,EAAK,OAAQwM,EAAM1I,KAAKvD,YACxCqN,EAAUrN,WAAwC,MAA3BiM,EAAMtI,OAAO3D,WAChCiM,EAAMtI,OAAO3D,WAAanB,EAAG0O,aAAatB,EAAMtI,OAAQ,OAAO6J,KACnEF,EAAQtN,WAAsC,MAAzBiM,EAAM1I,KAAKvD,WAC5BiM,EAAM1I,KAAKvD,WAAanB,EAAG0O,aAAatB,EAAM1I,KAAM,OAAOiK,KAC/D,IAAIC,EAAW,CAAC9J,OAAQ0J,EAAW9J,KAAM+J,GACzCF,EAAUnP,KAAKgO,GACfmB,EAAUnP,KAAKwP,EACjB,CACA5O,EAAGkO,cAAcK,EACnB,CAIA,SAASM,EAAgBP,EAAQrO,EAAMC,GACrC,IAAK,IAAI6D,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IACjC,GAAiD,GAA7CvF,EAAWsQ,OAAOR,EAAOvK,GAAG9D,OAAQA,IACK,GAAzCzB,EAAWsQ,OAAOR,EAAOvK,GAAG7D,KAAMA,GAAU,OAAO,EACzD,OAAO,CACT,CA3IAzB,EAAKsQ,cAAgB,SAAS/O,GAAMkN,EAAYlN,GAAK,EAAI,EACzDvB,EAAKuQ,eAAiB,SAAShP,GAAMkN,EAAYlN,EAAI,EAAI,EAEzDvB,EAAKwQ,aAAe,SAASjP,GAC3B,IAAIkP,EAAOlP,EAAGmP,gBACd,IAAKnP,EAAG4E,oBAAqB,CAC3B,IAAIwK,EAAoBpP,EAAGqP,aAAaH,EAAKI,IAAMJ,EAAKK,aAAc,SAClEvP,EAAGoE,YAAYrF,MAAQqQ,GACzBpP,EAAG6D,YAAY,WACnB,CACA7D,EAAGwP,SAAS,KAAMN,EAAKI,IAAMtP,EAAGyP,oBAClC,EACAhR,EAAKiR,eAAiB,SAAS1P,GAC7B,IAAIkP,EAAOlP,EAAGmP,gBACd,IAAKnP,EAAG4E,oBAAqB,CAC3B,IAAI+K,EAAiB3P,EAAGqP,aAAaH,EAAKI,IAAK,SAAS,EACpDtP,EAAGoE,YAAYrF,MAAQ4Q,GACzB3P,EAAG6D,YAAY,aACnB,CACA7D,EAAGwP,SAAS,KAAMN,EAAKI,IAAMtP,EAAGyP,oBAClC,EAEAhR,EAAKmR,qBAAuB,SAAS5P,GAEnC,IADA,IAAIsO,EAAStO,EAAGyE,iBAAkBoL,EAAa,GACtC9L,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IAEjC,IADA,IAAI9D,EAAOqO,EAAOvK,GAAG9D,OAAQC,EAAKoO,EAAOvK,GAAG7D,KACnCnB,EAAOkB,EAAKlB,KAAMA,GAAQmB,EAAGnB,OAAQA,EACtCmB,EAAGnB,KAAOkB,EAAKlB,MAAQA,GAAQmB,EAAGnB,MAAiB,GAATmB,EAAGlB,IACjD6Q,EAAWzQ,KAAK,CAAC0F,OAAQ/F,GAAQkB,EAAKlB,KAAOkB,EAAOtB,EAAII,EAAM,GAC7C2F,KAAM3F,GAAQmB,EAAGnB,KAAOmB,EAAKvB,EAAII,KAExDiB,EAAGkO,cAAc2B,EAAY,EAC/B,EAEApR,EAAKqR,mBAAqB,SAAS9P,GACjC,IAAIoN,EAAQpN,EAAGyE,iBAAiB,GAChCzE,EAAGiI,aAAamF,EAAMtI,OAAQsI,EAAM1I,KAAM,CAACqL,QAAQ,GACrD,EAEAtR,EAAKuR,WAAa,SAAShQ,GAEzB,IADA,IAAIsO,EAAStO,EAAGyE,iBAAkBwL,EAAW,GACpClM,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IAAK,CACtC,IAAIqJ,EAAQkB,EAAOvK,GACnBkM,EAAS7Q,KAAK,CAAC0F,OAAQnG,EAAIyO,EAAMnN,OAAOlB,KAAM,GAC/B2F,KAAM/F,EAAIyO,EAAMlN,KAAKnB,KAAO,EAAG,IAChD,CACAiB,EAAGkO,cAAc+B,EACnB,EAoBAxR,EAAKyR,gBAAkB,SAASlQ,GAAM,OAAOwN,EAAWxN,GAAI,EAAQ,EAEpEvB,EAAK0R,iBAAmB,SAASnQ,GAAM,OAAOwN,EAAWxN,GAAI,EAAO,EASpEvB,EAAK2R,qBAAuB,SAASpQ,GACnC,IAAIC,EAAOD,EAAGoE,UAAU,QAASlE,EAAKF,EAAGoE,UAAU,MAC/CiM,EAAWrQ,EAAGsD,MAAMgN,qBAAuBtQ,EAAGiB,IAAIC,IACtD,GAAmC,GAA/B1C,EAAWsQ,OAAO7O,EAAMC,GAAU,CACpC,IAAIkO,EAAOD,EAAOnO,EAAIC,GACtB,IAAKmO,EAAKA,KAAM,OAChBpO,EAAGiI,aAAamG,EAAKnO,KAAMmO,EAAKlO,IAChCmQ,GAAW,CACb,KAAO,CACL,IAAIjQ,EAAOJ,EAAGK,SAASJ,EAAMC,GACzBqQ,EAAQF,EAAW,IAAIG,OAAO,MAAQpQ,EAAO,OAASA,EACtDqQ,EAAMzQ,EAAG0Q,gBAAgBH,EAAOrQ,GAChCyQ,EAAQF,EAAIG,WAKhB,GAJKD,IACHF,EAAMzQ,EAAG0Q,gBAAgBH,EAAO5R,EAAIqB,EAAG4B,YAAa,IACpD+O,EAAQF,EAAIG,aAETD,GAAS9B,EAAgB7O,EAAGyE,iBAAkBgM,EAAIxQ,OAAQwQ,EAAIvQ,MAAO,OAC1EF,EAAG6Q,aAAaJ,EAAIxQ,OAAQwQ,EAAIvQ,KAClC,CACImQ,IACFrQ,EAAGsD,MAAMgN,oBAAsBtQ,EAAGiB,IAAIC,IAC1C,EAEAzC,EAAKqS,4BAA8B,SAAS9Q,GAC1C,IAAI+Q,EAAa/Q,EAAGoE,UAAU,UAAW4M,EAAWhR,EAAGoE,UAAU,QACjE3F,EAAK2R,qBAAqBpQ,GACqB,GAA3CxB,EAAWsQ,OAAOiC,EAAYC,IAChChR,EAAGiB,IAAIiN,cAAclO,EAAGiB,IAAIwD,iBACvBwM,OAAO,SAAU/P,GAChB,OAAOA,EAAI4D,QAAUiM,GAAc7P,EAAIwD,MAAQsM,CACjD,GAER,EAoBAvS,EAAKyS,oBAAsB,SAASlR,GAAMqO,EAAqBrO,GAAK,EAAI,EACxEvB,EAAK0S,oBAAsB,SAASnR,GAAMqO,EAAqBrO,EAAI,EAAI,EASvE,IAAIoR,EAAS,SACb,SAASC,EAAsBrR,GAE7B,IADA,IAAIsO,EAAStO,EAAGyE,iBAAkB8J,EAAY,GACrCxK,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IAAK,CACtC,IAAIqJ,EAAQkB,EAAOvK,GAAIzD,EAAM8M,EAAM1I,KAAM4M,EAAUtR,EAAGuR,eAAejR,GAAM,GAC3E,IAAKgR,EAAS,OAAO,EACrB,OAAS,CACP,IAAIE,EAAUxR,EAAGuR,eAAejR,EAAK,GACrC,IAAKkR,EAAS,OAAO,EACrB,GAAIA,EAAQxS,IAAMoS,EAAOhP,OAAOgP,EAAOK,QAAQH,EAAQtS,IAAM,GAAI,CAC/D,IAAI8N,EAAWnO,EAAI2S,EAAQhR,IAAIvB,KAAMuS,EAAQhR,IAAItB,GAAK,GACtD,GAAiD,GAA7CR,EAAWsQ,OAAOhC,EAAUM,EAAMnN,SACY,GAA9CzB,EAAWsQ,OAAO0C,EAAQlR,IAAK8M,EAAMlN,MAGlC,CACLqO,EAAUnP,KAAK,CAAC0F,OAAQgI,EAAUpI,KAAM8M,EAAQlR,MAChD,KACF,CAJE,GADAgR,EAAUtR,EAAGuR,eAAeD,EAAQhR,KAAM,IACrCgR,EAAS,OAAO,CAKzB,CACAhR,EAAM3B,EAAI6S,EAAQlR,IAAIvB,KAAMyS,EAAQlR,IAAItB,GAAK,EAC/C,CACF,CAEA,OADAgB,EAAGkO,cAAcK,IACV,CACT,CASA,SAASmD,EAAS7E,GAChB,OAAQA,EAAc,kBAAkBpL,KAAKoL,GAAQA,OAAO8E,EAA7C,IACjB,CA6GA,SAASC,EAAU5R,EAAI6R,EAAeC,GACpC,GAAI9R,EAAG0N,aAAc,OAAOlP,EAAWmP,KAEvC,IADA,IAA+CoE,EAA3CzD,EAAStO,EAAGyE,iBAAkBuN,EAAS,GAClCjO,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IAAK,CACtC,IAAIqJ,EAAQkB,EAAOvK,GACnB,IAAIqJ,EAAMG,QAAV,CACA,IAAItN,EAAOmN,EAAMnN,OAAOlB,KAAMmB,EAAKkN,EAAMlN,KAAKnB,KAC9C,MAAOgF,EAAIuK,EAAOjP,OAAS,GAAKiP,EAAOvK,EAAI,GAAG9D,OAAOlB,MAAQmB,EAC3DA,EAAKoO,IAASvK,GAAG7D,KAAKnB,KACnBuP,EAAOvK,GAAG7D,KAAKlB,IAAIkB,IACxB8R,EAAO5S,KAAKa,EAAMC,EALS,CAM7B,CACI8R,EAAO3S,OAAQ0S,GAAW,EACzBC,EAAO5S,KAAKY,EAAG4B,YAAa5B,EAAG8B,YAEpC9B,EAAG4N,UAAU,WAEX,IADA,IAAIU,EAAS,GACJvK,EAAI,EAAGA,EAAIiO,EAAO3S,OAAQ0E,GAAK,EAAG,CACzC,IAAI9D,EAAO+R,EAAOjO,GAAI7D,EAAK8R,EAAOjO,EAAI,GAClChB,EAAQpE,EAAIsB,EAAM,GAAI+C,EAAMrE,EAAIuB,GAChC+R,EAAQjS,EAAGK,SAAS0C,EAAOC,GAAK,GAChC6O,EACFI,EAAMC,KAAK,SAASrT,EAAGC,GAAK,OAAOD,EAAIC,GAAKgT,EAAYjT,GAAKC,EAAI,EAAIgT,CAAW,GAEhFG,EAAMC,KAAK,SAASrT,EAAGC,GACrB,IAAIqT,EAAKtT,EAAE2L,cAAe4H,EAAKtT,EAAE0L,cAEjC,OADI2H,GAAMC,IAAMvT,EAAIsT,EAAIrT,EAAIsT,GACrBvT,EAAIC,GAAKgT,EAAYjT,GAAKC,EAAI,EAAIgT,CAC3C,GACF9R,EAAGS,aAAawR,EAAOlP,EAAOC,GAC1B+O,GAAUzD,EAAOlP,KAAK,CAAC0F,OAAQ/B,EAAO2B,KAAM/F,EAAIuB,EAAK,EAAG,IAC9D,CACI6R,GAAU/R,EAAGkO,cAAcI,EAAQ,EACzC,EACF,CAsEA,SAAS+D,EAAsBrS,EAAIzB,GACjCyB,EAAG4N,UAAU,WAEX,IADA,IAAIU,EAAStO,EAAGyE,iBAAkB6N,EAAU,GAAIC,EAAe,GACtDxO,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IAAK,CACtC,IAAIqJ,EAAQkB,EAAOvK,GACfqJ,EAAMG,SAAW+E,EAAQlT,KAAK2E,GAAIwO,EAAanT,KAAK,KACnDmT,EAAanT,KAAKb,EAAIyB,EAAGK,SAAS+M,EAAMnN,OAAQmN,EAAMlN,OAC7D,CACAF,EAAGwS,kBAAkBD,EAAc,SAAU,QACxC,IAA4BvE,EAAjC,IAASjK,EAAIuO,EAAQjT,OAAS,EAAO0E,GAAK,EAAGA,IAAK,CAC5CqJ,EAAQkB,EAAOgE,EAAQvO,IAC3B,KAAIiK,GAAMxP,EAAWsQ,OAAO1B,EAAM1I,KAAMsJ,GAAM,GAA9C,CACA,IAAII,EAAOD,EAAOnO,EAAIoN,EAAM1I,MAC5BsJ,EAAKI,EAAKnO,KACVD,EAAGS,aAAalC,EAAI6P,EAAKA,MAAOA,EAAKnO,KAAMmO,EAAKlO,GAHS,CAI3D,CACF,EACF,CAiFA,SAASuS,EAAUzS,GACjB,IAAIC,EAAOD,EAAGoE,UAAU,QAASlE,EAAKF,EAAGoE,UAAU,MACnD,GAAmC,GAA/B5F,EAAWsQ,OAAO7O,EAAMC,GAAU,CACpC,IAAIkO,EAAOD,EAAOnO,EAAIC,GACtB,IAAKmO,EAAKA,KAAM,OAChBnO,EAAOmO,EAAKnO,KACZC,EAAKkO,EAAKlO,EACZ,CACA,MAAO,CAACD,KAAMA,EAAMC,GAAIA,EAAIqQ,MAAOvQ,EAAGK,SAASJ,EAAMC,GAAKkO,KAAMA,EAClE,CAEA,SAASsE,EAAY1S,EAAI0C,GACvB,IAAIiQ,EAASF,EAAUzS,GACvB,GAAK2S,EAAL,CACA,IAAIpC,EAAQoC,EAAOpC,MACfE,EAAMzQ,EAAG0Q,gBAAgBH,EAAO7N,EAAUiQ,EAAOzS,GAAKyS,EAAO1S,OAE7DyC,EAAU+N,EAAIG,WAAaH,EAAImC,gBACjC5S,EAAGiI,aAAawI,EAAIxQ,OAAQwQ,EAAIvQ,OAEhCuQ,EAAMzQ,EAAG0Q,gBAAgBH,EAAO7N,EAAU/D,EAAIqB,EAAG4B,YAAa,GACpB5B,EAAG+B,QAAQpD,EAAIqB,EAAG8B,eACxDY,EAAU+N,EAAIG,WAAaH,EAAImC,gBACjC5S,EAAGiI,aAAawI,EAAIxQ,OAAQwQ,EAAIvQ,MACzByS,EAAOvE,MACdpO,EAAGiI,aAAa0K,EAAO1S,KAAM0S,EAAOzS,IAZrB,CAcrB,CA3VAzB,EAAKoU,YAAc,SAAS7S,GAC1BqR,EAAsBrR,IAAOA,EAAG6D,YAAY,YAC9C,EACApF,EAAK4S,sBAAwB,SAASrR,GACpC,IAAKqR,EAAsBrR,GAAK,OAAOxB,EAAWmP,IACpD,EAMAlP,EAAKqU,YAAc,SAAS9S,GAC1BA,EAAGmN,mBAAmB,SAASC,GAC7B,IAAIjL,EAAOnC,EAAGuR,eAAenE,EAAM1I,KAAM,EAAGgN,EAAS1R,EAAG+S,eAAe3F,EAAM1I,QAC7E,GAAIvC,GAAmD,GAA3C3D,EAAWsQ,OAAO3M,EAAK7B,IAAK8M,EAAM1I,MAAY,OAAOvC,EAAK7B,IACtE,IAAI0S,EAAOhT,EAAGuR,eAAenE,EAAM1I,MAAO,EAAGgN,EAAS1R,EAAG+S,eAAepU,EAAIyO,EAAM1I,KAAK3F,KAAMqO,EAAM1I,KAAK1F,GAAK,MAC7G,OAAOgU,GAAQrU,EAAIqU,EAAK1S,IAAIvB,KAAMiU,EAAK1S,IAAItB,GAAK,IAAMoO,EAAM1I,IAC9D,EACF,EAEAjG,EAAKwU,WAAa,SAASjT,GACzB,GAAIA,EAAG0N,aAAc,OAAOlP,EAAWmP,KAEvC,IADA,IAAIW,EAAStO,EAAGyE,iBAAkByO,EAAc,GAAIlF,EAAKhO,EAAG4B,YAAc,EAAGuR,EAAU,GAC9EpP,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IAAK,CACtC,IAAIqJ,EAAQkB,EAAOvK,GAAI9D,EAAOmN,EAAMnN,OAAOlB,KAAO,EAAGmB,EAAKkN,EAAMlN,KAAKnB,KACrEoU,EAAQ/T,KAAK,CAAC0F,OAAQnG,EAAIyO,EAAMtI,OAAO/F,KAAO,EAAGqO,EAAMtI,OAAO9F,IAChD0F,KAAM/F,EAAIyO,EAAM1I,KAAK3F,KAAO,EAAGqO,EAAM1I,KAAK1F,MACnC,GAAjBoO,EAAMlN,KAAKlB,IAAYoO,EAAMG,WAAWrN,EACxCD,EAAO+N,EAAIkF,EAAY9T,KAAKa,EAAMC,GAC7BgT,EAAY7T,SAAQ6T,EAAYA,EAAY7T,OAAS,GAAKa,GACnE8N,EAAK9N,CACP,CACAF,EAAG4N,UAAU,WACX,IAAK,IAAI7J,EAAI,EAAGA,EAAImP,EAAY7T,OAAQ0E,GAAK,EAAG,CAC9C,IAAI9D,EAAOiT,EAAYnP,GAAI7D,EAAKgT,EAAYnP,EAAI,GAC5ChF,EAAOiB,EAAGuB,QAAQtB,GACtBD,EAAGS,aAAa,GAAI9B,EAAIsB,EAAM,GAAItB,EAAIsB,EAAO,EAAG,GAAI,aAChDC,EAAKF,EAAG8B,WACV9B,EAAGS,aAAa,KAAO1B,EAAMJ,EAAIqB,EAAG8B,YAAa,KAAM,aAEvD9B,EAAGS,aAAa1B,EAAO,KAAMJ,EAAIuB,EAAI,GAAI,KAAM,YACnD,CACAF,EAAGkO,cAAciF,GACjBnT,EAAGoT,gBACL,EACF,EAEA3U,EAAK4U,aAAe,SAASrT,GAC3B,GAAIA,EAAG0N,aAAc,OAAOlP,EAAWmP,KAEvC,IADA,IAAIW,EAAStO,EAAGyE,iBAAkByO,EAAc,GAAIlF,EAAKhO,EAAG8B,WAAa,EAChEiC,EAAIuK,EAAOjP,OAAS,EAAG0E,GAAK,EAAGA,IAAK,CAC3C,IAAIqJ,EAAQkB,EAAOvK,GAAI9D,EAAOmN,EAAMlN,KAAKnB,KAAO,EAAGmB,EAAKkN,EAAMnN,OAAOlB,KAChD,GAAjBqO,EAAMlN,KAAKlB,IAAYoO,EAAMG,SAAStN,IACtCA,EAAO+N,EAAIkF,EAAY9T,KAAKa,EAAMC,GAC7BgT,EAAY7T,SAAQ6T,EAAYA,EAAY7T,OAAS,GAAKa,GACnE8N,EAAK9N,CACP,CACAF,EAAG4N,UAAU,WACX,IAAK,IAAI7J,EAAImP,EAAY7T,OAAS,EAAG0E,GAAK,EAAGA,GAAK,EAAG,CACnD,IAAI9D,EAAOiT,EAAYnP,GAAI7D,EAAKgT,EAAYnP,EAAI,GAC5ChF,EAAOiB,EAAGuB,QAAQtB,GAClBA,GAAQD,EAAG8B,WACb9B,EAAGS,aAAa,GAAI9B,EAAIsB,EAAO,GAAItB,EAAIsB,GAAO,aAE9CD,EAAGS,aAAa,GAAI9B,EAAIsB,EAAM,GAAItB,EAAIsB,EAAO,EAAG,GAAI,aACtDD,EAAGS,aAAa1B,EAAO,KAAMJ,EAAIuB,EAAI,GAAI,KAAM,YACjD,CACAF,EAAGoT,gBACL,EACF,EAEA3U,EAAK6U,sBAAwB,SAAStT,GACpCA,EAAGuT,cAAc,CAAEC,QAAQ,GAC7B,EAEA/U,EAAKgV,UAAY,SAASzT,GAExB,IADA,IAAIsO,EAAStO,EAAGyE,iBAAkBiP,EAAS,GAClC3P,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IAAK,CACtC,IAAIqJ,EAAQkB,EAAOvK,GAAI9D,EAAOmN,EAAMnN,OAChC8C,EAAQ9C,EAAKlB,KAAMiE,EAAMoK,EAAMlN,KAAKnB,KACxC,MAAOgF,EAAIuK,EAAOjP,OAAS,GAAKiP,EAAOvK,EAAI,GAAG9D,OAAOlB,MAAQiE,EAC3DA,EAAMsL,IAASvK,GAAG7D,KAAKnB,KACzB2U,EAAOtU,KAAK,CAAC2D,MAAOA,EAAOC,IAAKA,EAAK8B,QAASsI,EAAMG,SAAWtN,GACjE,CACAD,EAAG4N,UAAU,WAEX,IADA,IAAI+F,EAAS,EAAGrF,EAAS,GAChBvK,EAAI,EAAGA,EAAI2P,EAAOrU,OAAQ0E,IAAK,CAGtC,IAFA,IACyEW,EADrEkP,EAAMF,EAAO3P,GACbe,EAAS8O,EAAI9O,QAAUnG,EAAIiV,EAAI9O,OAAO/F,KAAO4U,EAAQC,EAAI9O,OAAO9F,IAC3DD,EAAO6U,EAAI7Q,MAAOhE,GAAQ6U,EAAI5Q,IAAKjE,IAAQ,CAClD,IAAI8U,EAAS9U,EAAO4U,EAChB5U,GAAQ6U,EAAI5Q,MAAK0B,EAAO/F,EAAIkV,EAAQ7T,EAAGuB,QAAQsS,GAAQxU,OAAS,IAChEwU,EAAS7T,EAAG8B,aACd9B,EAAGS,aAAa,IAAK9B,EAAIkV,GAASlV,EAAIkV,EAAS,EAAG,OAAOC,KAAK9T,EAAGuB,QAAQsS,EAAS,IAAI,GAAGxU,WACvFsU,EAEN,CACArF,EAAOlP,KAAK,CAAC0F,OAAQA,GAAUJ,EAAMA,KAAMA,GAC7C,CACA1E,EAAGkO,cAAcI,EAAQ,EAC3B,EACF,EAEA7P,EAAKsV,cAAgB,SAAS/T,GAC5BA,EAAG4N,UAAU,WAEX,IADA,IAAIoG,EAAahU,EAAGyE,iBAAiBpF,OAC5B0E,EAAI,EAAGA,EAAIiQ,EAAYjQ,IAAK,CACnC,IAAIqJ,EAAQpN,EAAGyE,iBAAiBV,GAC5BqJ,EAAMG,QACRvN,EAAGS,aAAaT,EAAGuB,QAAQ6L,EAAM1I,KAAK3F,MAAQ,KAAMJ,EAAIyO,EAAM1I,KAAK3F,KAAM,IAEzEiB,EAAGS,aAAaT,EAAGK,SAAS+M,EAAMnN,OAAQmN,EAAMlN,MAAOkN,EAAMnN,OACjE,CACAD,EAAGoT,gBACL,EACF,EAuCA3U,EAAKmT,UAAY,SAAS5R,GAAM4R,EAAU5R,GAAI,EAAM,EAAI,EACxDvB,EAAKwV,iBAAmB,SAASjU,GAAM4R,EAAU5R,GAAI,GAAO,EAAI,EAChEvB,EAAKyV,qBAAuB,SAASlU,GAAM4R,EAAU5R,GAAI,EAAO,EAAI,EACpEvB,EAAK0V,4BAA8B,SAASnU,GAAM4R,EAAU5R,GAAI,GAAQ,EAAI,EAE5EvB,EAAK2V,aAAe,SAASpU,GAC3B,IAAIqU,EAAQrU,EAAGsD,MAAMgR,iBACrB,GAAID,EAAO,MAAOA,EAAMhV,OAAQ,CAC9B,IAAIkV,EAAUF,EAAM/U,QAChBqR,EAAQ4D,EAAQC,OACpB,GAAI7D,EAEF,OADA0D,EAAMjV,KAAKmV,GACJvU,EAAGiI,aAAa0I,EAAM1Q,KAAM0Q,EAAMzQ,GAE7C,CACF,EAEAzB,EAAKgW,aAAe,SAASzU,GAC3B,IAAIqU,EAAQrU,EAAGsD,MAAMgR,iBACrB,GAAID,EAAO,MAAOA,EAAMhV,OAAQ,CAC9BgV,EAAMK,QAAQL,EAAMxU,OACpB,IAAI8Q,EAAQ0D,EAAMA,EAAMhV,OAAS,GAAGmV,OACpC,GAAK7D,EAGH,OAAO3Q,EAAGiI,aAAa0I,EAAM1Q,KAAM0Q,EAAMzQ,IAFzCmU,EAAMxU,KAGV,CACF,EAEApB,EAAKkW,eAAiB,SAAS3U,GAG7B,IAFA,IAAIsO,EAAStO,EAAGyE,iBACZ4P,EAAQrU,EAAGsD,MAAMgR,mBAAqBtU,EAAGsD,MAAMgR,iBAAmB,IAC7DvQ,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IAAK,CAGtC,IAFA,IAAI9D,EAAOqO,EAAOvK,GAAG9D,OAAQC,EAAKoO,EAAOvK,GAAG7D,KACxCyQ,EAAQrC,EAAOvK,GAAGwJ,QAAUvN,EAAG4U,YAAY3U,GAAQD,EAAG6U,UAAU5U,EAAMC,GACjE4U,EAAI,EAAGA,EAAInE,EAAMtR,OAAQyV,IAChC,GAAInE,EAAMmE,GAAGC,gBAAiB,CAC5BpE,EAAMmE,GAAGE,QACT,IAAK,IAAIC,EAAI,EAAGA,EAAIZ,EAAMhV,OAAQ4V,IAC5BZ,EAAMY,IAAMtE,EAAMmE,IACpBT,EAAMa,OAAOD,IAAK,GACtB,KACF,CAEEH,GAAKnE,EAAMtR,QACbgV,EAAMjV,KAAKY,EAAGmV,SAASlV,EAAMC,EAAI,CAAC6U,iBAAiB,EAAMK,gBAAgB,IAC7E,CACF,EAEA3W,EAAK4W,eAAiB,SAASrV,GAC7B,IAAIqU,EAAQrU,EAAGsD,MAAMgR,iBACrB,GAAID,EAAO,IAAK,IAAItQ,EAAI,EAAGA,EAAIsQ,EAAMhV,OAAQ0E,IAAKsQ,EAAMtQ,GAAGiR,QAC3DX,EAAMhV,OAAS,CACjB,EAEAZ,EAAK6W,gBAAkB,SAAStV,GAC9B,IAAIqU,EAAQrU,EAAGsD,MAAMgR,iBAAkBhG,EAAS,GAChD,GAAI+F,EAAO,IAAK,IAAItQ,EAAI,EAAGA,EAAIsQ,EAAMhV,OAAQ0E,IAAK,CAChD,IAAI4M,EAAQ0D,EAAMtQ,GAAGyQ,OAChB7D,EAGHrC,EAAOlP,KAAK,CAAC0F,OAAQ6L,EAAM1Q,KAAMyE,KAAMiM,EAAMzQ,KAF7CmU,EAAMa,OAAOnR,IAAK,EAGtB,CACIuK,EAAOjP,QACTW,EAAGkO,cAAcI,EAAQ,EAC7B,EAqBA7P,EAAK8W,eAAiB,SAASvV,GAC7B,GAAIA,EAAG4E,oBAAqB,OAAOpG,EAAWmP,KAE9C3N,EAAG4N,UAAU,WAIX,IAHA,IAAI4H,EAAUxV,EAAGyE,iBACbgR,EAAazV,EAAGoL,UAAU,cAErBrH,EAAIyR,EAAQnW,OAAS,EAAG0E,GAAK,EAAGA,IAAK,CAC5C,IAAIQ,EAASiR,EAAQzR,GAAGW,KACpBgR,EAAgB1V,EAAGK,SAAS,CAACtB,KAAMwF,EAAOxF,KAAMC,GAAI,GAAIuF,GACxDoR,EAASnX,EAAWoX,YAAYF,EAAe,KAAM1V,EAAGoL,UAAU,YAGlEyK,EAAY7V,EAAGa,SAAS0D,GAAS,EAAG,QAAQ,GAEhD,GAAImR,IAAkB,KAAKjU,KAAKiU,IAAkBC,EAASF,GAAc,EAAG,CAC1E,IAAIK,EAAa,IAAInX,EAAI4F,EAAOxF,KAC9BP,EAAWuX,WAAWL,EAAeC,EAASF,EAAYA,IAGxDK,EAAW9W,IAAMuF,EAAOvF,KAAI6W,EAAYC,EAC9C,CAEA9V,EAAGS,aAAa,GAAIoV,EAAWtR,EAAQ,UACzC,CACF,EACF,EAEA9F,EAAKuX,aAAe,SAAShW,GAC3BA,EAAG4N,UAAU,WAEX,IADA,IAAIU,EAAStO,EAAGyE,iBACPV,EAAIuK,EAAOjP,OAAS,EAAG0E,GAAK,EAAGA,IACtC/D,EAAGS,aAAa,GAAI6N,EAAOvK,GAAGe,OAAQnG,EAAI2P,EAAOvK,GAAG7D,KAAKnB,MAAO,WAClEiB,EAAGoT,gBACL,EACF,EAEA3U,EAAKwX,eAAiB,SAASjW,GAC7BqS,EAAsBrS,EAAI,SAASb,GAAO,OAAOA,EAAIqL,aAAe,EACtE,EACA/L,EAAKyX,iBAAmB,SAASlW,GAC/BqS,EAAsBrS,EAAI,SAASb,GAAO,OAAOA,EAAIsL,aAAe,EACtE,EAEAhM,EAAK0X,eAAiB,SAASnW,GACzBA,EAAGsD,MAAM8S,aAAapW,EAAGsD,MAAM8S,YAAYpB,QAC/ChV,EAAGsD,MAAM8S,YAAcpW,EAAGqW,YAAYrW,EAAGoE,YAC3C,EACA3F,EAAK6X,oBAAsB,SAAStW,GAClC,IAAI2Q,EAAQ3Q,EAAGsD,MAAM8S,aAAepW,EAAGsD,MAAM8S,YAAY5B,OACrD7D,GAAO3Q,EAAGiI,aAAajI,EAAGoE,YAAauM,EAC7C,EACAlS,EAAK8X,oBAAsB,SAASvW,GAClC,IAAI2Q,EAAQ3Q,EAAGsD,MAAM8S,aAAepW,EAAGsD,MAAM8S,YAAY5B,OACzD,GAAI7D,EAAO,CACT,IAAI1Q,EAAOD,EAAGoE,YAAalE,EAAKyQ,EAChC,GAAInS,EAAWsQ,OAAO7O,EAAMC,GAAM,EAAG,CAAE,IAAIsW,EAAMtW,EAAIA,EAAKD,EAAMA,EAAOuW,CAAK,CAC5ExW,EAAGsD,MAAMmT,cAAgBzW,EAAGK,SAASJ,EAAMC,GAC3CF,EAAGS,aAAa,GAAIR,EAAMC,EAC5B,CACF,EACAzB,EAAKiY,oBAAsB,SAAS1W,GAClC,IAAI2Q,EAAQ3Q,EAAGsD,MAAM8S,aAAepW,EAAGsD,MAAM8S,YAAY5B,OACrD7D,IACF3Q,EAAGsD,MAAM8S,YAAYpB,QACrBhV,EAAGsD,MAAM8S,YAAcpW,EAAGqW,YAAYrW,EAAGoE,aACzCpE,EAAGqG,UAAUsK,GAEjB,EACAlS,EAAKkY,YAAc,SAAS3W,GACI,MAA1BA,EAAGsD,MAAMmT,eACXzW,EAAG+F,iBAAiB/F,EAAGsD,MAAMmT,cAAe,KAAM,QACtD,EAEAhY,EAAKmY,aAAe,SAAS5W,GAC3B,IAAIM,EAAMN,EAAG0O,aAAa,KAAM,SAChC1O,EAAGwP,SAAS,MAAOlP,EAAIgP,IAAMhP,EAAI8G,QAAU,EAAIpH,EAAGmP,gBAAgBI,aAAe,EACnF,EA8BA9Q,EAAKoY,UAAY,SAAS7W,GAAM0S,EAAY1S,GAAI,EAAO,EACvDvB,EAAKqY,kBAAoB,SAAS9W,GAAM0S,EAAY1S,GAAG,EAAQ,EAC/DvB,EAAKsY,aAAe,SAAS/W,GAC3B,IAAI2S,EAASF,EAAUzS,GACvB,GAAK2S,EAAL,CACA,IAAIlC,EAAMzQ,EAAG0Q,gBAAgBiC,EAAOpC,OAChCyG,EAAU,GACVC,GAAgB,EACpB,MAAOxG,EAAIG,WACToG,EAAQ5X,KAAK,CAAC0F,OAAQ2L,EAAIxQ,OAAQyE,KAAM+L,EAAIvQ,OACxCuQ,EAAIxQ,OAAOlB,MAAQ4T,EAAO1S,KAAKlB,MAAQ0R,EAAIxQ,OAAOjB,IAAM2T,EAAO1S,KAAKjB,IACtEiY,IAEJjX,EAAGkO,cAAc8I,EAASC,EATP,CAUrB,EAGA,IAAItL,EAASnN,EAAWmN,OACxBA,EAAOuL,WAAa,CAClB,WAAY,mBACZ,YAAa,aACb,eAAgB,aAChB,QAAS,YACT,YAAa,gBACb,aAAc,iBACd,cAAe,eACf,gBAAiB,iBACjB,QAAS,aACT,cAAe,uBACf,IAAO,qBACP,YAAa,kBACb,kBAAmB,mBACnB,QAAS,uBACT,kBAAmB,cACnB,cAAe,wBACf,QAAS,cACT,cAAe,aACf,gBAAiB,eACjB,QAAS,wBACT,QAAS,YACT,cAAe,gBACf,GAAM,YACN,WAAY,mBACZ,SAAU,uBACV,eAAgB,8BAChB,GAAM,eACN,WAAY,eACZ,SAAU,iBACV,eAAgB,iBAChB,SAAU,kBACV,UAAa,iBACb,cAAe,8BACf,cAAe,eACf,cAAe,iBACf,cAAe,mBACf,kBAAmB,iBACnB,cAAe,sBACf,cAAe,sBACf,cAAe,sBACf,cAAe,cACf,cAAe,eACf,cAAe,iBACf,sBAAuB,cACvB,cAAe,UACf,cAAe,YACf,cAAe,YACf,gBAAiB,sBACjB,kBAAmB,sBACnB,SAAU,YACV,eAAgB,oBAChB,SAAU,eACV,cAAe,OACf,cAAe,SACf,QAAS,kBACT,cAAe,yBACf,QAAS,UACT,GAAM,WACN,WAAY,WACZ,YAAe,cAEjB1Y,EAAWoN,gBAAgBD,EAAOuL,YAElCvL,EAAOwL,UAAY,CACjB,YAAa,aACb,eAAgB,aAChB,QAAS,YACT,SAAU,iBACV,WAAY,gBACZ,YAAa,iBACb,UAAW,eACX,YAAa,iBACb,SAAU,aACV,eAAgB,uBAChB,IAAO,qBACP,aAAc,kBACd,mBAAoB,mBACpB,SAAU,uBACV,mBAAoB,cACpB,eAAgB,wBAChB,SAAU,cACV,gBAAiB,aACjB,kBAAmB,eACnB,SAAU,wBACV,SAAU,YACV,eAAgB,gBAChB,GAAM,YACN,WAAY,mBACZ,UAAW,uBACX,gBAAiB,8BACjB,GAAM,eACN,WAAY,eACZ,UAAW,iBACX,gBAAiB,iBACjB,SAAU,kBACV,UAAa,iBACb,gBAAiB,8BACjB,gBAAiB,eACjB,gBAAiB,iBACjB,gBAAiB,mBACjB,oBAAqB,iBACrB,gBAAiB,sBACjB,gBAAiB,sBACjB,gBAAiB,sBACjB,gBAAiB,cACjB,gBAAiB,eACjB,gBAAiB,iBACjB,wBAAyB,cACzB,gBAAiB,UACjB,gBAAiB,YACjB,gBAAiB,YACjB,cAAe,sBACf,gBAAiB,sBACjB,UAAW,YACX,gBAAiB,oBACjB,SAAU,eACV,eAAgB,OAChB,eAAgB,SAChB,SAAU,kBACV,eAAgB,yBAChB,SAAU,UACV,GAAM,WACN,WAAY,WACZ,YAAe,aAEjB3Y,EAAWoN,gBAAgBD,EAAOwL,WAElC,IAAIC,EAAMzL,EAAO1N,SAAW0N,EAAO0L,WACnC1L,EAAO2L,QAAUF,EAAMzL,EAAOuL,WAAavL,EAAOwL,SACpD,E,kBC1sBA,SAAU5Y,GAENA,EAAI,EAAQ,OAKf,EAPD,CAOG,SAASC,GACV,aAEA,IAAI+Y,EAA4B,kBAC5BC,EAA4B,yBAsChC,SAASC,EAAWzX,EAAI0X,GAStB,GARAC,KAAK3X,GAAKA,EACV2X,KAAKD,QAAUA,EACfC,KAAKC,OAAS,KACdD,KAAKE,SAAW,EAChBF,KAAKG,KAAO,EACZH,KAAK7K,SAAW6K,KAAK3X,GAAGoE,UAAU,SAClCuT,KAAKI,SAAWJ,KAAK3X,GAAGuB,QAAQoW,KAAK7K,SAAS/N,MAAMM,OAASsY,KAAK3X,GAAG+H,eAAe1I,OAEhFsY,KAAKD,QAAQM,uBAAwB,CACvC,IAAIC,EAAON,KACX3X,EAAGiF,GAAG,iBAAkB0S,KAAKO,aAAe,WAAaD,EAAKE,gBAAkB,EAClF,CACF,CA/CA3Z,EAAW4Z,SAAW,SAASpY,EAAIqY,EAAUX,GAC3C,IAAKW,EAAU,OAAOrY,EAAGoY,SAASV,GAC9BA,GAAWA,EAAQY,QAAOD,EAASC,OAAQ,GAC/C,IAAIC,EAAU,CAACC,KAAMH,GACrB,GAAIX,EAAS,IAAK,IAAIe,KAAQf,EAASa,EAAQE,GAAQf,EAAQe,GAC/D,OAAOzY,EAAGoY,SAASG,EACrB,EAEA/Z,EAAWka,gBAAgB,WAAY,SAAShB,GAC9CA,EAAUiB,EAAahB,KAAMA,KAAKvT,UAAU,SAAUsT,GACtD,IAAIlT,EAAamT,KAAKlT,iBACtB,KAAID,EAAWnF,OAAS,GAAxB,CAIA,GAAIsY,KAAK/S,oBAAqB,CAC5B,IAAK8S,EAAQc,KAAKI,kBAAmB,OAErC,IAAK,IAAI7U,EAAI,EAAGA,EAAIS,EAAWnF,OAAQ0E,IACrC,GAAIS,EAAWT,GAAGW,KAAK3F,MAAQyF,EAAWT,GAAGe,OAAO/F,KAAM,MAC9D,CAEI4Y,KAAKrU,MAAMuV,kBAAkBlB,KAAKrU,MAAMuV,iBAAiBC,QAC7D,IAAIC,EAAapB,KAAKrU,MAAMuV,iBAAmB,IAAIpB,EAAWE,KAAMD,GAC/DqB,EAAWrB,QAAQc,OAExBha,EAAWwa,OAAOrB,KAAM,kBAAmBA,MAC3CoB,EAAWE,QAAO,GAhBe,CAiBnC,GAEAza,EAAWka,gBAAgB,YAAa,WAClCf,KAAKrU,MAAMuV,kBAAkBlB,KAAKrU,MAAMuV,iBAAiBC,OAC/D,GAiBA,IAAII,EAAwBC,OAAOD,uBAAyB,SAASE,GACnE,OAAOC,WAAWD,EAAI,IAAK,GAC7B,EACIE,EAAuBH,OAAOG,sBAAwBC,aAsF1D,SAASZ,EAAa3Y,EAAIM,EAAKoX,GAC7B,IAAI8B,EAASxZ,EAAG0X,QAAQ+B,YACpBC,EAAM,CAAC,EACX,IAAK,IAAIjB,KAAQkB,EAAgBD,EAAIjB,GAAQkB,EAAelB,GAC5D,GAAIe,EAAQ,IAAK,IAAIf,KAAQe,OACN7H,IAAjB6H,EAAOf,KAAqBiB,EAAIjB,GAAQe,EAAOf,IACrD,GAAIf,EAAS,IAAK,IAAIe,KAAQf,OACN/F,IAAlB+F,EAAQe,KAAqBiB,EAAIjB,GAAQf,EAAQe,IAEvD,OADIiB,EAAIlB,KAAKoB,UAASF,EAAIlB,KAAOkB,EAAIlB,KAAKoB,QAAQ5Z,EAAIM,IAC/CoZ,CACT,CAEA,SAASG,EAAQd,GACf,MAAyB,iBAAdA,EAA+BA,EAC9BA,EAAW3Y,IACzB,CAEA,SAAS0Z,EAAYf,EAAYgB,GAC/B,IAAIC,EAAU,CACZC,GAAI,WAAYF,EAAOG,WAAW,EAAG,EACrCC,KAAM,WAAYJ,EAAOG,UAAU,EAAG,EACtCE,OAAQ,WAAYL,EAAOG,UAA+B,EAApBH,EAAOM,YAAgB,EAAM,EACnEC,SAAU,WAAYP,EAAOG,UAAUH,EAAOM,WAAa,GAAG,EAAM,EACpEE,KAAM,WAAYR,EAAOS,SAAS,EAAG,EACrCC,IAAK,WAAYV,EAAOS,SAAST,EAAO1a,OAAS,EAAG,EACpDqb,MAAOX,EAAOY,KACdC,IAAKb,EAAOY,KACZE,IAAKd,EAAOjB,OAGV1B,EAAM,MAAM3V,KAAKqZ,UAAUC,UAE3B3D,IACF4C,EAAQ,UAAY,WAAYD,EAAOG,WAAW,EAAG,EACrDF,EAAQ,UAAY,WAAYD,EAAOG,UAAU,EAAG,GAGtD,IAAIc,EAASjC,EAAWrB,QAAQuD,WAC5BC,EAASF,EAAS,CAAC,EAAIhB,EAC3B,SAASmB,EAAWC,EAAKC,GACvB,IAAIC,EAEFA,EADgB,iBAAPD,EACD,SAASrb,GAAM,OAAOqb,EAAIrb,EAAI+Z,EAAS,EAExCC,EAAQzU,eAAe8V,GACtBrB,EAAQqB,GAERA,EACVH,EAAOE,GAAOE,CAChB,CACA,GAAIN,EACF,IAAK,IAAII,KAAOJ,EAAYA,EAAOzV,eAAe6V,IAChDD,EAAWC,EAAKJ,EAAOI,IAC3B,IAAIG,EAAQxC,EAAWrB,QAAQ8D,UAC/B,GAAID,EACF,IAAK,IAAIH,KAAOG,EAAWA,EAAMhW,eAAe6V,IAC9CD,EAAWC,EAAKG,EAAMH,IAC1B,OAAOF,CACT,CAEA,SAASO,EAAeC,EAAcC,GACpC,MAAOA,GAAMA,GAAMD,EAAc,CAC/B,GAAkC,OAA9BC,EAAGC,SAASpR,eAA0BmR,EAAGE,YAAcH,EAAc,OAAOC,EAChFA,EAAKA,EAAGE,UACV,CACF,CAEA,SAASC,EAAO/C,EAAYgD,GAC1BpE,KAAKxZ,GAAK,eAAiBuB,KAAKsc,MAAMtc,KAAKuc,OAAO,MAClDtE,KAAKoB,WAAaA,EAClBpB,KAAKoE,KAAOA,EACZpE,KAAKuE,QAAS,EACd,IAAItE,EAASD,KAAM3X,EAAK+Y,EAAW/Y,GAC/Bmc,EAAgBnc,EAAGoc,gBAAgBD,cACnCE,EAAeF,EAAcG,aAAeH,EAAcE,aAE1DE,EAAQ5E,KAAK4E,MAAQJ,EAAcvV,cAAc,MACrD2V,EAAM1V,aAAa,OAAQ,WAC3B0V,EAAM1V,aAAa,gBAAiB,QACpC0V,EAAMpe,GAAKwZ,KAAKxZ,GAChB,IAAIqe,EAAQzD,EAAW/Y,GAAG0X,QAAQ8E,MAClCD,EAAME,UAAY,oBAAsBD,EACxC7E,KAAK+E,aAAeX,EAAKW,cAAgB,EAGzC,IADA,IAAIC,EAAcZ,EAAKa,KACd7Y,EAAI,EAAGA,EAAI4Y,EAAYtd,SAAU0E,EAAG,CAC3C,IAAI8Y,EAAMN,EAAMvV,YAAYmV,EAAcvV,cAAc,OAAQ6J,EAAMkM,EAAY5Y,GAC9E0Y,EAAYlF,GAAsBxT,GAAK4T,KAAK+E,aAAe,GAAK,IAAMlF,GACrD,MAAjB/G,EAAIgM,YAAmBA,EAAYhM,EAAIgM,UAAY,IAAMA,GAC7DI,EAAIJ,UAAYA,EACZ1Y,GAAK4T,KAAK+E,cAAcG,EAAIhW,aAAa,gBAAiB,QAC9DgW,EAAI1e,GAAKwZ,KAAKxZ,GAAK,IAAM4F,EACzB8Y,EAAIhW,aAAa,OAAQ,UACrB4J,EAAIqM,OAAQrM,EAAIqM,OAAOD,EAAKd,EAAMtL,GACjCoM,EAAI7V,YAAYmV,EAAclV,eAAewJ,EAAIsM,aAAelD,EAAQpJ,KAC7EoM,EAAIG,OAASjZ,CACf,CAEA,IAAIkZ,EAAYlE,EAAWrB,QAAQuF,WAAad,EAAce,KAC1D5c,EAAMN,EAAG0O,aAAaqK,EAAWrB,QAAQyF,cAAgBpB,EAAK9b,KAAO,MACrE0O,EAAOrO,EAAIqO,KAAMW,EAAMhP,EAAI8G,OAAQgW,GAAQ,EAC3CC,EAAa,EAAGC,EAAY,EAChC,GAAIL,IAAcd,EAAce,KAAM,CAEpC,IAAIK,GAA0H,IAAlG,CAAC,WAAY,WAAY,SAAS9L,QAAQ4K,EAAamB,iBAAiBP,GAAWQ,UAC3GC,EAAeH,EAAwBN,EAAYA,EAAUS,aAC7DC,EAAuBD,EAAaE,wBACpCC,EAAe1B,EAAce,KAAKU,wBACtCP,EAAcM,EAAqBhP,KAAOkP,EAAalP,KAAO+O,EAAaI,WAC3ER,EAAaK,EAAqBrO,IAAMuO,EAAavO,IAAMoO,EAAaK,SAC1E,CACAxB,EAAMzV,MAAM6H,KAAQA,EAAO0O,EAAc,KACzCd,EAAMzV,MAAMwI,IAAOA,EAAMgO,EAAa,KAGtC,IAAIU,EAAO3B,EAAa4B,YAAcve,KAAKwe,IAAI/B,EAAce,KAAKiB,YAAahC,EAAciC,gBAAgBD,aACzGE,EAAOhC,EAAaiC,aAAe5e,KAAKwe,IAAI/B,EAAce,KAAKqB,aAAcpC,EAAciC,gBAAgBG,cAC/GtB,EAAUjW,YAAYuV,GACtBvc,EAAGoc,gBAAgBvV,aAAa,oBAAqB,QACrD7G,EAAGoc,gBAAgBvV,aAAa,YAAa8Q,KAAKxZ,IAClD6B,EAAGoc,gBAAgBvV,aAAa,wBAAyB8Q,KAAKxZ,GAAK,IAAMwZ,KAAK+E,cAE9E,IAII8B,EAJAC,EAAM1F,EAAWrB,QAAQgH,cAAgBnC,EAAMqB,wBAA0B,IAAIe,QAC7EC,IAAU7F,EAAWrB,QAAQmH,qBAAsBtC,EAAMuC,aAAevC,EAAMhN,aAAe,EAIjG8J,WAAW,WAAamF,EAAcxe,EAAGmP,eAAiB,GAE1D,IAAI4P,EAAWN,EAAIrX,OAASiX,EAC5B,GAAIU,EAAW,EAAG,CAChB,IAAIC,EAASP,EAAIrX,OAASqX,EAAInP,IAAK2P,EAAaR,EAAInP,KAAOhP,EAAI8G,OAAS9G,EAAIgP,KAAO,EAC/E+O,EAAOI,EAAInP,IAAM2P,GACfD,EAASC,IAAY1C,EAAMzV,MAAMkY,QAAUA,EAASC,GAAc,MACtE1C,EAAMzV,MAAMwI,KAAQA,EAAMhP,EAAIgP,IAAM0P,GAAU1B,EAAa,KAC3DF,GAAQ,GAERb,EAAMzV,MAAMkY,OAAUX,EAAOI,EAAInP,IAAM,EAAK,IAEhD,CACA,IAuBM4P,EAvBFC,EAAWV,EAAIW,MAAQpB,EAS3B,GARIY,IAASO,GAAYnf,EAAGqN,QAAQgS,gBAChCF,EAAW,IACTV,EAAIW,MAAQX,EAAI9P,KAAOqP,IACzBzB,EAAMzV,MAAMC,MAASiX,EAAO,EAAK,KACjCmB,GAAaV,EAAIW,MAAQX,EAAI9P,KAAQqP,GAEvCzB,EAAMzV,MAAM6H,MAAQA,EAAOjP,KAAKwe,IAAI5d,EAAIqO,KAAOwQ,EAAW9B,EAAY,IAAM,MAE1EuB,EAAS,IAAK,IAAIU,EAAO/C,EAAMgD,WAAYD,EAAMA,EAAOA,EAAKE,YAC/DF,EAAKxY,MAAM2Y,aAAezf,EAAGqN,QAAQgS,eAAiB,MAExDrf,EAAGwL,UAAUmM,KAAKhM,OAASmO,EAAYf,EAAY,CACjDmB,UAAW,SAASza,EAAGigB,GAAa9H,EAAO+H,aAAa/H,EAAO8E,aAAejd,EAAGigB,EAAY,EAC7FlF,SAAU,SAAS/a,GAAKmY,EAAO+H,aAAalgB,EAAI,EAChD4a,SAAU,WAAa,OAAOzC,EAAOgI,cAAgB,EACrDvgB,OAAQsd,EAAYtd,OACpByZ,MAAO,WAAaC,EAAWD,OAAS,EACxC6B,KAAM,WAAa/C,EAAO+C,MAAQ,EAClCoB,KAAMA,KAGJhD,EAAWrB,QAAQmI,kBAErB7f,EAAGiF,GAAG,OAAQ0S,KAAKmI,OAAS,WAAaZ,EAAgB7F,WAAW,WAAaN,EAAWD,OAAS,EAAG,IAAM,GAC9G9Y,EAAGiF,GAAG,QAAS0S,KAAKoI,QAAU,WAAaxG,aAAa2F,EAAgB,IAG1Elf,EAAGiF,GAAG,SAAU0S,KAAKqI,SAAW,WAC9B,IAAIC,EAAYjgB,EAAGmP,gBAAiBqK,EAASxZ,EAAGkgB,oBAAoBtC,wBAC/DY,IAAaA,EAAcxe,EAAGmP,iBACnC,IAAIgR,EAAS7Q,EAAMkP,EAAYlP,IAAM2Q,EAAU3Q,IAC3C8Q,EAAQD,GAAU9D,EAAagE,cAAgBlE,EAAciC,iBAAmBjC,EAAce,MAAMa,WAExG,GADKX,IAAOgD,GAAS7D,EAAMgC,cACvB6B,GAAS5G,EAAOlK,KAAO8Q,GAAS5G,EAAOpS,OAAQ,OAAO2R,EAAWD,QACrEyD,EAAMzV,MAAMwI,IAAM6Q,EAAS,KAC3B5D,EAAMzV,MAAM6H,KAAQA,EAAO6P,EAAY7P,KAAOsR,EAAUtR,KAAQ,IAClE,GAEAnQ,EAAWyG,GAAGsX,EAAO,WAAY,SAASxP,GACxC,IAAIuT,EAAI7E,EAAec,EAAOxP,EAAE4F,QAAU5F,EAAEwT,YACxCD,GAAiB,MAAZA,EAAEtD,SAAiBpF,EAAO+H,aAAaW,EAAEtD,QAASpF,EAAO+C,OACpE,GAEAnc,EAAWyG,GAAGsX,EAAO,QAAS,SAASxP,GACrC,IAAIuT,EAAI7E,EAAec,EAAOxP,EAAE4F,QAAU5F,EAAEwT,YACxCD,GAAiB,MAAZA,EAAEtD,SACTpF,EAAO+H,aAAaW,EAAEtD,QAClBjE,EAAWrB,QAAQ8I,uBAAuB5I,EAAO+C,OAEzD,GAEAnc,EAAWyG,GAAGsX,EAAO,YAAa,WAChClD,WAAW,WAAWrZ,EAAGygB,OAAQ,EAAG,GACtC,GAGA,IAAIC,EAAoB/I,KAAKgJ,uBAM7B,OAL+B,IAA3BD,EAAkBzgB,MAAuC,IAAzBygB,EAAkBxgB,IACpDyX,KAAKiJ,iBAGPpiB,EAAWwa,OAAO+C,EAAM,SAAUY,EAAYhF,KAAK+E,cAAeH,EAAMsE,WAAWlJ,KAAK+E,gBACjF,CACT,CA0EA,SAASoE,EAAkB9gB,EAAI+gB,GAC7B,IAAK/gB,EAAG4E,oBAAqB,OAAOmc,EAEpC,IADA,IAAIC,EAAS,GACJjd,EAAI,EAAGA,EAAIgd,EAAQ1hB,OAAQ0E,IAC9Bgd,EAAQhd,GAAG6U,mBAAmBoI,EAAO5hB,KAAK2hB,EAAQhd,IACxD,OAAOid,CACT,CAEA,SAASC,EAAWzI,EAAMxY,EAAI0X,EAASwJ,GACrC,GAAI1I,EAAKF,MACPE,EAAKxY,EAAIkhB,EAAUxJ,OACd,CACL,IAAIsJ,EAASxI,EAAKxY,EAAI0X,GAClBsJ,GAAUA,EAAOG,KAAMH,EAAOG,KAAKD,GAClCA,EAASF,EAChB,CACF,CAEA,SAASI,EAAiBphB,EAAIM,GAC5B,IAA0C+gB,EAAtCN,EAAU/gB,EAAGshB,WAAWhhB,EAAK,QACjC,GAAIygB,EAAQ1hB,OAAQ,CAClB,IAAIkiB,EAAW,SAASvhB,EAAIkhB,EAAUxJ,GACpC,IAAI8J,EAAMV,EAAkB9gB,EAAI+gB,GAChC,SAASU,EAAI1d,GACX,GAAIA,GAAKyd,EAAIniB,OAAQ,OAAO6hB,EAAS,MACrCD,EAAWO,EAAIzd,GAAI/D,EAAI0X,EAAS,SAASsJ,GACnCA,GAAUA,EAAOpE,KAAKvd,OAAS,EAAG6hB,EAASF,GAC1CS,EAAI1d,EAAI,EACf,EACF,CACA0d,EAAI,EACN,EAGA,OAFAF,EAASjJ,OAAQ,EACjBiJ,EAAS3I,mBAAoB,EACtB2I,CACT,CAAO,OAAIF,EAAQrhB,EAAG0hB,UAAU1hB,EAAGoE,YAAa,cACvC,SAASpE,GAAM,OAAOxB,EAAWga,KAAKmJ,SAAS3hB,EAAI,CAACqhB,MAAOA,GAAQ,EACjE7iB,EAAWga,KAAKoJ,QAClB,SAAS5hB,EAAI0X,GAAW,OAAOlZ,EAAWga,KAAKoJ,QAAQ5hB,EAAI0X,EAAS,EAEpE,WAAY,CAEvB,CApZAD,EAAWoK,UAAY,CACrB/I,MAAO,WACAnB,KAAKmK,WACVnK,KAAK3X,GAAGsD,MAAMuV,iBAAmB,KACjClB,KAAKG,KAAO,KACRH,KAAKD,QAAQM,wBACfL,KAAK3X,GAAGwF,IAAI,iBAAkBmS,KAAKO,cAGjCP,KAAKC,QAAUD,KAAKoE,MAAMvd,EAAWwa,OAAOrB,KAAKoE,KAAM,SACvDpE,KAAKC,QAAQD,KAAKC,OAAOkB,QAC7Bta,EAAWwa,OAAOrB,KAAK3X,GAAI,gBAAiB2X,KAAK3X,IACnD,EAEA8hB,OAAQ,WACN,OAAOnK,KAAK3X,GAAGsD,MAAMuV,kBAAoBlB,IAC3C,EAEAgD,KAAM,SAASoB,EAAMhY,GACnB,IAAIgV,EAAagD,EAAKa,KAAK7Y,GAAIkU,EAAON,KACtCA,KAAK3X,GAAG4N,UAAU,WACZmL,EAAWP,KACbO,EAAWP,KAAKP,EAAKjY,GAAI+b,EAAMhD,GAE/Bd,EAAKjY,GAAGS,aAAaoZ,EAAQd,GAAaA,EAAW9Y,MAAQ8b,EAAK9b,KAC7C8Y,EAAW7Y,IAAM6b,EAAK7b,GAAI,YACjD1B,EAAWwa,OAAO+C,EAAM,OAAQhD,GAChCd,EAAKjY,GAAGoT,gBACV,GACIuE,KAAKD,QAAQqK,aACfpK,KAAKmB,OAET,EAEAX,eAAgB,WACVR,KAAKE,WACPyB,EAAqB3B,KAAKE,UAC1BF,KAAKE,SAAW,GAGlB,IAAImK,EAAarK,KAAK7K,SACnB6K,KAAKoE,OACNiG,EAAarK,KAAKoE,KAAK9b,MAGzB,IAAIK,EAAMqX,KAAK3X,GAAGoE,YAAarF,EAAO4Y,KAAK3X,GAAGuB,QAAQjB,EAAIvB,MAC1D,GAAIuB,EAAIvB,MAAQ4Y,KAAK7K,SAAS/N,MAAQA,EAAKM,OAASiB,EAAItB,IAAM2Y,KAAKI,SAAWJ,KAAK7K,SAAS9N,IACxFsB,EAAItB,GAAKgjB,EAAWhjB,IAAM2Y,KAAK3X,GAAG4E,sBAChCtE,EAAItB,IAAM2Y,KAAKD,QAAQuK,gBAAgBxgB,KAAK1C,EAAKqD,OAAO9B,EAAItB,GAAK,IACrE2Y,KAAKmB,YACA,CACL,IAAIb,EAAON,KACXA,KAAKE,SAAWqB,EAAsB,WAAYjB,EAAKgB,QAAS,GAC5DtB,KAAKC,QAAQD,KAAKC,OAAOsK,SAC/B,CACF,EAEAjJ,OAAQ,SAAStW,GACf,GAAiB,MAAbgV,KAAKG,KAAT,CACA,IAAIG,EAAON,KAAMwK,IAAWxK,KAAKG,KACjCmJ,EAAWtJ,KAAKD,QAAQc,KAAMb,KAAK3X,GAAI2X,KAAKD,QAAS,SAASqE,GACxD9D,EAAKH,MAAQqK,GAAQlK,EAAKmK,aAAarG,EAAMpZ,EACnD,EAJuB,CAKzB,EAEAyf,aAAc,SAASrG,EAAMpZ,GACvBgV,KAAKoE,MAAMvd,EAAWwa,OAAOrB,KAAKoE,KAAM,UAE5C,IAAIG,EAAUvE,KAAKC,QAAUD,KAAKC,OAAOsE,QAAYvZ,GAASgV,KAAKD,QAAQ2K,eACvE1K,KAAKC,QAAQD,KAAKC,OAAOkB,QAE7BnB,KAAKoE,KAAOA,EAERA,GAAQA,EAAKa,KAAKvd,SAChB6c,GAA8B,GAApBH,EAAKa,KAAKvd,OACtBsY,KAAKgD,KAAKoB,EAAM,IAEhBpE,KAAKC,OAAS,IAAIkE,EAAOnE,KAAMoE,GAC/Bvd,EAAWwa,OAAO+C,EAAM,UAG9B,GAiNFD,EAAO+F,UAAY,CACjB/I,MAAO,WACL,GAAInB,KAAKoB,WAAWnB,QAAUD,KAA9B,CACAA,KAAKoB,WAAWnB,OAAS,KACrBD,KAAK4E,MAAMV,YAAYlE,KAAK4E,MAAMV,WAAWyG,YAAY3K,KAAK4E,OAClE5E,KAAKoB,WAAW/Y,GAAGiG,aAAa0R,KAAKhM,QACrC,IAAIhF,EAAQgR,KAAKoB,WAAW/Y,GAAGoc,gBAC/BzV,EAAM4b,gBAAgB,yBACtB5b,EAAM4b,gBAAgB,aAEtB,IAAIviB,EAAK2X,KAAKoB,WAAW/Y,GACrB2X,KAAKoB,WAAWrB,QAAQmI,iBAC1B7f,EAAGwF,IAAI,OAAQmS,KAAKmI,QACpB9f,EAAGwF,IAAI,QAASmS,KAAKoI,UAEvB/f,EAAGwF,IAAI,SAAUmS,KAAKqI,SAboB,CAc5C,EAEAkC,QAAS,WACPvK,KAAKoB,WAAW/Y,GAAGiG,aAAa0R,KAAKhM,QACrC,IAAIiM,EAASD,KACbA,KAAKhM,OAAS,CAAC+O,MAAO,WAAa9C,EAAOsE,QAAS,CAAM,GACzDvE,KAAKoB,WAAW/Y,GAAGwL,UAAUmM,KAAKhM,OACpC,EAEAgP,KAAM,WACJhD,KAAKoB,WAAW4B,KAAKhD,KAAKoE,KAAMpE,KAAK+E,aACvC,EAEAiD,aAAc,SAAS5b,EAAG2b,GAKxB,GAJI3b,GAAK4T,KAAKoE,KAAKa,KAAKvd,OACtB0E,EAAI2b,EAAY/H,KAAKoE,KAAKa,KAAKvd,OAAS,EAAI,EACrC0E,EAAI,IACXA,EAAI2b,EAAY,EAAK/H,KAAKoE,KAAKa,KAAKvd,OAAS,GAC3CsY,KAAK+E,cAAgB3Y,EAAzB,CACA,IAAIub,EAAO3H,KAAK4E,MAAMsE,WAAWlJ,KAAK+E,cAClC4C,IACFA,EAAK7C,UAAY6C,EAAK7C,UAAU+F,QAAQ,IAAMhL,EAA2B,IACzE8H,EAAKiD,gBAAgB,kBAEvBjD,EAAO3H,KAAK4E,MAAMsE,WAAWlJ,KAAK+E,aAAe3Y,GACjDub,EAAK7C,WAAa,IAAMjF,EACxB8H,EAAKzY,aAAa,gBAAiB,QACnC8Q,KAAKoB,WAAW/Y,GAAGoc,gBAAgBvV,aAAa,wBAAyByY,EAAKnhB,IAC9EwZ,KAAKiJ,iBACLpiB,EAAWwa,OAAOrB,KAAKoE,KAAM,SAAUpE,KAAKoE,KAAKa,KAAKjF,KAAK+E,cAAe4C,EAXxC,CAYpC,EAEAsB,eAAgB,WACd,IAAIF,EAAoB/I,KAAKgJ,uBACzB8B,EAAQ9K,KAAK4E,MAAMsE,WAAWH,EAAkBzgB,MAChDyiB,EAAQ/K,KAAK4E,MAAMsE,WAAWH,EAAkBxgB,IAChDyiB,EAAYhL,KAAK4E,MAAMgD,WACvBkD,EAAMnF,UAAY3F,KAAK4E,MAAMwB,UAC/BpG,KAAK4E,MAAMwB,UAAY0E,EAAMnF,UAAYqF,EAAUrF,UAC5CoF,EAAMpF,UAAYoF,EAAMnE,aAAe5G,KAAK4E,MAAMwB,UAAYpG,KAAK4E,MAAMhN,eAChFoI,KAAK4E,MAAMwB,UAAY2E,EAAMpF,UAAYoF,EAAMnE,aAAe5G,KAAK4E,MAAMhN,aAAeoT,EAAUrF,UACtG,EAEAsC,aAAc,WACZ,OAAOlgB,KAAKsc,MAAMrE,KAAK4E,MAAMhN,aAAeoI,KAAK4E,MAAMgD,WAAWhB,eAAiB,CACrF,EAEAoC,qBAAsB,WACpB,IAAIiC,EAASjL,KAAKoB,WAAWrB,QAAQmL,cAAgB,EACrD,MAAO,CACL5iB,KAAMP,KAAKwe,IAAI,EAAGvG,KAAK+E,aAAekG,GACtC1iB,GAAIR,KAAKC,IAAIgY,KAAKoE,KAAKa,KAAKvd,OAAS,EAAGsY,KAAK+E,aAAekG,GAEhE,GA+CFpkB,EAAWskB,eAAe,OAAQ,OAAQ,CACxClJ,QAASwH,IAGX5iB,EAAWskB,eAAe,OAAQ,WAAY,SAAS9iB,EAAI0X,GACzD,IACIqL,EADAtS,EAAMzQ,EAAGoE,YAAaxB,EAAQ5C,EAAG6C,WAAW4N,GACtCxQ,EAAOzB,EAAWG,IAAI8R,EAAI1R,KAAM6D,EAAMG,OAAQ7C,EAAKuQ,EACzD7N,EAAMG,MAAQ0N,EAAIzR,IAAM,KAAKyC,KAAKmB,EAAMK,OAAOb,OAAOqO,EAAIzR,GAAK4D,EAAMG,MAAQ,IAC/EggB,EAAOngB,EAAMK,OAAO+f,OAAO,EAAGvS,EAAIzR,GAAK4D,EAAMG,QAE7CggB,EAAO,GACP9iB,EAAOwQ,GAGT,IADA,IAAIE,EAAQ,GACH5M,EAAI,EAAGA,EAAI2T,EAAQ2J,MAAMhiB,OAAQ0E,IAAK,CAC7C,IAAIqK,EAAOsJ,EAAQ2J,MAAMtd,GACrBqK,EAAK1M,MAAM,EAAGqhB,EAAK1jB,SAAW0jB,GAChCpS,EAAMvR,KAAKgP,EACf,CAEA,GAAIuC,EAAMtR,OAAQ,MAAO,CAACud,KAAMjM,EAAO1Q,KAAMA,EAAMC,GAAIA,EACzD,GAEA1B,EAAWE,SAASukB,aAAezkB,EAAW4Z,SAE9C,IAAIuB,EAAiB,CACnBnB,KAAMha,EAAWga,KAAK0K,KACtBb,gBAAgB,EAChBlF,eAAe,EACf8E,gBAAiB,mBACjBF,aAAa,EACblC,gBAAgB,EAChB7H,wBAAwB,EACxBwI,uBAAuB,EACvBvD,UAAW,KACXhC,WAAY,KACZO,UAAW,KACXqD,qBAAqB,EACrBH,eAAe,GAGjBlgB,EAAW2kB,aAAa,cAAe,KACzC,E,sYCvgBA,SAAU5kB,GAENA,EAAI,EAAQ,OAKf,EAPD,CAOG,SAASC,GACV,aAEA,IAAI4kB,EAAO,SAAUC,EAAQ,IAE7B7kB,EAAWskB,eAAe,OAAQ,UAAW,SAAStJ,EAAQ9B,GAC5D,IAAItJ,EAAOsJ,GAAWA,EAAQtJ,MAAQgV,EAClChW,EAAQsK,GAAWA,EAAQtK,OAASiW,EACpC5S,EAAM+I,EAAOpV,YAAakf,EAAU9J,EAAOjY,QAAQkP,EAAI1R,MACvDiE,EAAMyN,EAAIzR,GAAI+D,EAAQC,EAC1B,MAAOD,GAASqL,EAAK3M,KAAK6hB,EAAQlhB,OAAOW,EAAQ,MAAOA,EAKxD,IAJA,IAAIwgB,EAAUxgB,GAASC,GAAOsgB,EAAQ5hB,MAAMqB,EAAOC,GAE/C4Z,EAAOlF,GAAWA,EAAQkF,MAAQ,GAAI4G,EAAO,CAAC,EAC9CC,EAAK,IAAIjT,OAAOpC,EAAKsV,OAAQ,KACxB9iB,GAAO,EAAGA,GAAO,EAAGA,GAAO,EAElC,IADA,IAAI7B,EAAO0R,EAAI1R,KAAM4kB,EAAUjkB,KAAKC,IAAID,KAAKwe,IAAInf,EAAO6B,EAAMwM,EAAOoM,EAAO5X,aAAc4X,EAAO1X,YAAclB,EACxG7B,GAAQ4kB,EAAS5kB,GAAQ6B,EAAK,CACnC,IAAiCgjB,EAA7BxjB,EAAOoZ,EAAOjY,QAAQxC,GAC1B,MAAO6kB,EAAIH,EAAG3P,KAAK1T,GACbrB,GAAQ0R,EAAI1R,MAAQ6kB,EAAE,KAAOL,GAC3BA,GAA2C,GAAhCK,EAAE,GAAGC,YAAYN,EAAS,IAAaO,OAAOjC,UAAUtc,eAAewe,KAAKP,EAAMI,EAAE,MACnGJ,EAAKI,EAAE,KAAM,EACbhH,EAAKxd,KAAKwkB,EAAE,IAGlB,CAEF,MAAO,CAAChH,KAAMA,EAAM3c,KAAMzB,EAAWG,IAAI8R,EAAI1R,KAAMgE,GAAQ7C,GAAI1B,EAAWG,IAAI8R,EAAI1R,KAAMiE,GAC1F,EACF,E,mBCrCA,SAAUzE,GAENA,EAAI,EAAQ,OAKf,EAPD,CAOG,SAASC,GACZ,aAEAA,EAAWwlB,WAAW,aAAc,SAASC,EAAQC,GACnD,IA8CIrX,EAAM9O,EA9CN0X,EAAawO,EAAOxO,WACpB0O,EAAkBD,EAAaC,gBAC/BC,EAAaF,EAAaG,OAC1BC,EAAWJ,EAAaK,MAAQH,EAChCI,GAAyC,IAA5BN,EAAaM,WAC1BC,EAAOP,EAAaQ,WACpBC,EAAST,EAAaU,gBAAkB,mBAIxCC,EAAW,WACb,SAASC,EAAGjY,GAAO,MAAO,CAACA,KAAMA,EAAM/F,MAAO,UAAW,CACzD,IAAIie,EAAID,EAAG,aAAcE,EAAIF,EAAG,aAAcG,EAAIH,EAAG,aAAcI,EAAIJ,EAAG,aACtEK,EAAWL,EAAG,YAAaM,EAAO,CAACvY,KAAM,OAAQ/F,MAAO,QAE5D,MAAO,CACL,GAAMge,EAAG,MAAO,MAASC,EAAG,KAAQA,EAAG,KAAQC,EAAG,GAAMA,EAAG,IAAOA,EAAG,QAAWA,EAChF,OAAUE,EAAG,MAASA,EAAG,SAAYA,EAAG,IAAOJ,EAAG,OAAQ,OAAUG,EAAG,KAAQA,EAAG,MAASA,EAC3F,SAAYH,EAAG,YAAa,IAAOA,EAAG,OAAQ,MAASA,EAAG,OAAQ,IAAOA,EAAG,OAC5E,SAAYA,EAAG,YAAa,MAASA,EAAG,SACxC,IAAOA,EAAG,OAAQ,OAAUA,EAAG,UAAW,KAAQA,EAAG,QAAS,QAAWA,EAAG,WAC5E,GAAMK,EAAU,OAAUA,EAAU,WAAcA,EAClD,KAAQC,EAAM,MAASA,EAAM,KAAQA,EAAM,UAAaA,EAAM,IAAOA,EAAM,SAAYA,EACvF,KAAQN,EAAG,QAAS,MAASA,EAAG,SAAU,MAASA,EAAG,QACtD,MAASG,EAAG,OAAUH,EAAG,UAAW,OAAUA,EAAG,UAAW,QAAWG,EACvE,MAASA,EAEb,CAjBe,GAmBXI,EAAiB,oBACjBC,EAAkB,wFAEtB,SAASC,EAAWC,GAClB,IAAqBrjB,EAAjBsjB,GAAU,EAAaC,GAAQ,EACnC,MAAiC,OAAzBvjB,EAAOqjB,EAAOrjB,QAAiB,CACrC,IAAKsjB,EAAS,CACZ,GAAY,KAARtjB,IAAgBujB,EAAO,OACf,KAARvjB,EAAaujB,GAAQ,EAChBA,GAAiB,KAARvjB,IAAaujB,GAAQ,EACzC,CACAD,GAAWA,GAAmB,MAARtjB,CACxB,CACF,CAKA,SAASwjB,EAAIC,EAAI9e,EAAO+e,GAEtB,OADAhZ,EAAO+Y,EAAI7nB,EAAU8nB,EACd/e,CACT,CACA,SAASgf,EAAUN,EAAQliB,GACzB,IAAItE,EAAKwmB,EAAOrjB,OAChB,GAAU,KAANnD,GAAmB,KAANA,EAEf,OADAsE,EAAMyiB,SAAWC,EAAYhnB,GACtBsE,EAAMyiB,SAASP,EAAQliB,GACzB,GAAU,KAANtE,GAAawmB,EAAO/iB,MAAM,kCACnC,OAAOkjB,EAAI,SAAU,UAChB,GAAU,KAAN3mB,GAAawmB,EAAO/iB,MAAM,MACnC,OAAOkjB,EAAI,SAAU,QAChB,GAAI,qBAAqBlkB,KAAKzC,GACnC,OAAO2mB,EAAI3mB,GACN,GAAU,KAANA,GAAawmB,EAAOS,IAAI,KACjC,OAAON,EAAI,KAAM,YACZ,GAAU,KAAN3mB,GAAawmB,EAAO/iB,MAAM,yCACnC,OAAOkjB,EAAI,SAAU,UAChB,GAAI,KAAKlkB,KAAKzC,GAEnB,OADAwmB,EAAO/iB,MAAM,oDACNkjB,EAAI,SAAU,UAChB,GAAU,KAAN3mB,EACT,OAAIwmB,EAAOS,IAAI,MACb3iB,EAAMyiB,SAAWG,EACVA,EAAaV,EAAQliB,IACnBkiB,EAAOS,IAAI,MACpBT,EAAOW,YACAR,EAAI,UAAW,YACbS,GAAkBZ,EAAQliB,EAAO,IAC1CiiB,EAAWC,GACXA,EAAO/iB,MAAM,qCACNkjB,EAAI,SAAU,cAErBH,EAAOS,IAAI,KACJN,EAAI,WAAY,WAAYH,EAAOjR,YAEvC,GAAU,KAANvV,EAET,OADAsE,EAAMyiB,SAAWM,EACVA,EAAWb,EAAQliB,GACrB,GAAU,KAANtE,GAA8B,KAAjBwmB,EAAOc,OAE7B,OADAd,EAAOW,YACAR,EAAI,OAAQ,QACd,GAAU,KAAN3mB,GAAawmB,EAAOe,SAAS5B,GACtC,OAAOgB,EAAI,WAAY,YAClB,GAAU,KAAN3mB,GAAawmB,EAAO/iB,MAAM,QACnB,KAANzD,GAAawmB,EAAO/iB,MAAM,QAAU,KAAKhB,KAAK+jB,EAAOviB,OAAOvB,MAAM,EAAG8jB,EAAOziB,QAEtF,OADAyiB,EAAOW,YACAR,EAAI,UAAW,WACjB,GAAIN,EAAe5jB,KAAKzC,GAS7B,MARU,KAANA,GAAcsE,EAAMkjB,SAAiC,KAAtBljB,EAAMkjB,QAAQ3Z,OAC3C2Y,EAAOS,IAAI,KACH,KAANjnB,GAAmB,KAANA,GAAWwmB,EAAOS,IAAI,KAC9B,cAAcxkB,KAAKzC,KAC5BwmB,EAAOS,IAAIjnB,GACD,KAANA,GAAWwmB,EAAOS,IAAIjnB,KAGpB,KAANA,GAAawmB,EAAOS,IAAI,KAAaN,EAAI,KACtCA,EAAI,WAAY,WAAYH,EAAOjR,WACrC,GAAIoQ,EAAOljB,KAAKzC,GAAK,CAC1BwmB,EAAOe,SAAS5B,GAChB,IAAIvW,EAAOoX,EAAOjR,UAClB,GAAsB,KAAlBjR,EAAMmjB,SAAiB,CACzB,GAAI5B,EAAS6B,qBAAqBtY,GAAO,CACvC,IAAI0W,EAAKD,EAASzW,GAClB,OAAOuX,EAAIb,EAAGjY,KAAMiY,EAAGhe,MAAOsH,EAChC,CACA,GAAY,SAARA,GAAmBoX,EAAO/iB,MAAM,4CAA4C,GAC9E,OAAOkjB,EAAI,QAAS,UAAWvX,EACnC,CACA,OAAOuX,EAAI,WAAY,WAAYvX,EACrC,CACF,CAEA,SAAS4X,EAAYW,GACnB,OAAO,SAASnB,EAAQliB,GACtB,IAAqBnB,EAAjBsjB,GAAU,EACd,GAAIrB,GAA+B,KAAjBoB,EAAOc,QAAiBd,EAAO/iB,MAAM6iB,GAErD,OADAhiB,EAAMyiB,SAAWD,EACVH,EAAI,iBAAkB,QAE/B,MAAiC,OAAzBxjB,EAAOqjB,EAAOrjB,QAAiB,CACrC,GAAIA,GAAQwkB,IAAUlB,EAAS,MAC/BA,GAAWA,GAAmB,MAARtjB,CACxB,CAEA,OADKsjB,IAASniB,EAAMyiB,SAAWD,GACxBH,EAAI,SAAU,SACvB,CACF,CAEA,SAASO,EAAaV,EAAQliB,GAC5B,IAAsBtE,EAAlB4nB,GAAW,EACf,MAAO5nB,EAAKwmB,EAAOrjB,OAAQ,CACzB,GAAU,KAANnD,GAAa4nB,EAAU,CACzBtjB,EAAMyiB,SAAWD,EACjB,KACF,CACAc,EAAkB,KAAN5nB,CACd,CACA,OAAO2mB,EAAI,UAAW,UACxB,CAEA,SAASU,EAAWb,EAAQliB,GAC1B,IAAqBnB,EAAjBsjB,GAAU,EACd,MAAiC,OAAzBtjB,EAAOqjB,EAAOrjB,QAAiB,CACrC,IAAKsjB,IAAoB,KAARtjB,GAAuB,KAARA,GAAeqjB,EAAOS,IAAI,MAAO,CAC/D3iB,EAAMyiB,SAAWD,EACjB,KACF,CACAL,GAAWA,GAAmB,MAARtjB,CACxB,CACA,OAAOwjB,EAAI,QAAS,WAAYH,EAAOjR,UACzC,CAEA,IAAIsS,EAAW,SAQf,SAASC,EAAatB,EAAQliB,GACxBA,EAAMyjB,aAAYzjB,EAAMyjB,WAAa,MACzC,IAAIC,EAAQxB,EAAOviB,OAAOwO,QAAQ,KAAM+T,EAAOziB,OAC/C,KAAIikB,EAAQ,GAAZ,CAEA,GAAIvC,EAAM,CACR,IAAIb,EAAI,6CAA6C9P,KAAK0R,EAAOviB,OAAOvB,MAAM8jB,EAAOziB,MAAOikB,IACxFpD,IAAGoD,EAAQpD,EAAEqD,MACnB,CAGA,IADA,IAAIC,EAAQ,EAAGC,GAAe,EACrB7mB,EAAM0mB,EAAQ,EAAG1mB,GAAO,IAAKA,EAAK,CACzC,IAAItB,EAAKwmB,EAAOviB,OAAOb,OAAO9B,GAC1B8mB,EAAUP,EAASpV,QAAQzS,GAC/B,GAAIooB,GAAW,GAAKA,EAAU,EAAG,CAC/B,IAAKF,EAAO,GAAI5mB,EAAK,KAAO,CAC5B,GAAe,KAAT4mB,EAAY,CAAY,KAANloB,IAAWmoB,GAAe,GAAM,KAAO,CACjE,MAAO,GAAIC,GAAW,GAAKA,EAAU,IACjCF,OACG,GAAIvC,EAAOljB,KAAKzC,GACrBmoB,GAAe,OACV,GAAI,UAAU1lB,KAAKzC,GACxB,QAAUsB,EAAK,CACb,GAAW,GAAPA,EAAU,OACd,IAAI6B,EAAOqjB,EAAOviB,OAAOb,OAAO9B,EAAM,GACtC,GAAI6B,GAAQnD,GAAuC,MAAjCwmB,EAAOviB,OAAOb,OAAO9B,EAAM,GAAY,CAAEA,IAAO,KAAM,CAC1E,MACK,GAAI6mB,IAAiBD,EAAO,GAC/B5mB,EACF,KACF,CACF,CACI6mB,IAAiBD,IAAO5jB,EAAMyjB,WAAazmB,EA7B1B,CA8BvB,CAIA,IAAI+mB,EAAc,CAAC,MAAQ,EAAM,QAAU,EAAM,UAAY,EAAM,QAAU,EAC1D,QAAU,EAAM,MAAQ,EAAM,QAAU,EAAM,kBAAkB,GAEnF,SAASC,EAAUC,EAAU5R,EAAQ9I,EAAM2a,EAAOxU,EAAM9D,GACtDyI,KAAK4P,SAAWA,EAChB5P,KAAKhC,OAASA,EACdgC,KAAK9K,KAAOA,EACZ8K,KAAK3E,KAAOA,EACZ2E,KAAKzI,KAAOA,EACC,MAATsY,IAAe7P,KAAK6P,MAAQA,EAClC,CAEA,SAASC,EAAQnkB,EAAOokB,GACtB,IAAKlD,EAAY,OAAO,EACxB,IAAK,IAAImD,EAAIrkB,EAAMskB,UAAWD,EAAGA,EAAIA,EAAExlB,KACrC,GAAIwlB,EAAEE,MAAQH,EAAS,OAAO,EAChC,IAAK,IAAII,EAAKxkB,EAAMykB,QAASD,EAAIA,EAAKA,EAAG9U,KACvC,IAAS2U,EAAIG,EAAGE,KAAML,EAAGA,EAAIA,EAAExlB,KAC7B,GAAIwlB,EAAEE,MAAQH,EAAS,OAAO,CAEpC,CAEA,SAASO,EAAQ3kB,EAAOwD,EAAO+F,EAAM9O,EAASynB,GAC5C,IAAI0C,EAAK5kB,EAAM4kB,GAGfJ,EAAGxkB,MAAQA,EAAOwkB,EAAGtC,OAASA,EAAQsC,EAAGK,OAAS,KAAML,EAAGI,GAAKA,EAAIJ,EAAGhhB,MAAQA,EAE1ExD,EAAMkjB,QAAQjhB,eAAe,WAChCjC,EAAMkjB,QAAQgB,OAAQ,GAExB,MAAM,EAAM,CACV,IAAIY,EAAaF,EAAG7oB,OAAS6oB,EAAGroB,MAAQykB,EAAW+D,EAAaC,EAChE,GAAIF,EAAWvb,EAAM9O,GAAU,CAC7B,MAAMmqB,EAAG7oB,QAAU6oB,EAAGA,EAAG7oB,OAAS,GAAGkpB,IACnCL,EAAGroB,KAAHqoB,GACF,OAAIJ,EAAGK,OAAeL,EAAGK,OACb,YAARtb,GAAsB4a,EAAQnkB,EAAOvF,GAAiB,aACnD+I,CACT,CACF,CACF,CAIA,IAAIghB,EAAK,CAACxkB,MAAO,KAAMqS,OAAQ,KAAMwS,OAAQ,KAAMD,GAAI,MACvD,SAASM,IACP,IAAK,IAAIzkB,EAAI0kB,UAAUppB,OAAS,EAAG0E,GAAK,EAAGA,IAAK+jB,EAAGI,GAAG9oB,KAAKqpB,UAAU1kB,GACvE,CACA,SAAS8hB,IAEP,OADA2C,EAAKE,MAAM,KAAMD,YACV,CACT,CACA,SAASE,EAAOd,EAAMjL,GACpB,IAAK,IAAI+K,EAAI/K,EAAM+K,EAAGA,EAAIA,EAAExlB,KAAM,GAAIwlB,EAAEE,MAAQA,EAAM,OAAO,EAC7D,OAAO,CACT,CACA,SAASe,EAASlB,GAChB,IAAIpkB,EAAQwkB,EAAGxkB,MAEf,GADAwkB,EAAGK,OAAS,MACP3D,EAAL,CACA,GAAIlhB,EAAMykB,QACR,GAA0B,OAAtBzkB,EAAMkjB,QAAQtX,MAAiB5L,EAAMykB,SAAWzkB,EAAMykB,QAAQc,MAAO,CAEvE,IAAIC,EAAaC,EAAkBrB,EAASpkB,EAAMykB,SAClD,GAAkB,MAAde,EAEF,YADAxlB,EAAMykB,QAAUe,EAGpB,MAAO,IAAKH,EAAOjB,EAASpkB,EAAMskB,WAEhC,YADAtkB,EAAMskB,UAAY,IAAIoB,EAAItB,EAASpkB,EAAMskB,YAKzC1D,EAAa+E,aAAeN,EAAOjB,EAASpkB,EAAM2lB,cACpD3lB,EAAM2lB,WAAa,IAAID,EAAItB,EAASpkB,EAAM2lB,YAhB3B,CAiBnB,CACA,SAASF,EAAkBrB,EAASK,GAClC,GAAKA,EAEE,IAAIA,EAAQc,MAAO,CACxB,IAAIK,EAAQH,EAAkBrB,EAASK,EAAQ/U,MAC/C,OAAKkW,EACDA,GAASnB,EAAQ/U,KAAa+U,EAC3B,IAAIoB,EAAQD,EAAOnB,EAAQC,MAAM,GAFrB,IAGrB,CAAO,OAAIW,EAAOjB,EAASK,EAAQC,MAC1BD,EAEA,IAAIoB,EAAQpB,EAAQ/U,KAAM,IAAIgW,EAAItB,EAASK,EAAQC,OAAO,EACnE,CAVE,OAAO,IAWX,CAEA,SAASoB,EAAWvB,GAClB,MAAe,UAARA,GAA4B,WAARA,GAA6B,aAARA,GAA+B,YAARA,GAA8B,YAARA,CAC/F,CAIA,SAASsB,EAAQnW,EAAMgV,EAAMa,GAASlR,KAAK3E,KAAOA,EAAM2E,KAAKqQ,KAAOA,EAAMrQ,KAAKkR,MAAQA,CAAM,CAC7F,SAASG,EAAInB,EAAM1lB,GAAQwV,KAAKkQ,KAAOA,EAAMlQ,KAAKxV,KAAOA,CAAK,CAE9D,IAAIknB,EAAc,IAAIL,EAAI,OAAQ,IAAIA,EAAI,YAAa,OACvD,SAASM,IACPxB,EAAGxkB,MAAMykB,QAAU,IAAIoB,EAAQrB,EAAGxkB,MAAMykB,QAASD,EAAGxkB,MAAMskB,WAAW,GACrEE,EAAGxkB,MAAMskB,UAAYyB,CACvB,CACA,SAASE,IACPzB,EAAGxkB,MAAMykB,QAAU,IAAIoB,EAAQrB,EAAGxkB,MAAMykB,QAASD,EAAGxkB,MAAMskB,WAAW,GACrEE,EAAGxkB,MAAMskB,UAAY,IACvB,CAEA,SAAS4B,IACP1B,EAAGxkB,MAAMskB,UAAYE,EAAGxkB,MAAMykB,QAAQC,KACtCF,EAAGxkB,MAAMykB,QAAUD,EAAGxkB,MAAMykB,QAAQ/U,IACtC,CAEA,SAASyW,EAAQ5c,EAAMqC,GACrB,IAAI8R,EAAS,WACX,IAAI1d,EAAQwkB,EAAGxkB,MAAOkQ,EAASlQ,EAAMikB,SACrC,GAA0B,QAAtBjkB,EAAMkjB,QAAQ3Z,KAAgB2G,EAASlQ,EAAMkjB,QAAQe,cACpD,IAAK,IAAImC,EAAQpmB,EAAMkjB,QAASkD,GAAuB,KAAdA,EAAM7c,MAAe6c,EAAMlC,MAAOkC,EAAQA,EAAM1W,KAC5FQ,EAASkW,EAAMnC,SACjBjkB,EAAMkjB,QAAU,IAAIc,EAAU9T,EAAQsU,EAAGtC,OAAO7P,SAAU9I,EAAM,KAAMvJ,EAAMkjB,QAAStX,EACvF,EAEA,OADA8R,EAAOuH,KAAM,EACNvH,CACT,CACA,SAAS2I,IACP,IAAIrmB,EAAQwkB,EAAGxkB,MACXA,EAAMkjB,QAAQxT,OACU,KAAtB1P,EAAMkjB,QAAQ3Z,OAChBvJ,EAAMikB,SAAWjkB,EAAMkjB,QAAQe,UACjCjkB,EAAMkjB,QAAUljB,EAAMkjB,QAAQxT,KAElC,CAGA,SAAS4W,EAAOC,GACd,SAASC,EAAIjd,GACX,OAAIA,GAAQgd,EAAehE,IACR,KAAVgE,GAAyB,KAARhd,GAAuB,KAARA,GAAuB,KAARA,EAAoB2b,IAChE3C,EAAKiE,EACnB,CACA,OAAOA,CACT,CAEA,SAASxB,EAAUzb,EAAMkd,GACvB,MAAY,OAARld,EAAsBgZ,EAAK4D,EAAQ,SAAUM,GAAQC,GAAQJ,EAAO,KAAMD,GAClE,aAAR9c,EAA4BgZ,EAAK4D,EAAQ,QAASQ,EAAW3B,EAAWqB,GAChE,aAAR9c,EAA4BgZ,EAAK4D,EAAQ,QAASnB,EAAWqB,GACrD,aAAR9c,EAA4Bib,EAAGtC,OAAO/iB,MAAM,SAAS,GAASojB,IAASA,EAAK4D,EAAQ,QAASS,EAAiBN,EAAO,KAAMD,GACnH,YAAR9c,EAA2BgZ,EAAK+D,EAAO,MAC/B,KAAR/c,EAAoBgZ,EAAK4D,EAAQ,KAAMF,EAAkBV,GAAOc,EAAQH,GAChE,KAAR3c,EAAoBgZ,IACZ,MAARhZ,GAC2B,QAAzBib,EAAGxkB,MAAMkjB,QAAQtX,MAAkB4Y,EAAGxkB,MAAM4kB,GAAGJ,EAAGxkB,MAAM4kB,GAAG7oB,OAAS,IAAMsqB,GAC5E7B,EAAGxkB,MAAM4kB,GAAGroB,KAAZioB,GACKjC,EAAK4D,EAAQ,QAASQ,EAAW3B,EAAWqB,EAAQQ,KAEjD,YAARtd,EAA2BgZ,EAAKuE,IACxB,OAARvd,EAAsBgZ,EAAK4D,EAAQ,QAASF,EAAkBc,GAAS/B,EAAWkB,EAAYG,GACtF,SAAR9c,GAAoB4X,GAAiB,aAATsF,GAC9BjC,EAAGK,OAAS,UACLtC,EAAK4D,EAAQ,OAAgB,SAAR5c,EAAkBA,EAAOkd,GAAQtN,GAAWkN,IAE9D,YAAR9c,EACE4X,GAAiB,WAATsF,GACVjC,EAAGK,OAAS,UACLtC,EAAKyC,IACH7D,IAAkB,UAATsF,GAA8B,QAATA,GAA4B,QAATA,IAAoBjC,EAAGtC,OAAO/iB,MAAM,UAAU,IACxGqlB,EAAGK,OAAS,UACC,QAAT4B,EAAwBlE,EAAKyE,IACf,QAATP,EAAwBlE,EAAK0E,GAAUX,EAAO,YAAaY,GAAUZ,EAAO,MACzE/D,EAAK4D,EAAQ,QAASgB,GAASb,EAAO,KAAMH,EAAQ,KAAMZ,GAAOc,EAAQA,IAC5ElF,GAAiB,aAATsF,GACjBjC,EAAGK,OAAS,UACLtC,EAAK4D,EAAQ,QAASpB,EAAYC,EAAWqB,IAC3ClF,GAAiB,YAATsF,GACjBjC,EAAGK,OAAS,UACLtC,EAAKyC,IAELzC,EAAK4D,EAAQ,QAASiB,IAGrB,UAAR7d,EAAyBgZ,EAAK4D,EAAQ,QAASQ,EAAWL,EAAO,KAAMH,EAAQ,IAAK,UAAWF,EACjEV,GAAOc,EAAQA,EAAQH,GAC7C,QAAR3c,EAAuBgZ,EAAKwC,EAAYuB,EAAO,MACvC,WAAR/c,EAA0BgZ,EAAK+D,EAAO,MAC9B,SAAR/c,EAAwBgZ,EAAK4D,EAAQ,QAASH,EAAaqB,EAAmBrC,EAAWqB,EAAQH,GACzF,UAAR3c,EAAyBgZ,EAAK4D,EAAQ,QAASmB,GAAajB,GACpD,UAAR9c,EAAyBgZ,EAAK4D,EAAQ,QAASoB,GAAalB,GACpD,SAAR9c,EAAwBgZ,EAAKyC,GACpB,KAATyB,EAAqBlE,EAAKwC,EAAYC,GACnCE,EAAKiB,EAAQ,QAASpB,EAAYuB,EAAO,KAAMD,EACxD,CACA,SAASgB,EAAkB9d,GACzB,GAAY,KAARA,EAAa,OAAOgZ,EAAKiF,GAAQlB,EAAO,KAC9C,CACA,SAASvB,EAAWxb,EAAMkd,GACxB,OAAOgB,EAAgBle,EAAMkd,GAAO,EACtC,CACA,SAASiB,EAAkBne,EAAMkd,GAC/B,OAAOgB,EAAgBle,EAAMkd,GAAO,EACtC,CACA,SAASE,EAAUpd,GACjB,MAAY,KAARA,EAAoB2b,IACjB3C,EAAK4D,EAAQ,KAAMS,EAAiBN,EAAO,KAAMD,EAC1D,CACA,SAASoB,EAAgBle,EAAMkd,EAAOkB,GACpC,GAAInD,EAAGxkB,MAAMyjB,YAAce,EAAGtC,OAAOziB,MAAO,CAC1C,IAAIma,EAAO+N,EAAUC,GAAmBC,GACxC,GAAY,KAARte,EAAa,OAAOgZ,EAAKyD,EAAaG,EAAQ,KAAM2B,GAASN,GAAQ,KAAMnB,EAAQC,EAAO,MAAO1M,EAAMsM,GACtG,GAAY,YAAR3c,EAAoB,OAAO2b,EAAKc,EAAamB,GAASb,EAAO,MAAO1M,EAAMsM,EACrF,CAEA,IAAI6B,EAAUJ,EAAUK,EAAuBC,EAC/C,OAAIlE,EAAY9hB,eAAesH,GAAcgZ,EAAKwF,GACtC,YAARxe,EAA2BgZ,EAAKuE,GAAaiB,GACrC,SAARxe,GAAoB4X,GAAiB,aAATsF,GAAyBjC,EAAGK,OAAS,UAAkBtC,EAAK4D,EAAQ,QAAS+B,GAAiB7B,IAClH,aAAR9c,GAA+B,SAARA,EAAwBgZ,EAAKoF,EAAUD,EAAoB3C,GAC1E,KAARxb,EAAoBgZ,EAAK4D,EAAQ,KAAMS,EAAiBN,EAAO,KAAMD,EAAQ0B,GACrE,YAARxe,GAA8B,UAARA,EAAyBgZ,EAAKoF,EAAUD,EAAoB3C,GAC1E,KAARxb,EAAoBgZ,EAAK4D,EAAQ,KAAMgC,GAAc9B,EAAQ0B,GACrD,KAARxe,EAAoB6e,GAAaC,GAAS,IAAK,KAAMN,GAC7C,SAARxe,EAAwB2b,EAAKoD,EAAOP,GAC5B,OAARxe,EAAsBgZ,EAAKgG,GAAYZ,IACpCpF,GACT,CACA,SAASqE,EAAgBrd,GACvB,OAAIA,EAAKpK,MAAM,cAAsB+lB,IAC9BA,EAAKH,EACd,CAEA,SAASkD,EAAmB1e,EAAMkd,GAChC,MAAY,KAARld,EAAoBgZ,EAAKqE,GACtBoB,EAAqBze,EAAMkd,GAAO,EAC3C,CACA,SAASuB,EAAqBze,EAAMkd,EAAOkB,GACzC,IAAIa,EAAgB,GAAXb,EAAmBM,EAAqBD,EAC7CS,EAAkB,GAAXd,EAAmB5C,EAAa2C,EAC3C,MAAY,MAARne,EAAqBgZ,EAAKyD,EAAa2B,EAAUC,GAAmBC,GAAW3B,GACvE,YAAR3c,EACE,UAAUpL,KAAKsoB,IAAUtF,GAAiB,KAATsF,EAAqBlE,EAAKiG,GAC3DrH,GAAiB,KAATsF,GAAgBjC,EAAGtC,OAAO/iB,MAAM,4BAA4B,GAC/DojB,EAAK4D,EAAQ,KAAM2B,GAASZ,GAAU,KAAMb,EAAQmC,GAChD,KAAT/B,EAAqBlE,EAAKwC,EAAYuB,EAAO,KAAMmC,GAChDlG,EAAKkG,GAEF,SAARlf,EAA0B2b,EAAKoD,EAAOE,GAC9B,KAARjf,EACQ,KAARA,EAAoB6e,GAAaV,EAAmB,IAAK,OAAQc,GACzD,KAARjf,EAAoBgZ,EAAKmG,GAAUF,GAC3B,KAARjf,EAAoBgZ,EAAK4D,EAAQ,KAAMS,EAAiBN,EAAO,KAAMD,EAAQmC,GAC7ErH,GAAiB,MAATsF,GAAiBjC,EAAGK,OAAS,UAAkBtC,EAAK2E,GAAUsB,IAC9D,UAARjf,GACFib,EAAGxkB,MAAMmjB,SAAWqB,EAAGK,OAAS,WAChCL,EAAGtC,OAAOyG,OAAOnE,EAAGtC,OAAOllB,IAAMwnB,EAAGtC,OAAOziB,MAAQ,GAC5C8iB,EAAKkG,SAHd,OALA,CAUF,CACA,SAASH,EAAM/e,EAAMkd,GACnB,MAAY,SAARld,EAAwB2b,IACS,MAAjCuB,EAAMroB,MAAMqoB,EAAM1qB,OAAS,GAAmBwmB,EAAK+F,GAChD/F,EAAKqE,EAAiBgC,EAC/B,CACA,SAASA,EAAcrf,GACrB,GAAY,KAARA,EAGF,OAFAib,EAAGK,OAAS,WACZL,EAAGxkB,MAAMyiB,SAAWM,EACbR,EAAK+F,EAEhB,CACA,SAAST,GAAUte,GAEjB,OADAia,EAAagB,EAAGtC,OAAQsC,EAAGxkB,OACpBklB,EAAa,KAAR3b,EAAcyb,EAAYD,EACxC,CACA,SAAS6C,GAAiBre,GAExB,OADAia,EAAagB,EAAGtC,OAAQsC,EAAGxkB,OACpBklB,EAAa,KAAR3b,EAAcyb,EAAY0C,EACxC,CACA,SAASa,GAAYZ,GACnB,OAAO,SAASpe,GACd,MAAY,KAARA,EAAoBgZ,EAAKoF,EAAUkB,GAAgBxZ,IACtC,YAAR9F,GAAsB4X,EAAaoB,EAAKuG,GAAenB,EAAUK,EAAuBC,GACrF/C,EAAKyC,EAAUD,EAAoB3C,EACjD,CACF,CACA,SAAS1V,GAAO0Z,EAAGtC,GACjB,GAAa,UAATA,EAA4C,OAAvBjC,EAAGK,OAAS,UAAkBtC,EAAK0F,EAC9D,CACA,SAASY,GAAcE,EAAGtC,GACxB,GAAa,UAATA,EAA4C,OAAvBjC,EAAGK,OAAS,UAAkBtC,EAAKyF,EAC9D,CACA,SAASZ,GAAW7d,GAClB,MAAY,KAARA,EAAoBgZ,EAAK8D,EAAQrB,GAC9BE,EAAK+C,EAAoB3B,EAAO,KAAMD,EAC/C,CACA,SAASqC,GAASnf,GAChB,GAAY,YAARA,EAA6C,OAAxBib,EAAGK,OAAS,WAAmBtC,GAC1D,CACA,SAAS8F,GAAQ9e,EAAMkd,GACrB,MAAY,SAARld,GACFib,EAAGK,OAAS,WACLtC,EAAK8F,KACK,YAAR9e,GAAkC,WAAZib,EAAGhhB,OAClCghB,EAAGK,OAAS,WACC,OAAT4B,GAA2B,OAATA,EAAuBlE,EAAKyG,KAE9C7H,GAAQqD,EAAGxkB,MAAMyjB,YAAce,EAAGtC,OAAOziB,QAAU6gB,EAAIkE,EAAGtC,OAAO/iB,MAAM,YAAY,MACrFqlB,EAAGxkB,MAAMyjB,WAAae,EAAGtC,OAAOllB,IAAMsjB,EAAE,GAAGvkB,QACtCwmB,EAAK0G,MACK,UAAR1f,GAA4B,UAARA,GAC7Bib,EAAGK,OAAS/D,EAAa,WAAc0D,EAAGhhB,MAAQ,YAC3C+e,EAAK0G,KACK,kBAAR1f,EACFgZ,EAAK0G,IACH9H,GAAQ2E,EAAWW,IAC5BjC,EAAGK,OAAS,UACLtC,EAAK8F,KACK,KAAR9e,EACFgZ,EAAKwC,EAAYmE,GAAW5C,EAAO,KAAM2C,IAC/B,UAAR1f,EACFgZ,EAAKmF,EAAmBuB,IACb,KAATxC,GACTjC,EAAGK,OAAS,UACLtC,EAAK8F,KACK,KAAR9e,EACF2b,EAAK+D,SADP,EAnBL,IAAI3I,CAsBR,CACA,SAAS0I,GAAazf,GACpB,MAAY,YAARA,EAA2B2b,EAAK+D,KACpCzE,EAAGK,OAAS,WACLtC,EAAKuE,IACd,CACA,SAASmC,GAAU1f,GACjB,MAAY,KAARA,EAAoBgZ,EAAKmF,GACjB,KAARne,EAAoB2b,EAAK4B,SAA7B,CACF,CACA,SAASgB,GAASqB,EAAMzpB,EAAK0pB,GAC3B,SAASC,EAAQ9f,EAAMkd,GACrB,GAAI2C,EAAMA,EAAIjb,QAAQ5E,IAAS,EAAY,KAARA,EAAa,CAC9C,IAAI0b,EAAMT,EAAGxkB,MAAMkjB,QAEnB,MADgB,QAAZ+B,EAAIrZ,OAAgBqZ,EAAIjoB,KAAOioB,EAAIjoB,KAAO,GAAK,GAC5CulB,EAAK,SAAShZ,EAAMkd,GACzB,OAAIld,GAAQ7J,GAAO+mB,GAAS/mB,EAAYwlB,IACjCA,EAAKiE,EACd,EAAGE,EACL,CACA,OAAI9f,GAAQ7J,GAAO+mB,GAAS/mB,EAAY6iB,IACpC6G,GAAOA,EAAIjb,QAAQ,MAAQ,EAAU+W,EAAKiE,GACvC5G,EAAK+D,EAAO5mB,GACrB,CACA,OAAO,SAAS6J,EAAMkd,GACpB,OAAIld,GAAQ7J,GAAO+mB,GAAS/mB,EAAY6iB,IACjC2C,EAAKiE,EAAME,EACpB,CACF,CACA,SAASjB,GAAae,EAAMzpB,EAAKkM,GAC/B,IAAK,IAAInL,EAAI,EAAGA,EAAI0kB,UAAUppB,OAAQ0E,IACpC+jB,EAAGI,GAAG9oB,KAAKqpB,UAAU1kB,IACvB,OAAO8hB,EAAK4D,EAAQzmB,EAAKkM,GAAOkc,GAASqB,EAAMzpB,GAAM2mB,EACvD,CACA,SAASd,GAAMhc,GACb,MAAY,KAARA,EAAoBgZ,IACjB2C,EAAKF,EAAWO,GACzB,CACA,SAAS2D,GAAU3f,EAAMkd,GACvB,GAAItF,EAAM,CACR,GAAY,KAAR5X,EAAa,OAAOgZ,EAAK2E,IAC7B,GAAa,KAATT,EAAc,OAAOlE,EAAK2G,GAChC,CACF,CACA,SAASI,GAAc/f,EAAMkd,GAC3B,GAAItF,IAAiB,KAAR5X,GAAwB,MAATkd,GAAgB,OAAOlE,EAAK2E,GAC1D,CACA,SAASqC,GAAahgB,GACpB,GAAI4X,GAAgB,KAAR5X,EACV,OAAIib,EAAGtC,OAAO/iB,MAAM,kBAAkB,GAAeojB,EAAKwC,EAAYyE,GAAMtC,IAChE3E,EAAK2E,GAErB,CACA,SAASsC,GAAKT,EAAGtC,GACf,GAAa,MAATA,EAEF,OADAjC,EAAGK,OAAS,UACLtC,GAEX,CACA,SAAS2E,GAAS3d,EAAMkd,GACtB,MAAa,SAATA,GAA6B,UAATA,GAA8B,SAATA,GAA6B,YAATA,GAC/DjC,EAAGK,OAAS,UACLtC,EAAc,UAATkE,EAAoBiB,EAAoBR,KAE1C,YAAR3d,GAA+B,QAATkd,GACxBjC,EAAGK,OAAS,OACLtC,EAAKkH,KAED,KAAThD,GAAyB,KAATA,EAAqBlE,EAAK2E,IAClC,UAAR3d,GAA4B,UAARA,GAA4B,QAARA,EAAuBgZ,EAAKkH,IAC5D,KAARlgB,EAAoBgZ,EAAK4D,EAAQ,KAAM2B,GAASZ,GAAU,IAAK,KAAMb,EAAQoD,IACrE,KAARlgB,EAAoBgZ,EAAK4D,EAAQ,KAAMuD,GAAWrD,EAAQoD,IAClD,KAARlgB,EAAoBgZ,EAAKuF,GAAS6B,GAAS,KAAMC,GAAiBH,IAC1D,KAARlgB,EAAoBgZ,EAAKuF,GAASZ,GAAU,KAAMA,IAC1C,SAAR3d,EAA0B2b,EAAK2E,GAAWJ,SAA9C,CACF,CACA,SAASG,GAAgBrgB,GACvB,GAAY,MAARA,EAAc,OAAOgZ,EAAK2E,GAChC,CACA,SAASwC,GAAUngB,GACjB,OAAIA,EAAKpK,MAAM,YAAoBojB,IACvB,KAARhZ,GAAuB,KAARA,EAAoBgZ,EAAKmH,IACrCxE,EAAK4E,GAAUJ,GACxB,CACA,SAASI,GAASvgB,EAAMkd,GACtB,MAAY,YAARld,GAAkC,WAAZib,EAAGhhB,OAC3BghB,EAAGK,OAAS,WACLtC,EAAKuH,KACM,KAATrD,GAAwB,UAARld,GAA4B,UAARA,EACtCgZ,EAAKuH,IACK,KAARvgB,EACFgZ,EAAK2E,IACK,KAAR3d,EACFgZ,EAAK+D,EAAO,YAAagD,GAAehD,EAAO,KAAMwD,IAC3C,KAARvgB,EACF2b,EAAK6E,GAAcD,IAChBvgB,EAAKpK,MAAM,mBAAhB,EACEojB,GAEX,CACA,SAASsH,GAAUtgB,EAAMkd,GACvB,MAAY,SAARld,EAAwB2b,IACS,MAAjCuB,EAAMroB,MAAMqoB,EAAM1qB,OAAS,GAAmBwmB,EAAKsH,IAChDtH,EAAK2E,GAAU8C,GACxB,CACA,SAASA,GAAkBzgB,GACzB,GAAY,KAARA,EAGF,OAFAib,EAAGK,OAAS,WACZL,EAAGxkB,MAAMyiB,SAAWM,EACbR,EAAKsH,GAEhB,CACA,SAASF,GAAQpgB,EAAMkd,GACrB,MAAY,YAARld,GAAsBib,EAAGtC,OAAO/iB,MAAM,YAAY,IAAmB,KAATsnB,EAAqBlE,EAAKoH,IAC9E,KAARpgB,EAAoBgZ,EAAK2E,IACjB,UAAR3d,EAAyBgZ,EAAKoH,IAC3BzE,EAAKgC,GACd,CACA,SAASuC,GAAUlgB,EAAMkd,GACvB,MAAa,KAATA,EAAqBlE,EAAK4D,EAAQ,KAAM2B,GAASZ,GAAU,KAAMb,EAAQoD,IAChE,KAAThD,GAAwB,KAARld,GAAwB,KAATkd,EAAqBlE,EAAK2E,IACjD,KAAR3d,EAAoBgZ,EAAK2E,GAAUZ,EAAO,KAAMmD,IACvC,WAAThD,GAA+B,cAATA,GAAyBjC,EAAGK,OAAS,UAAkBtC,EAAK2E,KACzE,KAATT,EAAqBlE,EAAK2E,GAAUZ,EAAO,KAAMY,SAArD,CACF,CACA,SAAS4B,GAAcC,EAAGtC,GACxB,GAAa,KAATA,EAAc,OAAOlE,EAAK4D,EAAQ,KAAM2B,GAASZ,GAAU,KAAMb,EAAQoD,GAC/E,CACA,SAASQ,KACP,OAAO/E,EAAKgC,GAAUgD,GACxB,CACA,SAASA,GAAiBnB,EAAGtC,GAC3B,GAAa,KAATA,EAAc,OAAOlE,EAAK2E,GAChC,CACA,SAASR,GAAOqC,EAAGtC,GACjB,MAAa,QAATA,GAAkBjC,EAAGK,OAAS,UAAkBtC,EAAKyE,KAClD9B,EAAKiC,GAAS+B,GAAWiB,GAAaC,GAC/C,CACA,SAASjD,GAAQ5d,EAAMkd,GACrB,OAAItF,GAAQ2E,EAAWW,IAAUjC,EAAGK,OAAS,UAAkBtC,EAAK4E,KACxD,YAAR5d,GAAsB+b,EAASmB,GAAelE,KACtC,UAARhZ,EAAyBgZ,EAAK4E,IACtB,KAAR5d,EAAoB6e,GAAaiC,GAAY,KACrC,KAAR9gB,EAAoB6e,GAAakC,GAAa,UAAlD,CACF,CACA,SAASA,GAAY/gB,EAAMkd,GACzB,MAAY,YAARld,GAAuBib,EAAGtC,OAAO/iB,MAAM,SAAS,IAIxC,YAARoK,IAAoBib,EAAGK,OAAS,YACxB,UAARtb,EAAyBgZ,EAAK4E,IACtB,KAAR5d,EAAoB2b,IACZ,KAAR3b,EAAoBgZ,EAAKwC,EAAYuB,EAAO,KAAMA,EAAO,KAAMgE,IAC5D/H,EAAK+D,EAAO,KAAMa,GAASgD,MAPhC7E,EAASmB,GACFlE,EAAK4H,IAOhB,CACA,SAASE,KACP,OAAOnF,EAAKiC,GAASgD,GACvB,CACA,SAASA,GAAYI,EAAO9D,GAC1B,GAAa,KAATA,EAAc,OAAOlE,EAAKmF,EAChC,CACA,SAAS0C,GAAW7gB,GAClB,GAAY,KAARA,EAAa,OAAOgZ,EAAKmE,GAC/B,CACA,SAASG,GAAUtd,EAAMkd,GACvB,GAAY,aAARld,GAAgC,QAATkd,EAAiB,OAAOlE,EAAK4D,EAAQ,OAAQ,QAASnB,EAAWqB,EAC9F,CACA,SAASU,GAAQxd,EAAMkd,GACrB,MAAa,SAATA,EAAyBlE,EAAKwE,IACtB,KAARxd,EAAoBgZ,EAAK4D,EAAQ,KAAMqE,GAAUnE,QAArD,CACF,CACA,SAASmE,GAASjhB,GAChB,MAAY,OAARA,EAAsBgZ,EAAKmE,GAAQ+D,IAC3B,YAARlhB,EAA2BgZ,EAAKkI,IAC7BvF,EAAKuF,GACd,CACA,SAASA,GAASlhB,EAAMkd,GACtB,MAAY,KAARld,EAAoBgZ,IACZ,KAARhZ,EAAoBgZ,EAAKkI,IAChB,MAAThE,GAA0B,MAATA,GAAiBjC,EAAGK,OAAS,UAAkBtC,EAAKwC,EAAY0F,KAC9EvF,EAAKH,EAAY0F,GAC1B,CACA,SAAS3D,GAAYvd,EAAMkd,GACzB,MAAa,KAATA,GAAejC,EAAGK,OAAS,UAAkBtC,EAAKuE,KAC1C,YAARvd,GAAqB+b,EAASmB,GAAelE,EAAKuE,KAC1C,KAARvd,EAAoBgZ,EAAKyD,EAAaG,EAAQ,KAAM2B,GAASN,GAAQ,KAAMnB,EAAQkD,GAAcvE,EAAWkB,GAC5G/E,GAAiB,KAATsF,EAAqBlE,EAAK4D,EAAQ,KAAM2B,GAASmC,GAAW,KAAM5D,EAAQS,SAAtF,CACF,CACA,SAASiD,GAAaxgB,EAAMkd,GAC1B,MAAa,KAATA,GAAejC,EAAGK,OAAS,UAAkBtC,EAAKwH,KAC1C,YAARxgB,GAAqB+b,EAASmB,GAAelE,EAAKwH,KAC1C,KAARxgB,EAAoBgZ,EAAKyD,EAAaG,EAAQ,KAAM2B,GAASN,GAAQ,KAAMnB,EAAQkD,GAAcrD,GACjG/E,GAAiB,KAATsF,EAAqBlE,EAAK4D,EAAQ,KAAM2B,GAASmC,GAAW,KAAM5D,EAAQ0D,SAAtF,CACF,CACA,SAAS9C,GAAS1d,EAAMkd,GACtB,MAAY,WAARld,GAA6B,YAARA,GACvBib,EAAGK,OAAS,OACLtC,EAAK0E,KACM,KAATR,EACFlE,EAAK4D,EAAQ,KAAM2B,GAASmC,GAAW,KAAM5D,QAD/C,CAGT,CACA,SAASmB,GAAOje,EAAMkd,GAEpB,MADa,KAATA,GAAclE,EAAKwC,EAAYyC,IACvB,UAARje,EAAyBgZ,EAAKiF,IAC9BrG,GAAQ2E,EAAWW,IAAUjC,EAAGK,OAAS,UAAkBtC,EAAKiF,KAChErG,GAAgB,QAAR5X,EAAuBgZ,EAAK2G,GAAWiB,IAC5CjF,EAAKiC,GAAS+B,GAAWiB,GAClC,CACA,SAASjC,GAAgB3e,EAAMkd,GAE7B,MAAY,YAARld,EAA2B4P,GAAU5P,EAAMkd,GACxCiE,GAAenhB,EAAMkd,EAC9B,CACA,SAAStN,GAAU5P,EAAMkd,GACvB,GAAY,YAARld,EAAsC,OAAjB+b,EAASmB,GAAelE,EAAKmI,GACxD,CACA,SAASA,GAAenhB,EAAMkd,GAC5B,MAAa,KAATA,EAAqBlE,EAAK4D,EAAQ,KAAM2B,GAASmC,GAAW,KAAM5D,EAAQqE,IACjE,WAATjE,GAA+B,cAATA,GAA0BtF,GAAgB,KAAR5X,GAC7C,cAATkd,IAAuBjC,EAAGK,OAAS,WAChCtC,EAAKpB,EAAO+F,GAAWnC,EAAY2F,KAEhC,KAARnhB,EAAoBgZ,EAAK4D,EAAQ,KAAMwE,GAAWtE,QAAtD,CACF,CACA,SAASsE,GAAUphB,EAAMkd,GACvB,MAAY,SAARld,GACS,YAARA,IACU,UAATkd,GAA8B,OAATA,GAA2B,OAATA,GAAmBtF,GAAQ2E,EAAWW,KAC9EjC,EAAGtC,OAAO/iB,MAAM,0BAA0B,IAC7CqlB,EAAGK,OAAS,UACLtC,EAAKoI,KAEF,YAARphB,GAAkC,WAAZib,EAAGhhB,OAC3BghB,EAAGK,OAAS,WACLtC,EAAKqI,GAAYD,KAEd,UAARphB,GAA4B,UAARA,EAAyBgZ,EAAKqI,GAAYD,IACtD,KAARphB,EACKgZ,EAAKwC,EAAYmE,GAAW5C,EAAO,KAAMsE,GAAYD,IACjD,KAATlE,GACFjC,EAAGK,OAAS,UACLtC,EAAKoI,KAEVxJ,GAAgB,KAAR5X,EAAoB2b,EAAK6E,GAAcY,IACvC,KAARphB,GAAuB,KAARA,EAAoBgZ,EAAKoI,IAChC,KAARphB,EAAoBgZ,IACX,KAATkE,EAAqBlE,EAAKwC,EAAY4F,SAA1C,CACF,CACA,SAASC,GAAWrhB,EAAMkd,GACxB,GAAa,KAATA,EAAc,OAAOlE,EAAKqI,IAC9B,GAAa,KAATnE,EAAc,OAAOlE,EAAKqI,IAC9B,GAAY,KAARrhB,EAAa,OAAOgZ,EAAK2E,GAAUiD,IACvC,GAAa,KAAT1D,EAAc,OAAOlE,EAAKmF,GAC9B,IAAIjD,EAAUD,EAAGxkB,MAAMkjB,QAAQxT,KAAMmb,EAAcpG,GAA2B,aAAhBA,EAAQ7Y,KACtE,OAAOsZ,EAAK2F,EAAcd,GAAejD,GAC3C,CACA,SAASQ,GAAY/d,EAAMkd,GACzB,MAAa,KAATA,GAAgBjC,EAAGK,OAAS,UAAkBtC,EAAKuI,GAAWxE,EAAO,OAC5D,WAATG,GAAsBjC,EAAGK,OAAS,UAAkBtC,EAAKwC,EAAYuB,EAAO,OACpE,KAAR/c,EAAoBgZ,EAAKuF,GAASiD,GAAa,KAAMD,GAAWxE,EAAO,MACpEpB,EAAKF,EACd,CACA,SAAS+F,GAAYxhB,EAAMkd,GACzB,MAAa,MAATA,GAAiBjC,EAAGK,OAAS,UAAkBtC,EAAK+D,EAAO,cACnD,YAAR/c,EAA2B2b,EAAKwC,EAAmBqD,SAAvD,CACF,CACA,SAASxD,GAAYhe,GACnB,MAAY,UAARA,EAAyBgZ,IACjB,KAARhZ,EAAoB2b,EAAKH,GACjB,KAARxb,EAAoB2b,EAAK+C,GACtB/C,EAAK8F,GAAYC,GAAkBH,GAC5C,CACA,SAASE,GAAWzhB,EAAMkd,GACxB,MAAY,KAARld,EAAoB6e,GAAa4C,GAAY,MACrC,YAARzhB,GAAoB+b,EAASmB,GACpB,KAATA,IAAcjC,EAAGK,OAAS,WACvBtC,EAAK2I,IACd,CACA,SAASD,GAAiB1hB,GACxB,GAAY,KAARA,EAAa,OAAOgZ,EAAKyI,GAAYC,GAC3C,CACA,SAASC,GAAQX,EAAO9D,GACtB,GAAa,MAATA,EAAwC,OAAvBjC,EAAGK,OAAS,UAAkBtC,EAAKyI,GAC1D,CACA,SAASF,GAAUP,EAAO9D,GACxB,GAAa,QAATA,EAA0C,OAAvBjC,EAAGK,OAAS,UAAkBtC,EAAKwC,EAC5D,CACA,SAASoD,GAAa5e,GACpB,MAAY,KAARA,EAAoBgZ,IACjB2C,EAAK4C,GAASJ,EAAmB,KAC1C,CACA,SAASV,KACP,OAAO9B,EAAKiB,EAAQ,QAASgB,GAASb,EAAO,KAAMH,EAAQ,KAAM2B,GAASqD,GAAY,KAAM9E,EAAQA,EACtG,CACA,SAAS8E,KACP,OAAOjG,EAAKiC,GAASgD,GACvB,CAEA,SAASiB,GAAqBprB,EAAOqrB,GACnC,MAAyB,YAAlBrrB,EAAMmjB,UAA4C,KAAlBnjB,EAAMmjB,UAC3CpB,EAAe5jB,KAAKktB,EAAUvsB,OAAO,KACrC,OAAOX,KAAKktB,EAAUvsB,OAAO,GACjC,CAEA,SAASgkB,GAAkBZ,EAAQliB,EAAO2oB,GACxC,OAAO3oB,EAAMyiB,UAAYD,GACvB,iFAAiFrkB,KAAK6B,EAAMmjB,WACzE,SAAlBnjB,EAAMmjB,UAAuB,SAAShlB,KAAK+jB,EAAOviB,OAAOvB,MAAM,EAAG8jB,EAAOllB,KAAO2rB,GAAU,IAC/F,CAIA,OArhBA3C,EAAYf,IAAMgB,EAAiBhB,KAAM,EAKzCiB,EAAWjB,KAAM,EAoBjBoB,EAAOpB,KAAM,EA4fN,CACLqG,WAAY,SAASC,GACnB,IAAIvrB,EAAQ,CACVyiB,SAAUD,EACVW,SAAU,MACVyB,GAAI,GACJ1B,QAAS,IAAIc,GAAWuH,GAAc,GAAKpZ,EAAY,EAAG,SAAS,GACnEmS,UAAW1D,EAAa0D,UACxBG,QAAS7D,EAAa0D,WAAa,IAAIuB,EAAQ,KAAM,MAAM,GAC3D5B,SAAUsH,GAAc,GAI1B,OAFI3K,EAAa+E,YAAgD,iBAA3B/E,EAAa+E,aACjD3lB,EAAM2lB,WAAa/E,EAAa+E,YAC3B3lB,CACT,EAEAV,MAAO,SAAS4iB,EAAQliB,GAOtB,GANIkiB,EAAOsJ,QACJxrB,EAAMkjB,QAAQjhB,eAAe,WAChCjC,EAAMkjB,QAAQgB,OAAQ,GACxBlkB,EAAMikB,SAAW/B,EAAOuJ,cACxBjI,EAAatB,EAAQliB,IAEnBA,EAAMyiB,UAAYG,GAAgBV,EAAOwJ,WAAY,OAAO,KAChE,IAAIloB,EAAQxD,EAAMyiB,SAASP,EAAQliB,GACnC,MAAY,WAARuJ,EAA0B/F,GAC9BxD,EAAMmjB,SAAmB,YAAR5Z,GAAkC,MAAX9O,GAA8B,MAAXA,EAA8B8O,EAAX,SACvEob,EAAQ3kB,EAAOwD,EAAO+F,EAAM9O,EAASynB,GAC9C,EAEAhS,OAAQ,SAASlQ,EAAOqrB,GACtB,GAAIrrB,EAAMyiB,UAAYG,GAAgB5iB,EAAMyiB,UAAYM,EAAY,OAAO7nB,EAAWmP,KACtF,GAAIrK,EAAMyiB,UAAYD,EAAW,OAAO,EACxC,IAA2ExW,EAAvE2f,EAAYN,GAAaA,EAAUvsB,OAAO,GAAIokB,EAAUljB,EAAMkjB,QAElE,IAAK,aAAa/kB,KAAKktB,GAAY,IAAK,IAAI5qB,EAAIT,EAAM4kB,GAAG7oB,OAAS,EAAG0E,GAAK,IAAKA,EAAG,CAChF,IAAImrB,EAAI5rB,EAAM4kB,GAAGnkB,GACjB,GAAImrB,GAAKvF,EAAQnD,EAAUA,EAAQxT,UAC9B,GAAIkc,GAAK/E,IAAa+E,GAAK1F,EAAY,KAC9C,CACA,OAAwB,QAAhBhD,EAAQ3Z,MAAkC,QAAhB2Z,EAAQ3Z,QACrB,KAAboiB,IAAsB3f,EAAMhM,EAAM4kB,GAAG5kB,EAAM4kB,GAAG7oB,OAAS,MACjCiQ,GAAOic,GAAsBjc,GAAOgc,KACpC,mBAAmB7pB,KAAKktB,IACpDnI,EAAUA,EAAQxT,KAChBmR,GAAmC,KAAhBqC,EAAQ3Z,MAAoC,QAArB2Z,EAAQxT,KAAKnG,OACzD2Z,EAAUA,EAAQxT,MACpB,IAAInG,EAAO2Z,EAAQ3Z,KAAM2E,EAAUyd,GAAapiB,EAEhD,MAAY,UAARA,EAAyB2Z,EAAQe,UAA8B,YAAlBjkB,EAAMmjB,UAA4C,KAAlBnjB,EAAMmjB,SAAkBD,EAAQtX,KAAK7P,OAAS,EAAI,GAClH,QAARwN,GAA+B,KAAboiB,EAAyBzI,EAAQe,SAC3C,QAAR1a,EAAuB2Z,EAAQe,SAAW9R,EAClC,QAAR5I,EACA2Z,EAAQe,UAAYmH,GAAqBprB,EAAOqrB,GAAaxK,GAAmB1O,EAAa,GAC7E,UAAhB+Q,EAAQtX,MAAqBsC,GAA8C,GAAnC0S,EAAaiL,mBAErD3I,EAAQgB,MAAchB,EAAQ7Q,QAAUnE,EAAU,EAAI,GACnDgV,EAAQe,UAAY/V,EAAU,EAAIiE,GAFrC+Q,EAAQe,UAAY,sBAAsB9lB,KAAKktB,GAAalZ,EAAa,EAAIA,EAGxF,EAEA2Z,cAAe,oCACfC,kBAAmB/K,EAAW,KAAO,KACrCgL,gBAAiBhL,EAAW,KAAO,KACnCiL,qBAAsBjL,EAAW,KAAO,MACxCkL,YAAalL,EAAW,KAAO,KAC/BmL,KAAM,QACNC,cAAe,iBAEfC,WAAYrL,EAAW,OAAS,aAChCF,WAAYA,EACZE,SAAUA,EAEV8B,kBAAmBA,GAEnBwJ,eAAgB,SAAStsB,GACvB2kB,EAAQ3kB,EAAO,OAAQ,OAAQ,OAAQ,IAAI9E,EAAWqxB,aAAa,GAAI,EAAG,MAC5E,EAEJ,GAEArxB,EAAWskB,eAAe,YAAa,aAAc,SAErDtkB,EAAWsxB,WAAW,kBAAmB,cACzCtxB,EAAWsxB,WAAW,kBAAmB,cACzCtxB,EAAWsxB,WAAW,yBAA0B,cAChDtxB,EAAWsxB,WAAW,2BAA4B,cAClDtxB,EAAWsxB,WAAW,yBAA0B,cAChDtxB,EAAWsxB,WAAW,mBAAoB,CAAEjI,KAAM,aAActD,MAAM,IACtE/lB,EAAWsxB,WAAW,qBAAsB,CAAEjI,KAAM,aAActD,MAAM,IACxE/lB,EAAWsxB,WAAW,4BAA6B,CAAEjI,KAAM,aAActD,MAAM,IAC/E/lB,EAAWsxB,WAAW,sBAAuB,CAAEjI,KAAM,aAAcxD,QAAQ,IAC3E7lB,EAAWsxB,WAAW,kBAAmB,CAAEjI,KAAM,aAAcnD,YAAY,IAC3ElmB,EAAWsxB,WAAW,yBAA0B,CAAEjI,KAAM,aAAcnD,YAAY,GAElF,E,mBC57BA,SAAUnmB,GAENA,EAAI,EAAQ,OAKf,EAPD,CAOG,SAASC,GACZ,aAEAA,EAAWwlB,WAAW,OAAQ,WAE5B,IAAI+L,EAAO,CAAC,OAAQ,QAAS,KAAM,MAAO,MAAO,MAC7CC,EAAe,IAAIxf,OAAO,QAAQuf,EAAKlqB,KAAK,OAAO,MAAO,KAE9D,MAAO,CACLjD,MAAO,SAAS4iB,EAAQliB,GACtB,IAAItE,EAAKwmB,EAAOc,OACZ2J,EAAM3sB,EAAMmiB,QAGhB,GAFAniB,EAAMmiB,SAAU,EAEN,KAANzmB,IAA4B,GAAdwmB,EAAOllB,KAAY,KAAKmB,KAAK+jB,EAAOviB,OAAOb,OAAOojB,EAAOllB,IAAM,KAE/E,OADAklB,EAAOW,YACA,UAGT,GAAIX,EAAO/iB,MAAM,oCACf,MAAO,SAET,GAAIa,EAAM4sB,SAAW1K,EAAOuJ,cAAgBzrB,EAAM6sB,OAC5B,OAApB3K,EAAOW,YAAoB,SAE7B,GADW7iB,EAAM4sB,UAAW5sB,EAAM4sB,SAAU,GACxC1K,EAAOsJ,MAAO,CAKhB,GAJAxrB,EAAM6sB,OAAS,EACf7sB,EAAM8sB,MAAO,EACb9sB,EAAM+sB,WAAY,EAEf7K,EAAO/iB,MAAM,OAAU,MAAO,MAEjC,GAAI+iB,EAAO/iB,MAAM,OAAU,MAAO,MAElC,GAAI+iB,EAAO/iB,MAAM,WAAc,MAAO,MACxC,CAEA,GAAI+iB,EAAO/iB,MAAM,kBASf,MARU,KAANzD,EACFsE,EAAMgtB,cACO,KAANtxB,EACPsE,EAAMgtB,cACO,KAANtxB,EACPsE,EAAMitB,aAENjtB,EAAMitB,aACD,OAIT,GAAIjtB,EAAMitB,WAAa,IAAMN,GAAa,KAANjxB,EAElC,OADAwmB,EAAOrjB,OACA,OAGT,GAAImB,EAAMgtB,YAAc,IAAML,GAAa,KAANjxB,EAKnC,OAJAsE,EAAM6sB,OAAS,EACf7sB,EAAM8sB,MAAO,EACb9sB,EAAM+sB,WAAY,EAClB7K,EAAOrjB,OACA,OAIT,GAAImB,EAAM+sB,UAAW,CAEnB,GAAI7K,EAAO/iB,MAAM,kBAA2C,OAAtBa,EAAM4sB,SAAU,EAAa,OAEnE,GAAI1K,EAAO/iB,MAAM,+BAAkC,MAAO,aAE1D,GAAyB,GAArBa,EAAMgtB,aAAoB9K,EAAO/iB,MAAM,wBAA2B,MAAO,SAC7E,GAAIa,EAAMgtB,YAAc,GAAK9K,EAAO/iB,MAAM,gCAAmC,MAAO,SAEpF,GAAI+iB,EAAO/iB,MAAMutB,GAAiB,MAAO,SAC3C,CAGA,OAAK1sB,EAAM8sB,MAAQ5K,EAAO/iB,MAAM,iFAC9Ba,EAAM8sB,MAAO,EACb9sB,EAAM6sB,OAAS3K,EAAOuJ,cACf,QAELzrB,EAAM8sB,MAAQ5K,EAAO/iB,MAAM,UAAYa,EAAM+sB,WAAY,EAAa,SAG1E/sB,EAAM+sB,WAAY,EAClB/sB,EAAMmiB,QAAiB,MAANzmB,EACjBwmB,EAAOrjB,OACA,KACT,EACAysB,WAAY,WACV,MAAO,CACLwB,MAAM,EACNC,WAAW,EACXF,OAAQ,EACRG,YAAa,EACbC,WAAY,EACZL,SAAS,EACTzK,SAAS,EAEb,EACA+J,YAAa,IACbC,KAAM,SAEV,GAEAjxB,EAAWsxB,WAAW,cAAe,QACrCtxB,EAAWsxB,WAAW,YAAa,OAEnC,E,mBCpHA,SAAUvxB,GAENA,EAAI,EAAQ,OAKf,EAPD,CAOG,SAASC,GACV,aACA,IAgHIgyB,EAAQC,EAhHR9xB,EAAMH,EAAWG,IAErB,SAAS+xB,EAAYC,GACnB,IAAIC,EAAQD,EAAOC,MACnB,OAAgB,MAATA,EAAgBA,GAASD,EAAOE,WAAa,IAAM,KACrDF,EAAOG,OAAS,IAAM,KACtBH,EAAOI,UAAY,IAAM,GAChC,CAEA,SAASC,EAAYL,EAAQC,GAE3B,IADA,IAAIrc,EAAUmc,EAAYC,GAAShe,EAAS4B,EACnCxQ,EAAI,EAAGA,EAAI6sB,EAAMvxB,OAAQ0E,KAA6C,GAApC4O,EAAOlB,QAAQmf,EAAMxuB,OAAO2B,MACrE4O,GAAUie,EAAMxuB,OAAO2B,IACzB,OAAOwQ,GAAW5B,EAASge,EAAS,IAAIngB,OAAOmgB,EAAOjN,OAAQ/Q,EAChE,CAEA,SAASse,EAAeN,GACtB,MAAO,0BAA0BlvB,KAAKkvB,EAAOjN,OAC/C,CAEA,SAASwN,EAAoBjwB,EAAK0vB,EAAQ5tB,GACxC4tB,EAASK,EAAYL,EAAQ,KAC7B,IAAK,IAAI5xB,EAAOgE,EAAMhE,KAAMC,EAAK+D,EAAM/D,GAAI+O,EAAO9M,EAAIa,WAAY/C,GAAQgP,EAAMhP,IAAQC,EAAK,EAAG,CAC9F2xB,EAAOQ,UAAYnyB,EACnB,IAAIiE,EAAShC,EAAIM,QAAQxC,GAAO0D,EAAQkuB,EAAO7c,KAAK7Q,GACpD,GAAIR,EACF,MAAO,CAACxC,KAAMtB,EAAII,EAAM0D,EAAMwkB,OACtB/mB,GAAIvB,EAAII,EAAM0D,EAAMwkB,MAAQxkB,EAAM,GAAGpD,QACrCoD,MAAOA,EACnB,CACF,CAEA,SAAS2uB,EAA6BnwB,EAAK0vB,EAAQ5tB,GACjD,IAAKkuB,EAAeN,GAAS,OAAOO,EAAoBjwB,EAAK0vB,EAAQ5tB,GAErE4tB,EAASK,EAAYL,EAAQ,MAE7B,IADA,IAAI1tB,EAAQouB,EAAQ,EACXtyB,EAAOgE,EAAMhE,KAAMgP,EAAO9M,EAAIa,WAAY/C,GAAQgP,GAAO,CAMhE,IAAK,IAAIhK,EAAI,EAAGA,EAAIstB,EAAOttB,IAAK,CAC9B,GAAIhF,EAAOgP,EAAM,MACjB,IAAIuV,EAAUriB,EAAIM,QAAQxC,KAC1BkE,EAAmB,MAAVA,EAAiBqgB,EAAUrgB,EAAS,KAAOqgB,CACtD,CACA+N,GAAgB,EAChBV,EAAOQ,UAAYpuB,EAAM/D,GACzB,IAAIyD,EAAQkuB,EAAO7c,KAAK7Q,GACxB,GAAIR,EAAO,CACT,IAAI6uB,EAASruB,EAAOvB,MAAM,EAAGe,EAAMwkB,OAAOsK,MAAM,MAAOC,EAAS/uB,EAAM,GAAG8uB,MAAM,MAC3EE,EAAY1uB,EAAMhE,KAAOuyB,EAAOjyB,OAAS,EAAGqyB,EAAUJ,EAAOA,EAAOjyB,OAAS,GAAGA,OACpF,MAAO,CAACY,KAAMtB,EAAI8yB,EAAWC,GACrBxxB,GAAIvB,EAAI8yB,EAAYD,EAAOnyB,OAAS,EACX,GAAjBmyB,EAAOnyB,OAAcqyB,EAAUF,EAAO,GAAGnyB,OAASmyB,EAAOA,EAAOnyB,OAAS,GAAGA,QACpFoD,MAAOA,EACjB,CACF,CACF,CAEA,SAASkvB,EAAY1uB,EAAQ0tB,EAAQiB,GACnC,IAAInvB,EAAOxC,EAAO,EAClB,MAAOA,GAAQgD,EAAO5D,OAAQ,CAC5BsxB,EAAOQ,UAAYlxB,EACnB,IAAI4xB,EAAWlB,EAAO7c,KAAK7Q,GAC3B,IAAK4uB,EAAU,MACf,IAAI7uB,EAAM6uB,EAAS5K,MAAQ4K,EAAS,GAAGxyB,OACvC,GAAI2D,EAAMC,EAAO5D,OAASuyB,EAAW,QAChCnvB,GAASO,EAAMP,EAAMwkB,MAAQxkB,EAAM,GAAGpD,UACzCoD,EAAQovB,GACV5xB,EAAO4xB,EAAS5K,MAAQ,CAC1B,CACA,OAAOxkB,CACT,CAEA,SAASqvB,EAAqB7wB,EAAK0vB,EAAQ5tB,GACzC4tB,EAASK,EAAYL,EAAQ,KAC7B,IAAK,IAAI5xB,EAAOgE,EAAMhE,KAAMC,EAAK+D,EAAM/D,GAAI2D,EAAQ1B,EAAIW,YAAa7C,GAAQ4D,EAAO5D,IAAQC,GAAM,EAAG,CAClG,IAAIiE,EAAShC,EAAIM,QAAQxC,GACrB0D,EAAQkvB,EAAY1uB,EAAQ0tB,EAAQ3xB,EAAK,EAAI,EAAIiE,EAAO5D,OAASL,GACrE,GAAIyD,EACF,MAAO,CAACxC,KAAMtB,EAAII,EAAM0D,EAAMwkB,OACtB/mB,GAAIvB,EAAII,EAAM0D,EAAMwkB,MAAQxkB,EAAM,GAAGpD,QACrCoD,MAAOA,EACnB,CACF,CAEA,SAASsvB,EAA8B9wB,EAAK0vB,EAAQ5tB,GAClD,IAAKkuB,EAAeN,GAAS,OAAOmB,EAAqB7wB,EAAK0vB,EAAQ5tB,GACtE4tB,EAASK,EAAYL,EAAQ,MAE7B,IADA,IAAI1tB,EAAQ+uB,EAAY,EAAGJ,EAAY3wB,EAAIM,QAAQwB,EAAMhE,MAAMM,OAAS0D,EAAM/D,GACrED,EAAOgE,EAAMhE,KAAM4D,EAAQ1B,EAAIW,YAAa7C,GAAQ4D,GAAQ,CACnE,IAAK,IAAIoB,EAAI,EAAGA,EAAIiuB,GAAajzB,GAAQ4D,EAAOoB,IAAK,CACnD,IAAIuf,EAAUriB,EAAIM,QAAQxC,KAC1BkE,EAAmB,MAAVA,EAAiBqgB,EAAUA,EAAU,KAAOrgB,CACvD,CACA+uB,GAAa,EAEb,IAAIvvB,EAAQkvB,EAAY1uB,EAAQ0tB,EAAQiB,GACxC,GAAInvB,EAAO,CACT,IAAI6uB,EAASruB,EAAOvB,MAAM,EAAGe,EAAMwkB,OAAOsK,MAAM,MAAOC,EAAS/uB,EAAM,GAAG8uB,MAAM,MAC3EE,EAAY1yB,EAAOuyB,EAAOjyB,OAAQqyB,EAAUJ,EAAOA,EAAOjyB,OAAS,GAAGA,OAC1E,MAAO,CAACY,KAAMtB,EAAI8yB,EAAWC,GACrBxxB,GAAIvB,EAAI8yB,EAAYD,EAAOnyB,OAAS,EACX,GAAjBmyB,EAAOnyB,OAAcqyB,EAAUF,EAAO,GAAGnyB,OAASmyB,EAAOA,EAAOnyB,OAAS,GAAGA,QACpFoD,MAAOA,EACjB,CACF,CACF,CAaA,SAASwvB,EAAUC,EAAMC,EAAQ7xB,EAAK8xB,GACpC,GAAIF,EAAK7yB,QAAU8yB,EAAO9yB,OAAQ,OAAOiB,EACzC,IAAK,IAAIX,EAAM,EAAGue,EAAM5d,EAAMZ,KAAKwe,IAAI,EAAGgU,EAAK7yB,OAAS8yB,EAAO9yB,UAAW,CACxE,GAAIM,GAAOue,EAAK,OAAOve,EACvB,IAAI0yB,EAAO1yB,EAAMue,GAAQ,EACrBrQ,EAAMukB,EAASF,EAAKxwB,MAAM,EAAG2wB,IAAMhzB,OACvC,GAAIwO,GAAOvN,EAAK,OAAO+xB,EACdxkB,EAAMvN,EAAK4d,EAAMmU,EACrB1yB,EAAM0yB,EAAM,CACnB,CACF,CAEA,SAASC,EAAoBrxB,EAAKsP,EAAOxN,EAAOwvB,GAG9C,IAAKhiB,EAAMlR,OAAQ,OAAO,KAC1B,IAAIowB,EAAO8C,EAAW/B,EAASC,EAC3Bxe,EAAQwd,EAAKlf,GAAOghB,MAAM,YAE9BhnB,EAAQ,IAAK,IAAIxL,EAAOgE,EAAMhE,KAAMC,EAAK+D,EAAM/D,GAAI+O,EAAO9M,EAAIa,WAAa,EAAImQ,EAAM5S,OAAQN,GAAQgP,EAAMhP,IAAQC,EAAK,EAAG,CACzH,IAAIkzB,EAAOjxB,EAAIM,QAAQxC,GAAM2C,MAAM1C,GAAKiE,EAASwsB,EAAKyC,GACtD,GAAoB,GAAhBjgB,EAAM5S,OAAa,CACrB,IAAIsR,EAAQ1N,EAAOwO,QAAQQ,EAAM,IACjC,IAAc,GAAVtB,EAAa,SAASpG,EACtBxH,EAAQkvB,EAAUC,EAAMjvB,EAAQ0N,EAAO8e,GAAQzwB,EACnD,MAAO,CAACiB,KAAMtB,EAAII,EAAMkzB,EAAUC,EAAMjvB,EAAQ0N,EAAO8e,GAAQzwB,GACvDkB,GAAIvB,EAAII,EAAMkzB,EAAUC,EAAMjvB,EAAQ0N,EAAQsB,EAAM,GAAG5S,OAAQowB,GAAQzwB,GACjF,CACE,IAAIwzB,EAAUvvB,EAAO5D,OAAS4S,EAAM,GAAG5S,OACvC,GAAI4D,EAAOvB,MAAM8wB,IAAYvgB,EAAM,GAAnC,CACA,IAAK,IAAIlO,EAAI,EAAGA,EAAIkO,EAAM5S,OAAS,EAAG0E,IACpC,GAAI0rB,EAAKxuB,EAAIM,QAAQxC,EAAOgF,KAAOkO,EAAMlO,GAAI,SAASwG,EACxD,IAAIvH,EAAM/B,EAAIM,QAAQxC,EAAOkT,EAAM5S,OAAS,GAAIozB,EAAYhD,EAAKzsB,GAAMlB,EAAWmQ,EAAMA,EAAM5S,OAAS,GACvG,GAAIozB,EAAU/wB,MAAM,EAAGI,EAASzC,SAAWyC,EAC3C,MAAO,CAAC7B,KAAMtB,EAAII,EAAMkzB,EAAUC,EAAMjvB,EAAQuvB,EAAS/C,GAAQzwB,GACzDkB,GAAIvB,EAAII,EAAOkT,EAAM5S,OAAS,EAAG4yB,EAAUjvB,EAAKyvB,EAAW3wB,EAASzC,OAAQowB,IANpCllB,CAQpD,CACF,CAEA,SAASmoB,EAAqBzxB,EAAKsP,EAAOxN,EAAOwvB,GAC/C,IAAKhiB,EAAMlR,OAAQ,OAAO,KAC1B,IAAIowB,EAAO8C,EAAW/B,EAASC,EAC3Bxe,EAAQwd,EAAKlf,GAAOghB,MAAM,YAE9BhnB,EAAQ,IAAK,IAAIxL,EAAOgE,EAAMhE,KAAMC,EAAK+D,EAAM/D,GAAI2D,EAAQ1B,EAAIW,YAAc,EAAIqQ,EAAM5S,OAAQN,GAAQ4D,EAAO5D,IAAQC,GAAM,EAAG,CAC7H,IAAIkzB,EAAOjxB,EAAIM,QAAQxC,GACnBC,GAAM,IAAGkzB,EAAOA,EAAKxwB,MAAM,EAAG1C,IAClC,IAAIiE,EAASwsB,EAAKyC,GAClB,GAAoB,GAAhBjgB,EAAM5S,OAAa,CACrB,IAAIsR,EAAQ1N,EAAO4gB,YAAY5R,EAAM,IACrC,IAAc,GAAVtB,EAAa,SAASpG,EAC1B,MAAO,CAACtK,KAAMtB,EAAII,EAAMkzB,EAAUC,EAAMjvB,EAAQ0N,EAAO8e,IAC/CvvB,GAAIvB,EAAII,EAAMkzB,EAAUC,EAAMjvB,EAAQ0N,EAAQsB,EAAM,GAAG5S,OAAQowB,IACzE,CACE,IAAI3tB,EAAWmQ,EAAMA,EAAM5S,OAAS,GACpC,GAAI4D,EAAOvB,MAAM,EAAGI,EAASzC,SAAWyC,EAAxC,CACK,IAAIiC,EAAI,EAAb,IAAgBhB,EAAQhE,EAAOkT,EAAM5S,OAAS,EAAG0E,EAAIkO,EAAM5S,OAAS,EAAG0E,IACrE,GAAI0rB,EAAKxuB,EAAIM,QAAQwB,EAAQgB,KAAOkO,EAAMlO,GAAI,SAASwG,EACzD,IAAI+E,EAAMrO,EAAIM,QAAQxC,EAAO,EAAIkT,EAAM5S,QAASszB,EAAYlD,EAAKngB,GACjE,GAAIqjB,EAAUjxB,MAAMixB,EAAUtzB,OAAS4S,EAAM,GAAG5S,SAAW4S,EAAM,GACjE,MAAO,CAAChS,KAAMtB,EAAII,EAAO,EAAIkT,EAAM5S,OAAQ4yB,EAAU3iB,EAAKqjB,EAAWrjB,EAAIjQ,OAAS4S,EAAM,GAAG5S,OAAQowB,IAC3FvvB,GAAIvB,EAAII,EAAMkzB,EAAUC,EAAMjvB,EAAQnB,EAASzC,OAAQowB,IANJllB,CAQ/D,CACF,CAEA,SAASqoB,EAAa3xB,EAAKsP,EAAOjQ,EAAKoX,GAOrC,IAAI6a,EANJ5a,KAAKkb,cAAe,EACpBlb,KAAKmb,iBAAkB,EACvBnb,KAAK1W,IAAMA,EACXX,EAAMA,EAAMW,EAAIc,QAAQzB,GAAO3B,EAAI,EAAG,GACtCgZ,KAAKrX,IAAM,CAACL,KAAMK,EAAKJ,GAAII,GAGL,iBAAXoX,EACT6a,EAAW7a,EAAQ6a,UAEnBA,EAAW7a,EACXA,EAAU,MAGQ,iBAATnH,GACO,MAAZgiB,IAAkBA,GAAW,GACjC5a,KAAKX,QAAU,SAAS+b,EAASzyB,GAC/B,OAAQyyB,EAAUL,EAAuBJ,GAAqBrxB,EAAKsP,EAAOjQ,EAAKiyB,EACjF,IAEAhiB,EAAQygB,EAAYzgB,EAAO,MACtBmH,IAAiC,IAAtBA,EAAQqZ,UAKtBpZ,KAAKX,QAAU,SAAS+b,EAASzyB,GAC/B,OAAQyyB,EAAUjB,EAAuBZ,GAAqBjwB,EAAKsP,EAAOjQ,EAC5E,EANAqX,KAAKX,QAAU,SAAS+b,EAASzyB,GAC/B,OAAQyyB,EAAUhB,EAAgCX,GAA8BnwB,EAAKsP,EAAOjQ,EAC9F,EAMN,CA5GIyL,OAAO8V,UAAUmR,WACnBxC,EAAS,SAASrxB,GAAO,OAAOA,EAAI6zB,UAAU,OAAOvoB,aAAc,EACnEgmB,EAAS,SAAStxB,GAAO,OAAOA,EAAI6zB,UAAU,MAAO,IAErDxC,EAAS,SAASrxB,GAAO,OAAOA,EAAIsL,aAAc,EAClDgmB,EAAS,SAAStxB,GAAO,OAAOA,CAAI,GAyGtCyzB,EAAa/Q,UAAY,CACvBjR,SAAU,WAAY,OAAO+G,KAAKnD,MAAK,EAAM,EAC7C5B,aAAc,WAAY,OAAO+E,KAAKnD,MAAK,EAAK,EAEhDA,KAAM,SAASue,GACb,IAAIruB,EAAOiT,KAAK1W,IAAIc,QAAQgxB,EAAUpb,KAAKrX,IAAIL,KAAO0X,KAAKrX,IAAIJ,IAC/D,GAAIyX,KAAKmb,iBAAmBnb,KAAKkb,eAE/BnuB,EAAO/F,EAAI+F,EAAK3F,KAAM2F,EAAK1F,IACvB+zB,GACFruB,EAAK1F,KACD0F,EAAK1F,GAAK,IACZ0F,EAAK3F,OACL2F,EAAK1F,IAAM2Y,KAAK1W,IAAIM,QAAQmD,EAAK3F,OAAS,IAAIM,UAGhDqF,EAAK1F,KACD0F,EAAK1F,IAAM2Y,KAAK1W,IAAIM,QAAQmD,EAAK3F,OAAS,IAAIM,SAChDqF,EAAK1F,GAAK,EACV0F,EAAK3F,SAG8C,GAAnDP,EAAWsQ,OAAOpK,EAAMiT,KAAK1W,IAAIc,QAAQ2C,KAC1C,OAAOiT,KAAKkb,cAAe,EAGhC,IAAI7R,EAASrJ,KAAKX,QAAQ+b,EAASruB,GAGnC,GAFAiT,KAAKmb,gBAAkB9R,GAAuD,GAA7CxiB,EAAWsQ,OAAOkS,EAAO/gB,KAAM+gB,EAAO9gB,IAEnE8gB,EAGF,OAFArJ,KAAKrX,IAAM0gB,EACXrJ,KAAKkb,cAAe,EACblb,KAAKrX,IAAImC,QAAS,EAEzB,IAAIO,EAAMrE,EAAIo0B,EAAUpb,KAAK1W,IAAIW,YAAc+V,KAAK1W,IAAIa,WAAa,EAAG,GAExE,OADA6V,KAAKrX,IAAM,CAACL,KAAM+C,EAAK9C,GAAI8C,GACpB2U,KAAKkb,cAAe,CAE/B,EAEA5yB,KAAM,WAAY,GAAI0X,KAAKkb,aAAc,OAAOlb,KAAKrX,IAAIL,IAAI,EAC7DC,GAAI,WAAY,GAAIyX,KAAKkb,aAAc,OAAOlb,KAAKrX,IAAIJ,EAAE,EAEzDsiB,QAAS,SAASyQ,EAASttB,GACzB,GAAKgS,KAAKkb,aAAV,CACA,IAAI5gB,EAAQzT,EAAW00B,WAAWD,GAClCtb,KAAK1W,IAAIR,aAAawR,EAAO0F,KAAKrX,IAAIL,KAAM0X,KAAKrX,IAAIJ,GAAIyF,GACzDgS,KAAKrX,IAAIJ,GAAKvB,EAAIgZ,KAAKrX,IAAIL,KAAKlB,KAAOkT,EAAM5S,OAAS,EACpC4S,EAAMA,EAAM5S,OAAS,GAAGA,QAA0B,GAAhB4S,EAAM5S,OAAcsY,KAAKrX,IAAIL,KAAKjB,GAAK,GAJnE,CAK1B,GAGFR,EAAWka,gBAAgB,kBAAmB,SAASnI,EAAOjQ,EAAKiyB,GACjE,OAAO,IAAIK,EAAajb,KAAK1W,IAAKsP,EAAOjQ,EAAKiyB,EAChD,GACA/zB,EAAW20B,mBAAmB,kBAAmB,SAAS5iB,EAAOjQ,EAAKiyB,GACpE,OAAO,IAAIK,EAAajb,KAAMpH,EAAOjQ,EAAKiyB,EAC5C,GAEA/zB,EAAWka,gBAAgB,gBAAiB,SAASnI,EAAOgiB,GAC1D,IAAIjkB,EAAS,GACTmC,EAAMkH,KAAKjH,gBAAgBH,EAAOoH,KAAKvT,UAAU,QAASmuB,GAC9D,MAAO9hB,EAAIG,WAAY,CACrB,GAAIpS,EAAWsQ,OAAO2B,EAAIvQ,KAAMyX,KAAKvT,UAAU,OAAS,EAAG,MAC3DkK,EAAOlP,KAAK,CAAC0F,OAAQ2L,EAAIxQ,OAAQyE,KAAM+L,EAAIvQ,MAC7C,CACIoO,EAAOjP,QACTsY,KAAKzJ,cAAcI,EAAQ,EAC/B,EACF,E,mBC7SA,SAAU/P,GAENA,EAAI,EAAQ,OAKf,EAPD,CAOG,SAASC,GACZ,aAMAA,EAAWskB,eAAe,OAAQ,OAAQ,SAAS1iB,GACjD,IAAIuQ,EAAQ,GACZ,IAAKwI,OAAOia,OAIV,OAHIja,OAAOka,SACTla,OAAOka,QAAQC,MAAM,yEAEhB3iB,EAET,IAAMyiB,OAAOG,QAAQnzB,EAAO,CAC5B,MAAM2M,GACF,IAAIymB,EAAMzmB,EAAE0mB,KAMRxzB,EAAOuzB,EAAMh1B,EAAWG,IAAI60B,EAAIz0B,KAAMy0B,EAAI7d,QAAUnX,EAAWG,IAAI,EAAG,GACtEuB,EAAKD,EACT0Q,EAAMvR,KAAK,CAAEa,KAAMA,EAAMC,GAAIA,EAAIwzB,QAAS3mB,EAAE2mB,SAChD,CACA,OAAO/iB,CACT,EAEA,E,kVCnCA,SAAUpS,GAENA,EAAI,EAAQ,OAKf,EAPD,CAOG,SAASC,GACV,SAASm1B,EAAU3zB,EAAI4zB,EAAUxsB,GAC/B,IACIysB,EADAvxB,EAAOtC,EAAGkgB,oBAcd,OAZA2T,EAASvxB,EAAK0E,YAAYP,SAASG,cAAc,QAE/CitB,EAAOpX,UADLrV,EACiB,6CAEA,0CAEE,iBAAZwsB,EACTC,EAAOC,UAAYF,EAEnBC,EAAO7sB,YAAY4sB,GAErBp1B,EAAWu1B,SAASzxB,EAAM,iBACnBuxB,CACT,CAEA,SAASG,EAAkBh0B,EAAIi0B,GACzBj0B,EAAGsD,MAAM4wB,0BACXl0B,EAAGsD,MAAM4wB,2BACXl0B,EAAGsD,MAAM4wB,yBAA2BD,CACtC,CAEAz1B,EAAWka,gBAAgB,aAAc,SAASkb,EAAU1S,EAAUxJ,GAC/DA,IAASA,EAAU,CAAC,GAEzBsc,EAAkBrc,KAAM,MAExB,IAAIkc,EAASF,EAAUhc,KAAMic,EAAUlc,EAAQtQ,QAC3C+sB,GAAS,EAAOrI,EAAKnU,KACzB,SAASmB,EAAMmb,GACb,GAAqB,iBAAVA,EACTG,EAAIrK,MAAQkK,MACP,CACL,GAAIE,EAAQ,OACZA,GAAS,EACT31B,EAAW61B,QAAQR,EAAOhY,WAAY,iBACtCgY,EAAOhY,WAAWyG,YAAYuR,GAC9B/H,EAAGrL,QAEC/I,EAAQ4c,SAAS5c,EAAQ4c,QAAQT,EACvC,CACF,CAEA,IAAmDU,EAA/CH,EAAMP,EAAOW,qBAAqB,SAAS,GAuC/C,OAtCIJ,GACFA,EAAI3T,QAEA/I,EAAQqS,QACVqK,EAAIrK,MAAQrS,EAAQqS,OACc,IAA9BrS,EAAQ+c,mBACVL,EAAIM,UAIJhd,EAAQid,SACVn2B,EAAWyG,GAAGmvB,EAAK,QAAS,SAASrnB,GAAK2K,EAAQid,QAAQ5nB,EAAGqnB,EAAIrK,MAAOjR,EAAO,GAC7EpB,EAAQkd,SACVp2B,EAAWyG,GAAGmvB,EAAK,QAAS,SAASrnB,GAAI2K,EAAQkd,QAAQ7nB,EAAGqnB,EAAIrK,MAAOjR,EAAO,GAEhFta,EAAWyG,GAAGmvB,EAAK,UAAW,SAASrnB,GACjC2K,GAAWA,EAAQmd,WAAand,EAAQmd,UAAU9nB,EAAGqnB,EAAIrK,MAAOjR,MACnD,IAAb/L,EAAE+nB,UAA2C,IAAzBpd,EAAQqd,cAAuC,IAAbhoB,EAAE+nB,WAC1DV,EAAIY,OACJx2B,EAAWy2B,OAAOloB,GAClB+L,KAEe,IAAb/L,EAAE+nB,SAAe5T,EAASkT,EAAIrK,MAAOhd,GAC3C,IAE4B,IAAxB2K,EAAQwd,aAAuB12B,EAAWyG,GAAG4uB,EAAQ,WAAY,SAAUsB,GACnD,OAAtBA,EAAIC,eAAwBtc,GAClC,KACSyb,EAASV,EAAOW,qBAAqB,UAAU,MACxDh2B,EAAWyG,GAAGsvB,EAAQ,QAAS,WAC7Bzb,IACAgT,EAAGrL,OACL,IAE4B,IAAxB/I,EAAQwd,aAAuB12B,EAAWyG,GAAGsvB,EAAQ,OAAQzb,GAEjEyb,EAAO9T,SAEF3H,CACT,GAEAta,EAAWka,gBAAgB,cAAe,SAASkb,EAAUyB,EAAW3d,GACtEsc,EAAkBrc,KAAM,MACxB,IAAIkc,EAASF,EAAUhc,KAAMic,EAAUlc,GAAWA,EAAQtQ,QACtDkuB,EAAUzB,EAAOW,qBAAqB,UACtCL,GAAS,EAAOrI,EAAKnU,KAAM4d,EAAW,EAC1C,SAASzc,IACHqb,IACJA,GAAS,EACT31B,EAAW61B,QAAQR,EAAOhY,WAAY,iBACtCgY,EAAOhY,WAAWyG,YAAYuR,GAC9B/H,EAAGrL,QACL,CACA6U,EAAQ,GAAG7U,QACX,IAAK,IAAI1c,EAAI,EAAGA,EAAIuxB,EAAQj2B,SAAU0E,EAAG,CACvC,IAAIjF,EAAIw2B,EAAQvxB,IAChB,SAAUmd,GACR1iB,EAAWyG,GAAGnG,EAAG,QAAS,SAASiO,GACjCvO,EAAWg3B,iBAAiBzoB,GAC5B+L,IACIoI,GAAUA,EAAS4K,EACzB,EACD,EAND,CAMGuJ,EAAUtxB,IACbvF,EAAWyG,GAAGnG,EAAG,OAAQ,aACrBy2B,EACFlc,WAAW,WAAiBkc,GAAY,GAAGzc,GAAS,EAAG,IACzD,GACAta,EAAWyG,GAAGnG,EAAG,QAAS,aAAey2B,CAAU,EACrD,CACF,GAUA/2B,EAAWka,gBAAgB,mBAAoB,SAASkb,EAAUlc,GAChEsc,EAAkBrc,KAAMmB,GACxB,IACoB2c,EADhB5B,EAASF,EAAUhc,KAAMic,EAAUlc,GAAWA,EAAQtQ,QACtD+sB,GAAS,EACTuB,EAAWhe,GAAuC,qBAArBA,EAAQge,SAA2Bhe,EAAQge,SAAW,IAEvF,SAAS5c,IACHqb,IACJA,GAAS,EACT5a,aAAakc,GACbj3B,EAAW61B,QAAQR,EAAOhY,WAAY,iBACtCgY,EAAOhY,WAAWyG,YAAYuR,GAChC,CAUA,OARAr1B,EAAWyG,GAAG4uB,EAAQ,QAAS,SAAS9mB,GACtCvO,EAAWg3B,iBAAiBzoB,GAC5B+L,GACF,GAEI4c,IACFD,EAAYpc,WAAWP,EAAO4c,IAEzB5c,CACT,EACF,E,kBC/JA,IAAI/a,EAAU,EAAQ,MACnBA,EAAQC,aAAYD,EAAUA,EAAQE,SACnB,kBAAZF,IAAsBA,EAAU,CAAC,CAACG,EAAOC,GAAIJ,EAAS,MAC7DA,EAAQK,SAAQF,EAAOG,QAAUN,EAAQK,QAE5C,IAAIE,EAAM,WACGA,EAAI,WAAYP,GAAS,EAAM,CAAC,WAAY,EAAM,YAAa,G,sNCsB5E,SAAS43B,EAAc31B,EAAI41B,GACzB,MAAO,cAAcn0B,KAAKzB,EAAG+S,eAAe,QAAe6iB,EAAQ,IACrE,CAEA,SAASC,EAAc71B,EAAI41B,GACzB,MAAMx1B,EAAOJ,EAAGuB,QAAQq0B,GAAQ5S,OAAO,GACjC8S,EAAU11B,EAAKmK,OAAO,MAE5B,IAAiB,IAAburB,EACF,OAAQ,EAGV,MAAMpc,EAAM,gBAAuBtZ,EAAM,KAAMJ,EAAGoL,UAAU,YAE5D,OAAOsO,CACT,CAQA,SAASqc,EAAW/1B,EAAI41B,GACtB,IAAIx1B,EAAOJ,EAAGuB,QAAQq0B,GACtB,MAAMnzB,EAAQrC,EAAKqC,MAAM,sBAEzB,IAAMA,EACJ,OAAQ,EAGV,MAAMqzB,EAAUrzB,EAAM,GAAGpD,OAIzB,OAFAe,GAAO,QAAO,GAAI01B,GAAWrzB,EAAM,GAE9B,cAAchB,KAAKzB,EAAG+S,eAAe,QAAe6iB,EAAQE,EAAU,MACjE,EAGH,gBAAuB11B,EAAM,KAAMJ,EAAGoL,UAAU,WACzD,CA+CA,SAAS4qB,EAAYj3B,GACnB,IAAK,IAAIgF,EAAI,EAAGA,EAAIhF,EAAKM,OAAQ0E,IAC/B,GAAgB,MAAZhF,EAAKgF,GACP,OAAOA,EAIX,OAAOhF,EAAKM,MACd,CAyHA,SAAS42B,EAAiBj2B,GACpBA,EAAGsD,MAAM4yB,iBACXl2B,EAAG4N,UAAU,KACXqL,EAAOjZ,IAGb,CAEA,SAASm2B,EAASn2B,GACZA,EAAGsD,MAAM4yB,iBAAmBl2B,EAAGsD,MAAM4yB,gBAAgB72B,QACvDW,EAAG4N,UAAU,KACXoH,EAAMhV,IAGZ,CA3LA,mBAA0B,OAAQ,SAAU,CAACA,EAAI+C,KAC/C,MAAMqzB,EAAWL,EAAW/1B,EAAI+C,EAAMhE,MAEtC,GAAIq3B,EAAW,EACb,OAEF,IAAIC,EAAiB,KAIrB,IAAK,IAAItyB,EAAIhB,EAAMhE,KAAO,EAAGiE,EAAMhD,EAAG8B,WAAYiC,GAAKf,IAAOe,EAAG,CAC/D,MAAMyP,EAASuiB,EAAW/1B,EAAI+D,GAE9B,IAAgB,IAAZyP,OACG,MAAIA,EAAS4iB,GAOlB,MALAC,EAAiBtyB,CAMnB,CACF,CACA,OAAIsyB,EACK,CACLp2B,KAAM,QAAe8C,EAAMhE,KAAMiB,EAAGuB,QAAQwB,EAAMhE,MAAMM,QACxDa,GAAM,QAAem2B,EAAgBr2B,EAAGuB,QAAQ80B,GAAgBh3B,cAHpE,IAQF,oBAA2B,oBAAqB,SAASi3B,GACvD3e,KAAK/J,UAAU,KACb,IAAK,IAAI7J,EAAI4T,KAAK/V,YAAamL,EAAI4K,KAAK7V,WAAYiC,GAAKgJ,EAAGhJ,IAAK,CAC/D,MAAMhF,EAAO4Y,KAAKpW,QAAQwC,GAErBhF,EAAK0D,MAAM6zB,IACd3e,KAAK4e,SAAS,QAAexyB,EAAG,GAAI,KAAM,OAE9C,GAEJ,GAYA,oBAA2B,WAAY,SAASyyB,GAC9C7e,KAAK/J,UAAU,KACb,IAAI6oB,EAAW,GAEf,IAAK,IAAI1yB,EAAI4T,KAAK/V,YAAamL,EAAI4K,KAAK7V,WAAYiC,GAAKgJ,EAAGhJ,IAAK,CAC/D,MAAMhF,EAAO4Y,KAAKpW,QAAQwC,GACpBkjB,EAAQ+O,EAAYj3B,GACpB23B,EAAU33B,EAAK43B,OAErB,GAAID,EAAQE,SAAS,MAAQF,EAAQE,SAAS,QAAS,CACrD,MAAM/O,EAAO6O,EAAQnF,MAAM,KAAK,GAAGvO,OAAO,EAAG0T,EAAQr3B,OAAS,GAG9Do3B,EAAWA,EAASxlB,OAAQlE,GAAMA,EAAEka,MAAQA,GAG5CwP,EAASr3B,KAAK,CACZ6nB,QACAY,SAGF,MAAMgP,EAAcJ,EAASK,IAAK/pB,GAAMA,EAAE8a,MAAMhiB,KAAK,KAEjDgxB,IAAgBL,GAClB7e,KAAK4e,SAAS,QAAexyB,EAAG,GAAI,KAAM,OAE9C,CACF,GAEJ,GAEA,mBAA0B,OAAQ,eAAgB,CAAC/D,EAAI+C,KACrD,IAAM4yB,EAAc31B,EAAI+C,EAAMhE,MAC5B,OAGF,MAAMq3B,EAAWP,EAAc71B,EAAI+C,EAAMhE,MAEzC,GAAIq3B,EAAW,EACb,OAGF,IAAIC,EAAiB,KAIrB,IAAK,IAAItyB,EAAIhB,EAAMhE,KAAO,EAAGiE,EAAMhD,EAAG8B,WAAYiC,GAAKf,IAAOe,EAAG,CAC/D,IAAM4xB,EAAc31B,EAAI+D,GACtB,MAGF,MAAMyP,EAASqiB,EAAc71B,EAAI+D,GAEjC,IAAgB,IAAZyP,OAEG,MAAIA,EAAS4iB,GAOlB,MALAC,EAAiBtyB,CAMnB,CACF,CAEA,OAAIsyB,EACK,CACLp2B,KAAM,QAAe8C,EAAMhE,KAAMiB,EAAGuB,QAAQwB,EAAMhE,MAAMM,QACxDa,GAAM,QAAem2B,EAAgBr2B,EAAGuB,QAAQ80B,GAAgBh3B,cAHpE,IAYF,iBAAwB,0BAA0B,EAAQ03B,IACxDA,EAAWC,WAAW,CACpBnP,KAAO,4BACPjlB,MAAQ4iB,GACFA,EAAOviB,OAAOuiB,EAAOllB,KAAKmC,MAAM,OAClC+iB,EAAOrjB,OAEAqjB,EAAOllB,IAAM,IAAM,EAAI,sCAAwC,uCAGxEklB,EAAOrjB,OAEA,UAYb,iBAAwB,qBAAqB,EAAO,CAACnC,EAAIqb,EAAK4b,KAC5D,MAAMjkB,EAAOikB,GAAOA,IAAQ,SAExB5b,IAAQrI,GACVhT,EAAGsD,MAAM4yB,gBAAkB,GAC3Bl2B,EAAGsD,MAAM4zB,qBAAsC,kBAAR7b,EAAmBA,EAAM,0BAChE8b,EAAMn3B,GACNA,EAAGiF,GAAG,iBAAkBgxB,GACxBj2B,EAAGiF,GAAG,SAAUkxB,KACN9a,GAAOrI,IACjBhT,EAAGwF,IAAI,iBAAkBywB,GACzBj2B,EAAGwF,IAAI,SAAU2wB,GACjBnhB,EAAMhV,GACNA,EAAGsD,MAAM4yB,gBAAkBl2B,EAAGsD,MAAM4zB,qBAAuB,QAoB/D,MAAME,EAAa,EACbz4B,EAAM,QACN04B,EAAM,WAEZ,SAASC,EAAWt3B,EAAIC,EAAMC,EAAIq3B,GAChC,GAAsB,IAAlBF,EAAIp3B,EAAMC,GACZ,OAEF,MAAMs3B,EAAQx3B,EAAGsD,MAAM4yB,gBACjBuB,EAAMz3B,EAAGsD,MAAM4zB,qBAErB,IAAK,IAAIn4B,EAAOkB,EAAKlB,OAAQ,CAC3B,MAAMgE,EAAQhE,IAASkB,EAAKlB,KAAOkB,EAAOtB,EAAII,EAAM,GAC9C4kB,EAAU5kB,EAAOq4B,EAAkBM,EAAQ/T,GAAWzjB,EAAGnB,KACzDiE,EAAM00B,EAAQx3B,EAAKvB,EAAIglB,EAAS,GAChC8P,EAAOzzB,EAAGmV,SAASpS,EAAOC,EAAK,CAAEyZ,UAAWgb,IAOlD,GALc,OAAVF,QAA4B5lB,IAAV4lB,EACpBC,EAAMp4B,KAAKq0B,GAEX+D,EAAMtiB,OAAOqiB,IAAS,EAAG9D,GAEvBiE,EACF,MAEF34B,EAAO4kB,CACT,CACF,CAEA,SAAS3O,EAAMhV,GACb,MAAMw3B,EAAQx3B,EAAGsD,MAAM4yB,gBAEvB,IAAK,IAAInyB,EAAI,EAAGA,EAAIyzB,EAAMn4B,SAAU0E,EAClCyzB,EAAMzzB,GAAGiR,QAEXwiB,EAAMn4B,OAAS,CACjB,CAEA,SAAS83B,EAAMn3B,GACbgV,EAAMhV,GACN,MAAMsO,EAAStO,EAAGyE,iBAElB,IAAK,IAAIV,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IACjCuzB,EAAWt3B,EAAIsO,EAAOvK,GAAG9D,OAAQqO,EAAOvK,GAAG7D,KAE/C,CAEA,SAAS+Y,EAAOjZ,GACd,IAAKA,EAAG4E,oBACN,OAAOoQ,EAAMhV,GAEf,GAAIA,EAAGyE,iBAAiBpF,OAAS,EAC/B,OAAO83B,EAAMn3B,GAGf,MAAMC,EAAOD,EAAGoE,UAAU,SAAgBlE,EAAKF,EAAGoE,UAAU,OAEtDozB,EAAQx3B,EAAGsD,MAAM4yB,gBAEvB,IAAKsB,EAAMn4B,OACT,OAAOi4B,EAAWt3B,EAAIC,EAAMC,GAG9B,IAAIy3B,EAAaH,EAAM,GAAGhjB,OAAYojB,EAAWJ,EAAMA,EAAMn4B,OAAS,GAAGmV,OAEzE,IAAKmjB,IAAeC,GAAY13B,EAAGnB,KAAOkB,EAAKlB,MAAQq4B,GACnDC,EAAIp3B,EAAM23B,EAAS13B,KAAO,GAAKm3B,EAAIn3B,EAAIy3B,EAAW13B,OAAS,EAC7D,OAAOk3B,EAAMn3B,GAGf,MAAOq3B,EAAIp3B,EAAM03B,EAAW13B,MAAQ,EAClCu3B,EAAMl4B,QAAQ0V,QACd2iB,EAAaH,EAAM,GAAGhjB,OAEpB6iB,EAAIp3B,EAAM03B,EAAW13B,MAAQ,IAC3B03B,EAAWz3B,GAAGnB,KAAOkB,EAAKlB,KAAOq4B,GACnCI,EAAMl4B,QAAQ0V,QACdsiB,EAAWt3B,EAAIC,EAAM03B,EAAWz3B,GAAI,IAEpCo3B,EAAWt3B,EAAIC,EAAM03B,EAAW13B,KAAM,IAI1C,MAAOo3B,EAAIn3B,EAAI03B,EAAS13B,IAAM,EAC5Bs3B,EAAM33B,MAAMmV,QACZ4iB,EAAWJ,EAAMA,EAAMn4B,OAAS,GAAGmV,OAEjC6iB,EAAIn3B,EAAI03B,EAAS13B,IAAM,IACrBA,EAAGnB,KAAO64B,EAAS33B,KAAKlB,KAAOq4B,GACjCI,EAAM33B,MAAMmV,QACZsiB,EAAWt3B,EAAI43B,EAAS33B,KAAMC,IAE9Bo3B,EAAWt3B,EAAI43B,EAAS13B,GAAIA,GAGlC,C,ocCnWIoM,EAA0B,IAA4B,KAE1DA,EAAwBlN,KAAK,CAAClB,EAAOC,GAAI,ytDAA0tD,KAEnwD,S,kCCPA,SAAUI,GAEJA,EAAI,EAAQ,OAAsB,EAAQ,OAAiC,EAAQ,OAA2B,EAAQ,OAKzH,EAPH,CAOK,SAASC,GACV,aAqCJ,SAASq5B,EAAUr5B,GAEjB,IAAIG,EAAMH,EAAWG,IAErB,SAASm5B,EAAgB93B,EAAIoN,GAC3B,IAAI2qB,EAAM/3B,EAAGsD,MAAMy0B,IACnB,IAAKA,GAAOA,EAAIC,WAAY,OAAO5qB,EAAM1I,KACzC,IAAIA,EAAOqzB,EAAI72B,IAAIwD,KACnB,OAAKA,EAEDqzB,EAAIE,aACF7qB,EAAM1I,KAAK3F,MAAQ2F,EAAK3F,UAD9B,EAKIqO,EAAMnN,QAAUmN,EAAMtI,QAAWsI,EAAMG,SACrCH,EAAM1I,KAAK3F,MAAQ2F,EAAK3F,MAAQqO,EAAM1I,KAAK1F,IAAM0F,EAAK1F,GAIrDoO,EAAM1I,KAHF,IAAI/F,EAAIyO,EAAM1I,KAAK3F,KAAMqO,EAAM1I,KAAK1F,GAAK,GATjCoO,EAAM1I,IAa3B,CAEA,IAAIwzB,EAAgB,CAGlB,CAAEC,KAAM,SAAUtrB,KAAM,WAAYurB,OAAQ,KAC5C,CAAED,KAAM,UAAWtrB,KAAM,WAAYurB,OAAQ,KAC7C,CAAED,KAAM,OAAQtrB,KAAM,WAAYurB,OAAQ,KAC1C,CAAED,KAAM,SAAUtrB,KAAM,WAAYurB,OAAQ,KAC5C,CAAED,KAAM,QAAStrB,KAAM,WAAYurB,OAAQ,MAC3C,CAAED,KAAM,UAAWtrB,KAAM,WAAYurB,OAAQ,MAC7C,CAAED,KAAM,UAAWtrB,KAAM,WAAYurB,OAAQ,KAC7C,CAAED,KAAM,OAAQtrB,KAAM,WAAYurB,OAAQ,IAAKrQ,QAAS,UACxD,CAAEoQ,KAAM,QAAStrB,KAAM,WAAYurB,OAAQ,IAAKrQ,QAAS,UACzD,CAAEoQ,KAAM,YAAatrB,KAAM,WAAYurB,OAAQ,KAC/C,CAAED,KAAM,SAAUtrB,KAAM,WAAYurB,OAAQ,IAAKrQ,QAAS,UAC1D,CAAEoQ,KAAM,YAAatrB,KAAM,WAAYurB,OAAQ,KAC/C,CAAED,KAAM,SAAUtrB,KAAM,WAAYurB,OAAQ,IAAKrQ,QAAS,UAC1D,CAAEoQ,KAAM,QAAStrB,KAAM,WAAYurB,OAAQ,KAC3C,CAAED,KAAM,QAAStrB,KAAM,WAAYurB,OAAQ,KAC3C,CAAED,KAAM,QAAStrB,KAAM,WAAYurB,OAAQ,SAC3C,CAAED,KAAM,QAAStrB,KAAM,WAAYurB,OAAQ,SAC3C,CAAED,KAAM,QAAStrB,KAAM,WAAYurB,OAAQ,QAASrQ,QAAS,UAC7D,CAAEoQ,KAAM,QAAStrB,KAAM,WAAYurB,OAAQ,QAASrQ,QAAS,UAC7D,CAAEoQ,KAAM,UAAWtrB,KAAM,WAAYurB,OAAQ,SAC7C,CAAED,KAAM,UAAWtrB,KAAM,WAAYurB,OAAQ,QAASrQ,QAAS,UAC/D,CAAEoQ,KAAM,IAAKtrB,KAAM,WAAYurB,OAAQ,KAAMrQ,QAAS,UACtD,CAAEoQ,KAAM,IAAKtrB,KAAM,WAAYurB,OAAQ,IAAKrQ,QAAS,UACrD,CAAEoQ,KAAM,IAAKtrB,KAAM,WAAYurB,OAAQ,KAAMrQ,QAAS,UACtD,CAAEoQ,KAAM,IAAKtrB,KAAM,WAAYurB,OAAQ,MAAOrQ,QAAS,UACvD,CAAEoQ,KAAM,SAAUtrB,KAAM,WAAYurB,OAAQ,KAC5C,CAAED,KAAM,QAAStrB,KAAM,WAAYurB,OAAQ,KAC3C,CAAED,KAAM,WAAYtrB,KAAM,WAAYurB,OAAQ,SAC9C,CAAED,KAAM,aAActrB,KAAM,WAAYurB,OAAQ,SAChD,CAAED,KAAM,OAAQtrB,KAAM,WAAYurB,OAAQ,KAAMrQ,QAAS,UACzD,CAAEoQ,KAAM,QAAStrB,KAAM,WAAYurB,OAAQ,IAAKrQ,QAAS,UACzD,CAAEoQ,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,kBAAmBtQ,QAAS,UAErE,CAAEoQ,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,gBAAiBi0B,WAAY,CAAEC,UAAU,EAAMC,YAAY,IAChG,CAAEL,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,mBAAoBi0B,WAAY,CAAEC,UAAU,EAAMC,YAAY,IACnG,CAAEL,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,mBAAoBi0B,WAAY,CAAEC,UAAU,EAAMC,YAAY,IACnG,CAAEL,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,mBAAoBi0B,WAAY,CAAE51B,SAAS,IAChF,CAAEy1B,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,mBAAoBi0B,WAAY,CAAE51B,SAAS,IAChF,CAAEy1B,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAM61B,UAAU,IAC3F,CAAEJ,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAO61B,UAAU,IAC5F,CAAEJ,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,qBAAsBi0B,WAAY,CAAE51B,SAAS,IACnF,CAAEy1B,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,qBAAsBi0B,WAAY,CAAE51B,SAAS,IACnF,CAAEy1B,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAM+1B,SAAS,IAC1F,CAAEN,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAM+1B,SAAS,EAAOC,SAAS,IAC1G,CAAEP,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAM+1B,SAAS,EAAME,WAAW,IAC3G,CAAER,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAM+1B,SAAS,EAAMC,SAAS,EAAMC,WAAW,IAC1H,CAAER,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAO+1B,SAAS,IAC3F,CAAEN,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAO+1B,SAAS,EAAOC,SAAS,IAC3G,CAAEP,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAO+1B,SAAS,EAAME,WAAW,IAC7G,CAAER,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAO+1B,SAAS,EAAMC,SAAS,EAAMC,WAAW,IAC5H,CAAER,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,kBAAmBi0B,WAAY,CAAE51B,SAAS,EAAO81B,YAAY,IAClG,CAAEL,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,kBAAmBi0B,WAAY,CAAE51B,SAAS,EAAM81B,YAAY,IACjG,CAAEL,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,iBAAkBi0B,WAAY,CAAE51B,SAAS,IAC9E,CAAEy1B,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,iBAAkBi0B,WAAY,CAAE51B,SAAS,IAC9E,CAAEy1B,KAAM,QAAStrB,KAAM,SAAUxI,OAAQ,aAAci0B,WAAY,CAAE51B,SAAS,IAC9E,CAAEy1B,KAAM,QAAStrB,KAAM,SAAUxI,OAAQ,aAAci0B,WAAY,CAAE51B,SAAS,IAC9E,CAAEy1B,KAAM,QAAStrB,KAAM,SAAUxI,OAAQ,eAAgBi0B,WAAY,CAAE51B,SAAS,EAAMk2B,gBAAgB,IACtG,CAAET,KAAM,QAAStrB,KAAM,SAAUxI,OAAQ,eAAgBi0B,WAAY,CAAE51B,SAAS,EAAOk2B,gBAAgB,IACvG,CAAET,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,6BAA8Bi0B,WAAY,CAAE51B,SAAS,EAAOk2B,gBAAgB,EAAML,UAAU,EAAMC,YAAY,IACpJ,CAAEL,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,6BAA8Bi0B,WAAY,CAAE51B,SAAS,EAAMk2B,gBAAgB,EAAML,UAAU,EAAMC,YAAY,IAClJ,CAACL,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,0BACrC,CAAC8zB,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,4BACrC,CAAC8zB,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,4BACrC,CAAE8zB,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,qBACrC,CAAE8zB,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,qCACrC,CAAE8zB,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAMm2B,aAAY,IAC7F,CAAEV,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAOm2B,aAAY,IAC9F,CAAEV,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAMm2B,aAAY,EAAMC,cAAc,IACjH,CAAEX,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,YAAai0B,WAAY,CAAEK,WAAW,IAC3E,CAAER,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,sBAAuBi0B,WAAY,CAAEK,WAAW,EAAMH,YAAY,IACvG,CAAEL,KAAM,eAAgBtrB,KAAM,SAAUxI,OAAQ,kBAAmBi0B,WAAY,CAAE51B,SAAS,EAAOi2B,WAAW,IAC5G,CAAER,KAAM,eAAgBtrB,KAAM,SAAUxI,OAAQ,kBAAmBi0B,WAAY,CAAE51B,SAAS,IAC1F,CAAEy1B,KAAM,eAAgBtrB,KAAM,SAAUxI,OAAQ,oBAAqBi0B,WAAY,CAAE51B,SAAS,EAAMi2B,WAAW,IAC7G,CAAER,KAAM,eAAgBtrB,KAAM,SAAUxI,OAAQ,oBAAqBi0B,WAAY,CAAE51B,SAAS,IAC5F,CAAEy1B,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,4BAA6Bi0B,WAAY,CAAE51B,SAAS,IACzF,CAAEy1B,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,4BAA6Bi0B,WAAY,CAAE51B,SAAS,IACzF,CAAEy1B,KAAM,eAAiBtrB,KAAM,SAAUxI,OAAQ,WAAYi0B,WAAY,CAACE,YAAY,EAAMD,UAAU,IACtG,CAAEJ,KAAM,eAAgBtrB,KAAM,SAAUxI,OAAQ,WAAYi0B,WAAY,CAACE,YAAY,IACrF,CAAEL,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,aAAci0B,WAAY,CAAE51B,SAAS,IAC3E,CAAEy1B,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,aAAci0B,WAAY,CAAE51B,SAAS,IAC3E,CAAEy1B,KAAM,KAAOtrB,KAAM,SAAUxI,OAAQ,aAAci0B,WAAY,CAAE51B,SAAS,EAAM61B,UAAU,IAC5F,CAAEJ,KAAM,KAAOtrB,KAAM,SAAUxI,OAAQ,aAAci0B,WAAY,CAAE51B,SAAS,EAAO61B,UAAU,IAE7F,CAAEJ,KAAM,KAAMtrB,KAAM,SAAUwrB,OAAQ,QAASU,QAAQ,EAAMC,WAAY,CAAEl2B,OAAO,EAAMi2B,QAAQ,EAAME,aAAa,IACnH,CAAEd,KAAM,KAAMtrB,KAAM,SAAUwrB,OAAQ,QAASU,QAAQ,EAAMC,WAAY,CAAEl2B,OAAO,EAAOi2B,QAAQ,EAAME,aAAa,IACpH,CAAEd,KAAM,eAAgBtrB,KAAM,SAAUxI,OAAQ,eAAgBi0B,WAAY,CAAE51B,SAAS,EAAM81B,YAAY,IACzG,CAAEL,KAAM,eAAgBtrB,KAAM,SAAUxI,OAAQ,eAAgBi0B,WAAY,CAAE51B,SAAS,EAAO81B,YAAY,IAC1G,CAAEL,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,gBACrC,CAAE8zB,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,4BAA6B0jB,QAAQ,UAC1E,CAAEoQ,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,4BAA6Bi0B,WAAY,CAACY,UAAU,GAAOnR,QAAQ,UAExG,CAAEoQ,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,UACzC,CAAEgT,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,QACzC,CAAEgT,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,UACzC,CAAEgT,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,cACzC,CAAEgT,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,SAAUgU,aAAc,CAAEC,aAAa,IAChF,CAAEjB,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,SAAUgU,aAAc,CAAEC,aAAa,IAChF,CAAEjB,KAAM,KAAMtrB,KAAM,WAAYsY,SAAU,cAC1C,CAAEgT,KAAM,KAAMtrB,KAAM,WAAYsY,SAAU,aAAcgU,aAAc,CAACE,SAAS,GAAON,QAAQ,GAC/F,CAAEZ,KAAM,KAAMtrB,KAAM,WAAYsY,SAAU,aAAcgU,aAAc,CAACE,SAAS,GAAQN,QAAQ,GAChG,CAAEZ,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,WAAYi0B,WAAY,CAAE51B,SAAS,EAAM81B,YAAY,IAC1F,CAAEL,KAAM,IAAKtrB,KAAM,SAAUxI,OAAQ,WAAYi0B,WAAY,CAAE51B,SAAS,EAAO81B,YAAY,IAC3F,CAAEL,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,6BAA8Bi0B,WAAY,CAAE51B,SAAS,IAC3F,CAAEy1B,KAAM,KAAMtrB,KAAM,SAAUxI,OAAQ,6BAA8Bi0B,WAAY,CAAE51B,SAAS,IAE3F,CAAEy1B,KAAM,IAAKtrB,KAAM,iBAAkBsY,SAAU,SAAU9gB,OAAQ,mBAAoBi0B,WAAY,CAAE51B,SAAS,GAAQ42B,mBAAoB,CAAEC,YAAY,IACtJ,CAAEpB,KAAM,IAAKtrB,KAAM,iBAAkBsY,SAAU,SAAU9gB,OAAQ,mBAAoBi0B,WAAY,CAAE51B,SAAS,GAAS42B,mBAAoB,CAAEC,YAAY,IACvJ,CAAEpB,KAAM,IAAKtrB,KAAM,iBAAkBsY,SAAU,SAAU9gB,OAAQ,YAAai0B,WAAY,CAAEK,WAAW,GAAQ5Q,QAAS,UACxH,CAAEoQ,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,SAAUgU,aAAc,CAAEZ,UAAU,GAAQxQ,QAAS,UAC9F,CAAEoQ,KAAM,IAAKtrB,KAAM,iBAAkBsY,SAAU,OAAQ9gB,OAAQ,eAAgBi0B,WAAY,CAAEC,UAAU,GAAQxQ,QAAS,UACxH,CAAEoQ,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,OAAQgU,aAAc,CAAEZ,UAAU,GAAQxQ,QAAS,UAC5F,CAAEoQ,KAAM,IAAKtrB,KAAM,iBAAkBsY,SAAU,SAAU9gB,OAAQ,YAAai0B,WAAY,CAAEK,WAAW,GAAQ5Q,QAAS,UACxH,CAAEoQ,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,SAAUgU,aAAc,CAAEZ,UAAU,GAAQxQ,QAAS,UAC9F,CAAEoQ,KAAM,IAAKtrB,KAAM,iBAAkBsY,SAAU,aAAc9gB,OAAQ,mBAAoBi0B,WAAY,CAAE51B,SAAS,GAAQy2B,aAAc,CAAEK,kBAAkB,GAAQzR,QAAS,UAC3K,CAAEoQ,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,aAAc4C,QAAS,UAChE,CAAEoQ,KAAM,QAAStrB,KAAM,iBAAkBsY,SAAU,SAAU9gB,OAAQ,oBAAqB0jB,QAAS,UACnG,CAAEoQ,KAAM,QAAStrB,KAAM,iBAAkBsY,SAAU,SAAU9gB,OAAQ,cAAei0B,WAAY,CAAE51B,SAAS,EAAO+1B,SAAS,GAAS1Q,QAAS,UAE7I,CAAEoQ,KAAM,QAAStrB,KAAM,OAAQkb,QAAS,UAExC,CAAEoQ,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,eAAgBW,WAAY,CAAEt2B,SAAS,IAChF,CAAEy1B,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,eAAgBW,WAAY,CAAEt2B,SAAS,IAChF,CAAEy1B,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,SAAUW,WAAY,CAAEt2B,SAAS,EAAM61B,UAAU,IAC1F,CAAEJ,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,SAAUW,WAAY,CAAEt2B,SAAS,EAAO61B,UAAU,IAC3F,CAAEJ,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,kBAAmBU,QAAQ,EAAMC,WAAY,CAAES,SAAU,aAAe1R,QAAS,UACtH,CAAEoQ,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,kBAAmBU,QAAQ,EAAMC,WAAY,CAAES,SAAU,OAAS1R,QAAS,UAChH,CAAEoQ,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,kBAAmBU,QAAQ,EAAMC,WAAY,CAAES,SAAU,qBAAuB1R,QAAS,UAC9H,CAAEoQ,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,kBAAmBU,QAAQ,EAAMC,WAAY,CAAES,SAAU,WAAa1R,QAAS,UACpH,CAAEoQ,KAAM,KAAMtrB,KAAM,SAAUwrB,OAAQ,kBAAmBU,QAAQ,EAAMC,WAAY,CAAES,SAAU,YAAc1R,QAAS,UACtH,CAAEoQ,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,kBAAmBU,QAAQ,EAAMC,WAAY,CAAES,SAAU,iBAAkB1R,QAAS,UACzH,CAAEoQ,KAAM,KAAMtrB,KAAM,SAAUwrB,OAAQ,kBAAmBU,QAAQ,EAAMC,WAAY,CAAES,SAAU,OAAQ1R,QAAS,UAChH,CAAEoQ,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,kBAAmBU,QAAQ,EAAMC,WAAY,CAAES,SAAU,uBAAyB1R,QAAS,UAChI,CAAEoQ,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,4BAA6BU,QAAQ,EAAMW,uBAAuB,EAAMV,WAAY,CAAEl2B,OAAO,GAAQilB,QAAS,UACnJ,CAAEoQ,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,4BAA6BU,QAAQ,EAAMW,uBAAuB,EAAMV,WAAY,CAAEl2B,OAAO,GAASilB,QAAS,UACpJ,CAAEoQ,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,oBACrC,CAAEF,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,mBAAoBW,WAAY,CAAET,UAAU,IACjF,CAAEJ,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,mBAAoBW,WAAY,CAAEW,WAAW,IACtF,CAAExB,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,mBAAoBW,WAAY,CAAEW,WAAW,IACtF,CAAExB,KAAM,KAAMtrB,KAAM,SAAUwrB,OAAQ,yBACtC,CAAEF,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,YAAaU,QAAQ,GAC1D,CAAEZ,KAAM,KAAMtrB,KAAM,SAAUwrB,OAAQ,YAAaW,WAAY,CAAEY,YAAY,GAAQb,QAAQ,GAC7F,CAAEZ,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,QAASU,QAAQ,EAAMC,WAAY,CAAEl2B,OAAO,EAAMi2B,QAAQ,IAC/F,CAAEZ,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,QAASU,QAAQ,EAAMC,WAAY,CAAEl2B,OAAO,EAAOi2B,QAAQ,IAChG,CAAEZ,KAAM,eAAgBtrB,KAAM,SAAUwrB,OAAQ,UAAWU,QAAQ,GACnE,CAAEZ,KAAM,eAAgBtrB,KAAM,SAAUwrB,OAAQ,eAChD,CAAEF,KAAM,eAAgBtrB,KAAM,SAAUwrB,OAAQ,wBAEhD,CAAEF,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,kBAAmBU,QAAQ,EAAMC,WAAY,CAAExW,SAAS,GAAQuF,QAAS,UAC9G,CAAEoQ,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,SAAUgU,aAAc,CAAEZ,UAAU,EAAMsB,UAAU,GAAQ9R,QAAS,SAAU+R,iBAAiB,GACzI,CAAE3B,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,OAAQtQ,QAAS,UACtD,CAAEoQ,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,aAAcgU,aAAc,CAACE,SAAS,GAAOtR,QAAS,SAAUgR,QAAQ,GACjH,CAAEZ,KAAM,IAAKtrB,KAAM,WAAYsY,SAAU,aAAcgU,aAAc,CAACE,SAAS,GAAQtR,QAAS,SAAUgR,QAAQ,GAClH,CAAEZ,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,QACzC,CAAEF,KAAM,eAAgBtrB,KAAM,SAAUwrB,OAAQ,WAChD,CAAEF,KAAM,eAAgBtrB,KAAM,SAAUwrB,OAAQ,eAChD,CAAEF,KAAM,KAAMtrB,KAAM,SAAUwrB,OAAQ,iBAAkBW,WAAY,CAAEvb,SAAU,WAChF,CAAE0a,KAAM,KAAMtrB,KAAM,SAAUwrB,OAAQ,iBAAkBW,WAAY,CAAEvb,SAAU,UAAYpZ,OAAQ,qCACpG,CAAE8zB,KAAM,KAAMtrB,KAAM,SAAUwrB,OAAQ,iBAAkBW,WAAY,CAAEvb,SAAU,QAChF,CAAE0a,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,iBAAkBW,WAAY,CAAEvb,SAAU,OAASpZ,OAAQ,qCACpG,CAAE8zB,KAAM,KAAMtrB,KAAM,SAAUwrB,OAAQ,iBAAkBW,WAAY,CAAEvb,SAAU,WAChF,CAAE0a,KAAM,KAAMtrB,KAAM,SAAUwrB,OAAQ,iBAAkBW,WAAY,CAAEvb,SAAU,UAAYpZ,OAAQ,qCACpG,CAAE8zB,KAAM,IAAKtrB,KAAM,SAAUwrB,OAAQ,kBACrC,CAAEF,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,uBAAwBU,QAAQ,EAAMC,WAAY,CAACe,UAAU,EAAMC,WAAW,IACvH,CAAE7B,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,uBAAwBU,QAAQ,EAAMC,WAAY,CAACe,UAAU,EAAOC,WAAW,IACxH,CAAE7B,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,SAAUW,WAAY,CAAEI,aAAa,GAAQrR,QAAS,UAC/F,CAAEoQ,KAAM,QAAStrB,KAAM,SAAUwrB,OAAQ,SAAUW,WAAY,CAAEI,aAAa,GAASrR,QAAS,UAEhG,CAAEoQ,KAAM,eAAgBtrB,KAAM,SAAUxI,OAAQ,0BAChD,CAAE8zB,KAAM,eAAgBtrB,KAAM,SAAUxI,OAAQ,yBAA0Bi0B,WAAY,CAAE2B,iBAAiB,IAEzG,CAAE9B,KAAM,IAAKtrB,KAAM,SAAUqtB,WAAY,CAAEx3B,SAAS,EAAMy3B,SAAU,SAAU3B,YAAY,IAC1F,CAAEL,KAAM,IAAKtrB,KAAM,SAAUqtB,WAAY,CAAEx3B,SAAS,EAAOy3B,SAAU,SAAU3B,YAAY,IAC3F,CAAEL,KAAM,IAAKtrB,KAAM,SAAUqtB,WAAY,CAAEx3B,SAAS,EAAMy3B,SAAU,kBAAmBC,eAAe,EAAM5B,YAAY,IACxH,CAAEL,KAAM,IAAKtrB,KAAM,SAAUqtB,WAAY,CAAEx3B,SAAS,EAAOy3B,SAAU,kBAAmBC,eAAe,EAAM5B,YAAY,IACzH,CAAEL,KAAM,KAAMtrB,KAAM,SAAUqtB,WAAY,CAAEx3B,SAAS,EAAMy3B,SAAU,kBAAmB3B,YAAY,IACpG,CAAEL,KAAM,KAAMtrB,KAAM,SAAUqtB,WAAY,CAAEx3B,SAAS,EAAOy3B,SAAU,kBAAmB3B,YAAY,IAErG,CAAEL,KAAM,IAAKtrB,KAAM,OAEjBwtB,EAAsBnC,EAAc74B,OAQpCi7B,EAAsB,CACxB,CAAEzS,KAAM,cAAe0S,UAAW,QAClC,CAAE1S,KAAM,OACR,CAAEA,KAAM,OAAQ0S,UAAW,MAC3B,CAAE1S,KAAM,OAAQ0S,UAAW,MAC3B,CAAE1S,KAAM,OAAQ0S,UAAW,MAC3B,CAAE1S,KAAM,SACR,CAAEA,KAAM,QAAS0S,UAAW,KAC5B,CAAE1S,KAAM,OAAQ0S,UAAW,KAC3B,CAAE1S,KAAM,OAAQ0S,UAAW,OAC3B,CAAE1S,KAAM,MAAO0S,UAAW,MAC1B,CAAE1S,KAAM,WAAY0S,UAAW,QAC/B,CAAE1S,KAAM,YAAa0S,UAAW,QAChC,CAAE1S,KAAM,OAAQ0S,UAAW,OAC3B,CAAE1S,KAAM,aAAc0S,UAAW,IAAKC,eAAe,GACrD,CAAE3S,KAAM,aAAc0S,UAAW,OACjC,CAAE1S,KAAM,OAAQ0S,UAAW,KAC3B,CAAE1S,KAAM,WAAY0S,UAAW,QAC/B,CAAE1S,KAAM,YAAa0S,UAAW,MAAOE,2BAA2B,GAClE,CAAE5S,KAAM,UAAW0S,UAAW,KAC9B,CAAE1S,KAAM,SAAU0S,UAAW,MAG7B,SAASG,EAAa16B,GACpBA,EAAG26B,UAAU,gBAAgB,GAC7B36B,EAAG26B,UAAU,2BAA2B,GACxCn8B,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,WAChD56B,EAAGiF,GAAG,iBAAkBgxB,IACxB4E,EAAkB76B,GAClBxB,EAAWyG,GAAGjF,EAAGoc,gBAAiB,QAAS0e,EAAa96B,GAC1D,CAEA,SAAS+6B,EAAa/6B,GACpBA,EAAG26B,UAAU,gBAAgB,GAC7B36B,EAAGwF,IAAI,iBAAkBywB,IACzBz3B,EAAWgH,IAAIxF,EAAGoc,gBAAiB,QAAS0e,EAAa96B,IACzDA,EAAGsD,MAAMy0B,IAAM,KACXiD,IAAkBzhB,aAAayhB,GACrC,CAEA,SAASC,EAAaj7B,EAAImC,GACpBwV,MAAQnZ,EAAWmN,OAAOosB,MAC5B/3B,EAAG0X,QAAQwjB,cAAgB,KAC3B18B,EAAW61B,QAAQr0B,EAAGkgB,oBAAqB,kBAGxC/d,GAAQA,EAAKg5B,QAAUC,GAC1BL,EAAa/6B,EACjB,CACA,SAASo7B,EAAap7B,EAAIgT,GACpB2E,MAAQnZ,EAAWmN,OAAOosB,MACxB/3B,EAAGq7B,QAAOr7B,EAAGq7B,MAAMC,kBAAmB,GAC1Ct7B,EAAG0X,QAAQwjB,cAAgBpD,EAC3Bt5B,EAAWu1B,SAAS/zB,EAAGkgB,oBAAqB,kBAGzClN,GAAQA,EAAKmoB,QAAUC,GAC1BV,EAAa16B,EACjB,CAUA,SAASu7B,EAAMngB,EAAKpb,GAClB,GAAKA,EAAL,CACA,GAAI2X,KAAKyD,GAAQ,OAAOzD,KAAKyD,GAC7B,IAAIogB,EAASC,EAAcrgB,GAC3B,IAAKogB,EACH,OAAO,EAET,IAAI73B,EAAM+3B,EAAOC,QAAQ37B,EAAIw7B,GAI7B,MAHkB,mBAAP73B,GACTnF,EAAWwa,OAAOhZ,EAAI,eAAgBw7B,GAEjC73B,CAVsB,CAW/B,CAnBAnF,EAAW2kB,aAAa,WAAW,EAAO,SAASnjB,EAAIqb,EAAKrI,GACtDqI,GAAiC,OAA1Brb,EAAGoL,UAAU,UACtBpL,EAAG26B,UAAU,SAAU,QACftf,GAAOrI,GAAQxU,EAAWo9B,MAAQ,OAAOn6B,KAAKzB,EAAGoL,UAAU,YACnEpL,EAAG26B,UAAU,SAAU,UAC3B,GAgBA,IAAIkB,EAAY,CAACC,MAAM,IAAIC,KAAK,IAAIC,IAAI,IAAIC,IAAI,IAAIC,IAAI,IAAIC,SAAS,IACjEC,EAAc,CAAC1hB,MAAM,KAAK2hB,UAAU,KAAKC,OAAO,MAAMC,OAAO,OACjE,SAASd,EAAcrgB,GACrB,GAAqB,KAAjBA,EAAIhZ,OAAO,GAEb,OAAOgZ,EAAIhZ,OAAO,GAEpB,IAAIo6B,EAASphB,EAAImW,MAAM,UACnBkL,EAAYD,EAAOA,EAAOn9B,OAAS,GACvC,GAAqB,GAAjBm9B,EAAOn9B,QAAmC,GAApBm9B,EAAO,GAAGn9B,OAElC,OAAO,EACF,GAAqB,GAAjBm9B,EAAOn9B,QAA4B,SAAbm9B,EAAO,IAAqC,GAApBC,EAAUp9B,OAEjE,OAAO,EAGT,IADA,IAAIq9B,GAAe,EACV34B,EAAI,EAAGA,EAAIy4B,EAAOn9B,OAAQ0E,IAAK,CACtC,IAAI44B,EAAQH,EAAOz4B,GACf44B,KAASd,EAAaW,EAAOz4B,GAAK83B,EAAUc,GACzCD,GAAe,EAClBC,KAASP,IAAeI,EAAOz4B,GAAKq4B,EAAYO,GACtD,CACA,QAAKD,IAMDE,EAAYH,KACdD,EAAOA,EAAOn9B,OAAS,GAAKo9B,EAAUhyB,eAEjC,IAAM+xB,EAAO32B,KAAK,KAAO,IAClC,CAEA,SAASi1B,EAAa96B,GACpB,IAAI+3B,EAAM/3B,EAAGsD,MAAMy0B,IASnB,OARKA,EAAI8E,YACP9E,EAAI8E,UAAY,WACT9E,EAAIC,aACPh4B,EAAGqG,UAAUy2B,GAAa98B,EAAGoE,YAAa,EAAG,IAC7C24B,GAAQC,gBAAgBh9B,EAAI,CAAC,EAAG+3B,GAEpC,GAEKA,EAAI8E,SACb,CAEA,IAAII,EAAc,OACdC,EAAe,CAAC1+B,EAAWyO,WAAY,SAASjO,GAClD,OAAOA,IAAOR,EAAWyO,WAAWjO,KAAQ,KAAKyC,KAAKzC,EACxD,GAAIm+B,EAAkB,CAAC,SAASn+B,GAC9B,MAAO,KAAKyC,KAAKzC,EACnB,GACA,SAASo+B,EAAar6B,EAAOs6B,GAE3B,IADA,IAAIlF,EAAO,GACFp0B,EAAIhB,EAAOgB,EAAIhB,EAAQs6B,EAAMt5B,IACpCo0B,EAAK/4B,KAAK2M,OAAOuxB,aAAav5B,IAEhC,OAAOo0B,CACT,CACA,IAKIoF,EALAC,EAAoBJ,EAAa,GAAI,IACrCK,EAAoBL,EAAa,GAAI,IACrCM,EAAUN,EAAa,GAAI,IAC3BO,EAAa,GAAGC,OAAOJ,EAAmBC,EAAmBC,EAAS,CAAC,IAAK,MAC5EG,EAAiB,GAAGD,OAAOJ,EAAmBC,EAAmBC,EAAS,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,MAExG,IAAMH,EAAiB,IAAI/sB,OAAO,cAAe,IAAM,CACvD,MAAO6b,IAAKkR,EAAiB,SAAW,CAExC,SAASO,EAAO99B,EAAIjB,GAClB,OAAOA,GAAQiB,EAAG4B,aAAe7C,GAAQiB,EAAG8B,UAC9C,CACA,SAASi8B,EAAY9oB,GACnB,MAAO,UAAYxT,KAAKwT,EAC1B,CACA,SAAS+oB,EAAkB/oB,GACzB,OAA+B,GAAxB,SAASxD,QAAQwD,EAC1B,CACA,SAASgpB,EAAShpB,GAChB,OAAOgoB,EAAYx7B,KAAKwT,EAC1B,CACA,SAAS2nB,EAAY3nB,GACnB,OAAOsoB,EAAe97B,KAAKwT,EAC7B,CACA,SAASipB,EAAmBjpB,GAC1B,MAAO,QAAUxT,KAAKwT,EACxB,CACA,SAASkpB,EAAsBlpB,GAC7B,OAA4B,GAArB,MAAMxD,QAAQwD,EACvB,CACA,SAASmpB,EAAQ/iB,EAAKgjB,GACpB,IAAK,IAAIt6B,EAAI,EAAGA,EAAIs6B,EAAIh/B,OAAQ0E,IAC9B,GAAIs6B,EAAIt6B,IAAMsX,EACZ,OAAO,EAGX,OAAO,CACT,CAEA,IAAI3D,EAAU,CAAC,EACf,SAASyL,EAAa0E,EAAMyW,EAAczxB,EAAM0xB,EAASrd,GACvD,QAAqBvP,IAAjB2sB,IAA+Bpd,EACjC,MAAMsd,MAAM,wDAQd,GANK3xB,IAAQA,EAAO,UACpB6K,EAAQmQ,GAAQ,CACdhb,KAAMA,EACNyxB,aAAcA,EACdpd,SAAUA,GAERqd,EACF,IAAK,IAAIx6B,EAAI,EAAGA,EAAIw6B,EAAQl/B,OAAQ0E,IAClC2T,EAAQ6mB,EAAQx6B,IAAM2T,EAAQmQ,GAG9ByW,GACF3D,EAAU9S,EAAMyW,EAEpB,CAEA,SAAS3D,EAAU9S,EAAMkC,EAAO/pB,EAAIy+B,GAClC,IAAIC,EAAShnB,EAAQmQ,GACrB4W,EAAMA,GAAO,CAAC,EACd,IAAIE,EAAQF,EAAIE,MAChB,IAAKD,EACH,OAAO,IAAIF,MAAM,mBAAqB3W,GAExC,GAAmB,WAAf6W,EAAO7xB,KAAmB,CAC5B,GAAIkd,IAAmB,IAAVA,EACX,OAAO,IAAIyU,MAAM,qBAAuB3W,EAAO,IAAMkC,IAClC,IAAVA,IAETA,GAAQ,EAEZ,CACI2U,EAAOxd,UACK,UAAVyd,GACFD,EAAOxd,SAAS6I,OAAOpY,GAEX,WAAVgtB,GAAsB3+B,GACxB0+B,EAAOxd,SAAS6I,EAAO/pB,KAGX,UAAV2+B,IACFD,EAAO3U,MAAuB,WAAf2U,EAAO7xB,OAAsBkd,EAAQA,GAExC,WAAV4U,GAAsB3+B,IACxBA,EAAGsD,MAAMy0B,IAAIrgB,QAAQmQ,GAAQ,CAACkC,MAAOA,IAG3C,CAEA,SAAS3e,EAAUyc,EAAM7nB,EAAIy+B,GAC3B,IAAIC,EAAShnB,EAAQmQ,GACrB4W,EAAMA,GAAO,CAAC,EACd,IAAIE,EAAQF,EAAIE,MAChB,IAAKD,EACH,OAAO,IAAIF,MAAM,mBAAqB3W,GAExC,GAAI6W,EAAOxd,SAAU,CACnB,IAAI0d,EAAQ5+B,GAAM0+B,EAAOxd,cAASvP,EAAW3R,GAC7C,MAAc,WAAV2+B,QAAgChtB,IAAVitB,EACjBA,EAEK,UAAVD,EACKD,EAAOxd,gBAEhB,CACF,CACM0d,EAAmB,WAAVD,GAAwB3+B,GAAMA,EAAGsD,MAAMy0B,IAAIrgB,QAAQmQ,GAChE,OAAQ+W,GAAoB,UAAVD,GAAsBD,GAAU,CAAC,GAAG3U,KAE1D,CAEA5G,EAAa,gBAAYxR,EAAW,SAAU,CAAC,MAAO,SAASkW,EAAM7nB,GAEnE,QAAW2R,IAAP3R,EAAJ,CAIA,QAAa2R,IAATkW,EAAoB,CACtB,IAAI+S,EAAO56B,EAAGoL,UAAU,QACxB,MAAe,QAARwvB,EAAiB,GAAKA,CAC/B,CACMA,EAAe,IAAR/S,EAAa,OAASA,EACjC7nB,EAAG26B,UAAU,OAAQC,EAPvB,CASF,GAEA,IAoKIiE,EAyBAC,EA7LAC,EAAyB,WAC3B,IAAI1B,EAAO,IACP2B,GAAW,EACXt6B,EAAO,EACPu6B,EAAO,EACPC,EAAS,IAAIC,MAAM9B,GACvB,SAAS/+B,EAAI0B,EAAIo/B,EAAQC,GACvB,IAAI9qB,EAAUyqB,EAAU3B,EACpBiC,EAAUJ,EAAO3qB,GACrB,SAASgrB,EAAYh7B,GACnB,IAAIpC,IAAS68B,EAAU3B,EACnBmC,EAAYN,EAAO/8B,GACnBq9B,GACFA,EAAUxqB,QAEZkqB,EAAO/8B,GAAQnC,EAAGqW,YAAY9R,EAChC,CACA,GAAI+6B,EAAS,CACX,IAAIG,EAAUH,EAAQ9qB,OAElBirB,IAAYC,GAAYD,EAASL,IACnCG,EAAYH,EAEhB,MACEG,EAAYH,GAEdG,EAAYF,GACZ36B,EAAOs6B,EACPC,EAAOD,EAAU3B,EAAO,EACpB4B,EAAO,IACTA,EAAO,EAEX,CACA,SAAS/6B,EAAKlE,EAAI2T,GAChBqrB,GAAWrrB,EACPqrB,EAAUt6B,EACZs6B,EAAUt6B,EACDs6B,EAAUC,IACnBD,EAAUC,GAEZ,IAAIxL,EAAOyL,GAAQ7B,EAAO2B,GAAW3B,GAErC,GAAI5J,IAASA,EAAKjf,OAAQ,CACxB,IACI6qB,EADAM,EAAMhsB,EAAS,EAAI,GAAK,EAExByrB,EAASp/B,EAAGoE,YAChB,GAIE,GAHA46B,GAAWW,EACXlM,EAAOyL,GAAQ7B,EAAO2B,GAAW3B,GAE7B5J,IACC4L,EAAS5L,EAAKjf,UACdkrB,GAAYN,EAAQC,GACvB,YAEKL,EAAUt6B,GAAQs6B,EAAUC,EACvC,CACA,OAAOxL,CACT,CACA,SAASjf,EAAKxU,EAAI2T,GAChB,IAAIisB,EAAaZ,EACbvL,EAAOvvB,EAAKlE,EAAI2T,GAEpB,OADAqrB,EAAUY,EACHnM,GAAQA,EAAKjf,MACtB,CACA,MAAO,CACLqrB,kBAAcluB,EACdrT,IAAKA,EACLkW,KAAMA,EACNtQ,KAAMA,EAEV,EAKI47B,EAA0B,SAAS5Q,GACrC,OAAIA,EAEK,CACL6Q,QAAS7Q,EAAE6Q,QACXC,8BAA+B9Q,EAAE8Q,+BAG9B,CAELD,QAAS,GAETC,+BAA+B,EAEnC,EAEA,SAASC,IACPtoB,KAAKuoB,oBAAiBvuB,EACtBgG,KAAKwoB,WAAY,EACjBxoB,KAAKyoB,aAAc,EACnBzoB,KAAK0oB,oBAAsB,GAC3B1oB,KAAK2oB,qBAAkB3uB,EACvBgG,KAAK4oB,sBAAwBT,GAC/B,CAyBA,SAASjF,EAAkB76B,GAsCzB,OArCKA,EAAGsD,MAAMy0B,MAEZ/3B,EAAGsD,MAAMy0B,IAAM,CACbyI,WAAY,IAAIC,EAGhBC,wBAAoB/uB,EAGpBgvB,2BAAuBhvB,EAMvBivB,UAAW,EAEXC,WAAY,EAGZC,WAAY,KACZzsB,MAAO,CAAC,EACR2jB,YAAY,EAGZ+I,sBAAkBpvB,EAClBqvB,YAAY,EAEZzH,YAAY,EACZtB,aAAa,EACbgJ,cAAe,KACfC,eAAgB,KAChBhgC,IAAK,CAAC,EAENwW,QAAS,CAAC,IAGP1X,EAAGsD,MAAMy0B,GAClB,CAEA,SAASoJ,IAkBP,IAAK,IAAIC,KAjBTvC,EAAiB,CAEfwC,YAAa,KAEbC,kBAAkB,EAElBC,+BAA2B5vB,EAC3B6vB,SAAUzC,IACV0C,eAAgB,IAAIxB,EAEpByB,oBAAqB,CAACC,UAAU,EAAGj/B,SAAQ,EAAMk/B,kBAAkB,IACnEC,mBAAoB,IAAIC,EAAmB,CAAC,GAE5CC,wBAAyB,IAAIC,EAE7BC,2BAA6B,IAAID,GAEZtqB,EAAS,CAC9B,IAAIgnB,EAAShnB,EAAQ0pB,GACrB1C,EAAO3U,MAAQ2U,EAAOJ,YACxB,CACF,CAvFA2B,EAAepe,UAAY,CACzBqgB,oBAAqB,WACnB,IAAIT,EAAiB5C,EAAe4C,eAChCA,EAAenB,iBACjBmB,EAAenB,kBAEjBmB,EAAenB,qBAAkB3uB,EACjC8vB,EAAerB,aAAc,CAC/B,EACA+B,qBAAsB,SAASniC,EAAIoiC,GACjC,IAAIxZ,EACAiW,EAAegD,mBAAmBQ,YAAYD,GAClD,GAAIxZ,EAAU,CAGZ,GAFAA,EAAS5T,QACT2C,KAAKuoB,eAAiBkC,EAClBpiC,EAAGmH,WAAY,CACjB,IAAIysB,EAAW0O,GAAI,OAAQ,CAACC,MAAO,kBAAmB,cAAgBH,GACtEzqB,KAAK2oB,gBAAkBtgC,EAAGmH,WAAWysB,EAAU,KAAM,CAACxsB,QAAO,GAC/D,CACAuQ,KAAKyoB,aAAc,CACrB,CACF,GAqEF,IAAI1E,EAAS,CACXhB,aAAcA,EACd5gB,YAAa,WAEb,EAGA0oB,sBAAuB,WACrB,OAAO3D,EAAegD,kBACxB,EAEAY,qBAAsBtB,EAGtBuB,mBAAoB,WAClB,OAAO7D,CACT,EAGA8D,mBAAoB9H,EAEpB+H,sBAAsB,EAEtBC,cAAeA,GACf/L,IAAK,SAASgM,EAAKC,EAAKC,GAEtBC,GAAoBnM,IAAIgM,EAAKC,EAAKC,EACpC,EACAE,MAAO,SAASJ,EAAKE,GACnB,OAAOC,GAAoBC,MAAMJ,EAAKE,EACxC,EAIAG,QAAS,SAASL,EAAKC,EAAKC,GAC1B,SAASI,EAAWJ,GAClB,OAAOA,EAAM,CAACA,GAAO,CAAC,SAAU,SAAU,SAC5C,CAIA,IAHA,IAAIK,EAAYD,EAAWJ,GAEvBM,EAAepL,EAAc74B,OAAQkkC,EAAalJ,EAC7Ct2B,EAAIu/B,EAAeC,EACvBx/B,EAAIu/B,GAAgBD,EAAUhkC,OAC9B0E,IAAK,CACR,IAAIy/B,EAAUtL,EAAcn0B,GAE5B,GAAIy/B,EAAQrL,MAAQ4K,KACdC,IAAQQ,EAAQzb,SAAWyb,EAAQzb,UAAYib,IACnB,OAA9BQ,EAAQ32B,KAAKmW,OAAO,EAAG,IACO,QAA9BwgB,EAAQ32B,KAAKmW,OAAO,EAAG,GAAc,CAEvC,IAAIygB,EAAa,CAAC,EAClB,IAAK,IAAIroB,KAAOooB,EACdC,EAAWroB,GAAOooB,EAAQpoB,GAG5BqoB,EAAWtL,KAAO2K,EACdE,IAAQS,EAAW1b,UACrB0b,EAAW1b,QAAUib,GAGvBrrB,KAAK+rB,YAAYD,GAEjB,IAAIE,EAAaP,EAAWI,EAAQzb,SACpCsb,EAAYA,EAAUpyB,OAAO,SAAS0K,GAAM,OAAmC,IAA5BgoB,EAAWlyB,QAAQkK,EAAY,EACpF,CACF,CAEF,EAEAioB,SAAU,SAASZ,GAEjB,IAAIM,EAAepL,EAAc74B,OAC7BkkC,EAAalJ,EACbwJ,EAAa3L,EAAcx2B,MAAM,EAAG4hC,EAAeC,GAEvD,GADArL,EAAgBA,EAAcx2B,MAAM4hC,EAAeC,GAC/CP,EAGF,IAAK,IAAIj/B,EAAI8/B,EAAWxkC,OAAS,EAAG0E,GAAK,EAAGA,IAAK,CAC/C,IAAIy/B,EAAUK,EAAW9/B,GACzB,GAAIi/B,IAAQQ,EAAQzb,QAClB,GAAIyb,EAAQzb,QACVpQ,KAAK+rB,YAAYF,OACZ,CAGL,IAAIM,EAAW,CAAC,SAAU,SAAU,UACpC,IAAK,IAAIhvB,KAAKgvB,EACZ,GAAIA,EAAShvB,KAAOkuB,EAAK,CACvB,IAAIS,EAAa,CAAC,EAClB,IAAK,IAAIroB,KAAOooB,EACdC,EAAWroB,GAAOooB,EAAQpoB,GAE5BqoB,EAAW1b,QAAU+b,EAAShvB,GAC9B6C,KAAK+rB,YAAYD,EACnB,CAEJ,CAEJ,CAEJ,EAGA9I,UAAWA,EACXvvB,UAAWA,EACX+X,aAAcA,EACd4gB,SAAU,SAASlc,EAAM/jB,EAAQkgC,GAC/B,GAAKlgC,GAEE,GAA6B,IAAzB+jB,EAAKpW,QAAQ3N,GACtB,MAAM,IAAI06B,MAAM,mBAAmB16B,EAAO,yBAAyB+jB,EAAK,kCAFxE/jB,EAAS+jB,EAIXoc,GAAWpc,GAAMmc,EACjBf,GAAoBiB,YAAYpgC,GAAQ,CAAC+jB,KAAKA,EAAM0S,UAAUz2B,EAAQ+I,KAAK,MAC7E,EACAs3B,UAAW,SAAUnkC,EAAIob,EAAKzV,GAC5B,IAAIy+B,EAAUzsB,KAAKgkB,QAAQ37B,EAAIob,EAAKzV,GACpC,GAAuB,oBAAZy+B,EACT,OAAOA,GAEX,EACAC,qBAAsBA,GAYtB1I,QAAS,SAAS37B,EAAIob,EAAKzV,GACzB,IAwGIy+B,EAxGArM,EAAM8C,EAAkB76B,GAC5B,SAASskC,IACP,IAAI7C,EAAiB5C,EAAe4C,eACpC,GAAIA,EAAerB,YAAa,CAC9B,GAAW,KAAPhlB,EAGF,OAFAqmB,EAAeS,sBACfqC,EAAgBvkC,IACT,EAEK,WAAV2F,GACF6+B,GAAO/C,EAAgBrmB,EAE3B,CACF,CACA,SAASqpB,IACP,GAAW,SAAPrpB,EAAgB,CAClB,GAAI2c,EAAIiJ,WAEN0D,GAAe1kC,OACV,KAAI+3B,EAAIC,WAKb,OAHA2M,GAAe3kC,EAIjB,CAEA,OADAukC,EAAgBvkC,IACT,CACT,CACF,CACA,SAAS4kC,EAAWzM,GAElB,IAAI11B,EACJ,MAAO01B,EAGL11B,EAAQ,oBAAsBqR,KAAKqkB,GACnC/c,EAAM3Y,EAAM,GACZ01B,EAAOA,EAAK0M,UAAUpiC,EAAMwkB,MAAQ7L,EAAI/b,QACxCq8B,EAAOyI,UAAUnkC,EAAIob,EAAK,UAE9B,CAEA,SAAS0pB,IACP,GAAIL,IAAe,OAAO,EAC1B,IAAItM,EAAOJ,EAAIyI,WAAWuE,UAAYhN,EAAIyI,WAAWuE,UAAY3pB,EAC7D4pB,EAA6B,GAAd5pB,EAAI/b,OACnBoD,EAAQwiC,EAAkBC,aAAa/M,EAAMD,EAAeH,EAAIyI,WAAY,UAEhF,MAAOrI,EAAK94B,OAAS,GAAmB,QAAdoD,EAAMoK,KAAgB,CAC1CsrB,EAAOJ,EAAIyI,WAAWuE,UAAY5M,EAAKz2B,MAAM,GAAjD,IACIyjC,EAAYF,EAAkBC,aAAa/M,EAAMD,EAAeH,EAAIyI,WAAY,UAC9D,QAAlB2E,EAAUt4B,OAAkBpK,EAAQ0iC,EAC1C,CACA,GAAkB,QAAd1iC,EAAMoK,KAAuC,OAArB03B,EAAgBvkC,IAAY,EACnD,GAAkB,WAAdyC,EAAMoK,KAKb,OAJIiyB,GAA0B3lB,OAAOI,aAAaulB,GAClDA,EAAyB3lB,OAAOE,WAC9B,WAAiB0e,EAAIC,YAAcD,EAAIyI,WAAWuE,WAAaR,EAAgBvkC,EAAO,EACtFoL,EAAU,8BACJ45B,EAIV,GADIlG,GAA0B3lB,OAAOI,aAAaulB,GAC9CkG,EAAc,CAEhB,IADA,IAAIxgC,EAAaxE,EAAGyE,iBACXV,EAAI,EAAGA,EAAIS,EAAWnF,OAAQ0E,IAAK,CAC1C,IAAIqhC,EAAO5gC,EAAWT,GAAGW,KACzB1E,EAAGS,aAAa,GAAIq8B,GAAasI,EAAM,IAAKjN,EAAK94B,OAAS,IAAK+lC,EAAM,SACvE,CACAvG,EAAe4C,eAAelB,sBAAsBR,QAAQlgC,KAC9D,CAEA,OADA0kC,EAAgBvkC,GACTyC,EAAM2hC,OACf,CAEA,SAASiB,IACP,GAAIf,KAA0BG,IAAe,OAAO,EAEpD,IAAItM,EAAOJ,EAAIyI,WAAWuE,UAAYhN,EAAIyI,WAAWuE,UAAY3pB,EACjE,GAAI,aAAa3Z,KAAK02B,GAAS,OAAO,EAEtC,IAAImN,EAAc,cAAcxxB,KAAKqkB,GACrC,IAAKmN,EAAoC,OAArBf,EAAgBvkC,IAAY,EAChD,IAAI+nB,EAAUgQ,EAAIiJ,WAAa,SACA,SAC3BuE,EAAUD,EAAY,IAAMA,EAAY,GACxCvN,EAAIyI,WAAWgF,kBAAoBzN,EAAIyI,WAAWgF,iBAAiB9jC,OAAO,IAAM6jC,IAElFA,EAAUxN,EAAIyI,WAAWgF,kBAE3B,IAAI/iC,EAAQwiC,EAAkBC,aAAaK,EAASrN,EAAeH,EAAIyI,WAAYzY,GACnF,MAAkB,QAAdtlB,EAAMoK,MAAkB03B,EAAgBvkC,IAAY,GACjC,WAAdyC,EAAMoK,OACQ,SAAdpK,EAAMoK,MAAmB03B,EAAgBvkC,IAAY,IAE9D+3B,EAAIyI,WAAWuE,UAAY,GAC3BO,EAAc,cAAcxxB,KAAKqkB,GAC7BmN,EAAY,IAAwB,KAAlBA,EAAY,IAChCvN,EAAIyI,WAAWiF,gBAAgBH,EAAY,IAEtC7iC,EAAM2hC,SACf,CAKA,OAFsBA,EAAlBrM,EAAIC,WAAwB8M,IACfO,KACD,IAAZjB,EACMrM,EAAIC,YAA6B,IAAf5c,EAAI/b,YAA6CsS,EAA9B,WAAa,OAAO,CAAM,GAClD,IAAZyyB,EAIF,WAAa,OAAO,CAAM,EAE1B,WACL,OAAOpkC,EAAG4N,UAAU,WAClB5N,EAAGq7B,MAAMqK,SAAU,EACnB,IACsB,YAAhBtB,EAAQv3B,KACV+3B,EAAWR,EAAQhM,QAEnB6M,EAAkBU,eAAe3lC,EAAI+3B,EAAKqM,EAE9C,CAAE,MAAOr3B,GAOP,MALA/M,EAAGsD,MAAMy0B,SAAMpmB,EACfkpB,EAAkB76B,GACb07B,EAAOkH,sBACVvP,EAAQ,OAAOtmB,GAEXA,CACR,CACA,OAAO,CACT,EACF,CAEJ,EACA64B,SAAU,SAAS5lC,EAAI2G,GACrBs8B,GAAoB0C,eAAe3lC,EAAI2G,EACzC,EAEAk/B,aAAcA,GACdC,aAAcA,GACdC,eAAgBA,GAChBC,WAAYA,GACZtC,YAAaA,GAEbuC,eAAgBA,EAEhBvB,eAAgBA,GAChBC,eAAgBA,IAIlB,SAASlE,IACP9oB,KAAKuuB,aAAe,GACpBvuB,KAAKwuB,aAAe,GAEpBxuB,KAAKwN,SAAW,KAChBxN,KAAKwhB,aAAe,KACpBxhB,KAAKtT,OAAS,KACdsT,KAAK2gB,WAAa,KAClB3gB,KAAKotB,UAAY,GACjBptB,KAAKyqB,aAAe,IACtB,CAsBA,SAASmC,EAAgBvkC,EAAIomC,GAC3BpmC,EAAGsD,MAAMy0B,IAAIyI,WAAa,IAAIC,EAC9BjiC,EAAWwa,OAAOhZ,EAAI,mBAAoBomC,EAC5C,CAQA,SAASC,EAASjmC,EAAMm4B,EAAUoB,GAChChiB,KAAK3C,QACL2C,KAAKotB,UAAY,CAAC3kC,GAAQ,IAC1BuX,KAAK2uB,kBAAoB,GACzB3uB,KAAK4uB,cAAgB,GACrB5uB,KAAK4gB,WAAaA,EAClB5gB,KAAKgiB,YAAcA,CACrB,CAyCA,SAASsM,EAAepe,EAAMe,GAC5B,IAAI4d,EAAY3H,EAAegD,mBAAmB2E,UAClD,IAAK3e,GAAuB,GAAfA,EAAKxoB,OAChB,MAAMm/B,MAAM,qCAEd,GAAIgI,EAAU3e,GACZ,MAAM2W,MAAM,4BAA8B3W,GAE5C2e,EAAU3e,GAAQe,EAClBiV,EAAez+B,KAAKyoB,EACtB,CAUA,SAASia,EAAmB0E,GAC1B7uB,KAAK6uB,UAAYA,EACjB7uB,KAAK8uB,gBAAkBD,EAAU,KAAO,IAAIH,EAC5CG,EAAU,KAAO,IAAIH,EACrBG,EAAU,KAAO,IAAIH,EACrBG,EAAU,KAAO,IAAIH,CACvB,CAsEA,SAASrE,IACLrqB,KAAK+uB,cAAgB,GACrB/uB,KAAKgvB,SAAW,EAChBhvB,KAAKivB,cAAgB,IACzB,CApLAnG,EAAW5e,UAAU4jB,gBAAkB,SAAShmC,GACzCkY,KAAKwN,SAGRxN,KAAKwuB,aAAexuB,KAAKwuB,aAAavI,OAAOn+B,GAF7CkY,KAAKuuB,aAAevuB,KAAKuuB,aAAatI,OAAOn+B,EAIjD,EACAghC,EAAW5e,UAAUglB,UAAY,WAC/B,IAAIC,EAAS,EAUb,OATInvB,KAAKuuB,aAAa7mC,OAAS,GAAKsY,KAAKwuB,aAAa9mC,OAAS,KAC7DynC,EAAS,EACLnvB,KAAKuuB,aAAa7mC,OAAS,IAC7BynC,GAAUC,SAASpvB,KAAKuuB,aAAargC,KAAK,IAAK,KAE7C8R,KAAKwuB,aAAa9mC,OAAS,IAC7BynC,GAAUC,SAASpvB,KAAKwuB,aAAatgC,KAAK,IAAK,MAG5CihC,CACT,EAqBAT,EAASxkB,UAAY,CACnBmlB,QAAS,SAAS5mC,EAAMm4B,EAAUoB,GAChChiB,KAAKotB,UAAY,CAAC3kC,GAAQ,IAC1BuX,KAAK4gB,WAAaA,EAClB5gB,KAAKgiB,YAAcA,CACrB,EACAsN,SAAU,SAAS7mC,EAAMm4B,GAEnBA,IACG5gB,KAAK4gB,UACR5gB,KAAKotB,UAAU3lC,KAAK,MAEtBuY,KAAK4gB,UAAW,GAElB5gB,KAAKotB,UAAU3lC,KAAKgB,EACtB,EACA8mC,sBAAuB,SAASnH,GAC9BpoB,KAAK2uB,kBAAkBlnC,KAAK0gC,EAAwBC,GACtD,EACAoH,gBAAiB,SAAS52B,GACxBoH,KAAK4uB,cAAcnnC,KAAKmR,EAC1B,EACAyE,MAAO,WACL2C,KAAKotB,UAAY,GACjBptB,KAAK2uB,kBAAoB,GACzB3uB,KAAK4uB,cAAgB,GACrB5uB,KAAK4gB,UAAW,CAClB,EACA6O,SAAU,WACR,OAAOzvB,KAAKotB,UAAUl/B,KAAK,GAC7B,GAqCFi8B,EAAmBjgB,UAAY,CAC7BolB,SAAU,SAAS7E,EAAcjd,EAAU/kB,EAAMm4B,EAAUoB,GAEzD,GAAqB,MAAjByI,EAAJ,CACI7J,GAA6C,OAAjCn4B,EAAKgC,OAAOhC,EAAKf,OAAS,KACxCe,GAAQ,MAIV,IAAIwoB,EAAWjR,KAAK0vB,gBAAgBjF,GAChCzqB,KAAK0qB,YAAYD,GAAgB,KAGrC,GAAKxZ,EAAL,CAyBA,IAAI0e,EAAS1K,EAAYwF,GACrBkF,EACF1e,EAASqe,SAAS7mC,EAAMm4B,GAExB3P,EAASoe,QAAQ5mC,EAAMm4B,EAAUoB,GAInChiB,KAAK8uB,gBAAgBO,QAAQpe,EAASwe,WAAY7O,EAXlD,KAtBA,CACE,OAAQpT,GACN,IAAK,OAEHxN,KAAK6uB,UAAU,KAAO,IAAIH,EAASjmC,EAAMm4B,EAAUoB,GACnD,MACF,IAAK,SACL,IAAK,UACwB,GAAvBv5B,EAAKqR,QAAQ,MAEfkG,KAAK6uB,UAAU,KAAO,IAAIH,EAASjmC,EAAMm4B,IAIzC5gB,KAAK4vB,yBACL5vB,KAAK6uB,UAAU,KAAO,IAAIH,EAASjmC,EAAMm4B,IAE3C,MAGJ5gB,KAAK8uB,gBAAgBO,QAAQ5mC,EAAMm4B,EAAUoB,EAE/C,CAhCgC,CA4ClC,EAGA0I,YAAa,SAASxa,GACpB,OAAKlQ,KAAK0vB,gBAAgBxf,IAG1BA,EAAOA,EAAKpd,cACPkN,KAAK6uB,UAAU3e,KAClBlQ,KAAK6uB,UAAU3e,GAAQ,IAAIwe,GAEtB1uB,KAAK6uB,UAAU3e,IANblQ,KAAK8uB,eAOhB,EACAY,gBAAiB,SAASxf,GACxB,OAAOA,GAAQuW,EAAQvW,EAAMgW,EAC/B,EACA0J,uBAAwB,WACtB,IAAK,IAAIxjC,EAAI,EAAGA,GAAK,EAAGA,IACtB4T,KAAK6uB,UAAUziC,GAAK4T,KAAK0qB,YAAY,IAAMt+B,EAAI,GAEnD,GAOFi+B,EAAkBngB,UAAY,CAG5B2lB,UAAW,SAAU7gC,EAAO8gC,GAC1B,IAAIf,EAAgB/uB,KAAK+uB,cACrB9lC,EAAM6mC,GAAM,EAAI,EACO,OAAvB9vB,KAAKivB,gBAAwBjvB,KAAKivB,cAAgBjgC,GACtD,IAAK,IAAI5C,EAAI4T,KAAKgvB,SAAW/lC,EAAK6mC,EAAK1jC,GAAK,EAAIA,EAAI2iC,EAAcrnC,OAAQ0E,GAAInD,EAE5E,IADA,IAAI8mC,EAAUhB,EAAc3iC,GACnB+Q,EAAI,EAAGA,GAAK4yB,EAAQroC,OAAQyV,IACnC,GAAI6C,KAAKivB,eAAiBc,EAAQ7C,UAAU,EAAG/vB,GAE7C,OADA6C,KAAKgvB,SAAW5iC,EACT2jC,EAKb,OAAI3jC,GAAK2iC,EAAcrnC,QACrBsY,KAAKgvB,SAAWD,EAAcrnC,OACvBsY,KAAKivB,eAGV7iC,EAAI,EAAW4C,OAAnB,CACF,EACAghC,UAAW,SAAShhC,GAClB,IAAIsgB,EAAQtP,KAAK+uB,cAAcj1B,QAAQ9K,GACnCsgB,GAAS,GAAGtP,KAAK+uB,cAAcxxB,OAAO+R,EAAO,GAC7CtgB,EAAMtH,QAAQsY,KAAK+uB,cAActnC,KAAKuH,EAC5C,EACAwwB,MAAO,WACLxf,KAAKivB,cAAgB,KACrBjvB,KAAKgvB,SAAWhvB,KAAK+uB,cAAcrnC,MACrC,GAEF,IAAI4lC,EAAoB,CACtBC,aAAc,SAAS/M,EAAMxsB,EAAQ60B,EAAYzY,GAC/C,IAOI6f,EAPA5wB,EAAU6wB,GAAe1P,EAAMxsB,EAAQoc,EAASyY,GACpD,IAAKxpB,EAAQ8wB,OAAS9wB,EAAQ+wB,QAC5B,MAAO,CAACl7B,KAAM,QACT,IAAKmK,EAAQ8wB,MAAQ9wB,EAAQ+wB,QAClC,MAAO,CAACl7B,KAAM,WAIhB,IAAK,IAAI9I,EAAI,EAAGA,EAAIiT,EAAQ8wB,KAAKzoC,OAAQ0E,IAAK,CAC5C,IAAItB,EAAQuU,EAAQ8wB,KAAK/jC,GACpB6jC,IACHA,EAAYnlC,EAEhB,CACA,GAAiC,eAA7BmlC,EAAUzP,KAAKz2B,OAAO,IAAsB,CAC9C,IAAIsmC,EAAYC,GAAS9P,GACzB,IAAK6P,GAAaA,EAAU3oC,OAAS,EAAG,MAAO,CAACwN,KAAM,SACtD2zB,EAAWoB,kBAAoBoG,CACjC,CACA,MAAO,CAACn7B,KAAM,OAAQu3B,QAASwD,EACjC,EACAjC,eAAgB,SAAS3lC,EAAI+3B,EAAKqM,GAEhC,OADArM,EAAIyI,WAAW0H,eAAiB9D,EAAQ8D,eAChC9D,EAAQv3B,MACd,IAAK,SACH8K,KAAKwwB,cAAcnoC,EAAI+3B,EAAKqM,GAC5B,MACF,IAAK,WACHzsB,KAAKywB,gBAAgBpoC,EAAI+3B,EAAKqM,GAC9B,MACF,IAAK,iBACHzsB,KAAK0wB,sBAAsBroC,EAAI+3B,EAAKqM,GACpC,MACF,IAAK,SACHzsB,KAAK2wB,cAActoC,EAAI+3B,EAAKqM,GAC5B,MACF,IAAK,SACHzsB,KAAK4wB,cAAcvoC,EAAI+3B,EAAKqM,GAC5B,MACF,IAAK,KACL,IAAK,UACHzsB,KAAK6wB,UAAUxoC,EAAI+3B,EAAKqM,GACxB,MAEN,EACA+D,cAAe,SAASnoC,EAAI+3B,EAAKqM,GAC/BrM,EAAIyI,WAAWn8B,OAAS+/B,EAAQ//B,OAChC0zB,EAAIyI,WAAWlI,WAAamQ,GAASrE,EAAQ9L,YAC7C3gB,KAAK+wB,UAAU1oC,EAAI+3B,EACrB,EACAqQ,gBAAiB,SAASpoC,EAAI+3B,EAAKqM,GACjC,IAAI5D,EAAazI,EAAIyI,WACrB,GAAIA,EAAWrb,SAAU,CACvB,GAAIqb,EAAWrb,UAAYif,EAAQjf,SAMjC,OAHAqb,EAAWn8B,OAAS,eACpBm8B,EAAWlI,WAAa,CAAEC,UAAU,QACpC5gB,KAAK+wB,UAAU1oC,EAAI+3B,GAInBwM,EAAgBvkC,EAEpB,CACAwgC,EAAWrb,SAAWif,EAAQjf,SAC9Bqb,EAAWrH,aAAesP,GAASrE,EAAQjL,cACvCiL,EAAQjM,KAAK94B,OAAS,IACxBmhC,EAAWgF,iBAAmBpB,EAAQjM,MAEpCiM,EAAQtK,kBACR/B,EAAIE,aAAc,EAClB0Q,GAAkB3oC,IAElB+3B,EAAIiJ,YAENrpB,KAAK+wB,UAAU1oC,EAAI+3B,EAEvB,EACAsQ,sBAAuB,SAASroC,EAAI+3B,EAAKqM,GACvC,IAAIpD,EAAajJ,EAAIiJ,WACjB1H,EAAqBmP,GAASrE,EAAQ9K,oBACtCA,GAEE0H,GAAc1H,EAAmBC,aACnCxB,EAAIwB,YAAa,GAGrB5hB,KAAKywB,gBAAgBpoC,EAAI+3B,EAAKqM,GACzBpD,GACHrpB,KAAKwwB,cAAcnoC,EAAI+3B,EAAKqM,EAEhC,EACAkE,cAAe,SAAStoC,EAAI+3B,EAAKqM,GAC/B,IAAI5D,EAAazI,EAAIyI,WACjBsG,EAAStG,EAAWqG,YACpB+B,IAAqB9B,EACrB9N,EAAayP,GAASrE,EAAQpL,aAAe,CAAC,EAC9CwH,EAAWoB,oBACb5I,EAAW4I,kBAAoBpB,EAAWoB,mBAGxCwC,EAAQjf,UACVxN,KAAKywB,gBAAgBpoC,EAAI+3B,EAAKqM,GAE5BA,EAAQ//B,QACVsT,KAAKwwB,cAAcnoC,EAAI+3B,EAAKqM,IAE1BA,EAAQ//B,QAAU+/B,EAAQjf,WAC5BxN,KAAK+wB,UAAU1oC,EAAI+3B,GAErBiB,EAAW8N,OAASA,GAAU,EAC9B9N,EAAW4P,iBAAmBA,EAC9B5P,EAAWoJ,aAAe5B,EAAW4B,aACrCmC,EAAgBvkC,GAChB+3B,EAAI+I,WAAa,KACbsD,EAAQrL,QACVphB,KAAKkxB,eAAe9Q,EAAKyI,EAAY4D,GAEvCrH,GAAQqH,EAAQ/L,QAAQr4B,EAAIg5B,EAAYjB,EAC1C,EACAwQ,cAAe,SAASvoC,EAAI+3B,EAAKqM,GAC/B,GAAKpkC,EAAG0Q,gBAAR,CAIA,IAAIhO,EAAU0hC,EAAQlK,WAAWx3B,QAC7B03B,EAAgBgK,EAAQlK,WAAWE,cACvC0O,GAAe9oC,GAAI+oC,aAAarmC,GAChC,IAAIsmC,EAAe,EAAY,IAAM,IACjCC,EAAgBH,GAAe9oC,GAAIkpC,WACnCC,EAAoBnpC,EAAGmP,gBAwE3B,OAAQi1B,EAAQlK,WAAWC,UACzB,IAAK,SACH,IAAIsH,EAAiB5C,EAAe4C,eACpC,GAAIA,EAAetB,UAAW,CAC5B,IAAI5vB,EAAQkxB,EAAepB,oBAAoB/gC,QAC/C8pC,EAAY74B,GAAO,GAAwB,EAC7C,MACE84B,GAAWrpC,EAAI,CACXs0B,QAASgV,EACTxlC,OAAQklC,EACRO,KAAM,sBACN3U,QAAS4U,EACT3U,UAAW4U,IAGjB,MACF,IAAK,kBACH,IAAIr7B,EAAOs7B,GAAsB1pC,GAAI,GACjC,GAAqB,GACrB,GACA2pC,GAAY,EAOhB,GANKv7B,IACHA,EAAOs7B,GAAsB1pC,GAAI,GAC7B,GAAqB,GACrB,GACJ2pC,GAAY,IAETv7B,EACH,OAEEmC,EAAQvQ,EAAGuB,QAAQ6M,EAAKrL,MAAMhE,MAAM8lC,UAAUz2B,EAAKrL,MAAM/D,GACzDoP,EAAKpL,IAAIhE,IAETuR,EADAo5B,GAAavP,EACL,MAAQ7pB,EAAQ,MAElBq5B,GAAYr5B,GAMtBsuB,EAAe2C,SAAS3B,aAAe7/B,EAAGoE,YAC1CpE,EAAGqG,UAAU+H,EAAKrL,OAElBqmC,EAAY74B,GAAO,GAAwB,GAC3C,MA3HJ,CAOA,SAAS64B,EAAY74B,EAAOsgB,EAAYgZ,GACtChL,EAAekD,wBAAwB4F,UAAUp3B,GACjDsuB,EAAekD,wBAAwB5K,QACvC,IACE2S,GAAkB9pC,EAAIuQ,EAAOsgB,EAAYgZ,EAC3C,CAAE,MAAO98B,GAGP,OAFAg9B,GAAY/pC,EAAI,kBAAoBuQ,QACpCg0B,EAAgBvkC,EAElB,CACAilC,EAAkBkD,cAAcnoC,EAAI+3B,EAAK,CACvClrB,KAAM,SACNxI,OAAQ,WACRi0B,WAAY,CAAE51B,SAAS,EAAM81B,WAAY4L,EAAQlK,WAAW1B,aAEhE,CACA,SAAS8Q,EAAc/4B,GACrBvQ,EAAGwP,SAAS25B,EAAkBx6B,KAAMw6B,EAAkB75B,KACtD85B,EAAY74B,GAAO,GAAwB,GAC3C,IAAIkxB,EAAiB5C,EAAe4C,eAChCA,EAAerB,aACjB4J,GAAevI,EAAgBlxB,EAEnC,CACA,SAASi5B,EAAcz8B,EAAGwD,EAAOuI,GAC/B,IAAqC2uB,EAAI9zB,EAWrCs2B,EAXAC,EAAU1rC,EAAW0rC,QAAQn9B,GAClB,MAAXm9B,GAA8B,QAAXA,GACrBzC,EAAgB,MAAXyC,EACLv2B,EAAS5G,EAAE4F,OAAS5F,EAAE4F,OAAOw3B,aAAe,EAC5C55B,EAAQsuB,EAAekD,wBAAwByF,UAAUj3B,EAAOk3B,IAAO,GACvE3uB,EAAMvI,GACFoD,GAAU5G,EAAE4F,SAAQ5F,EAAE4F,OAAOw3B,aAAep9B,EAAE4F,OAAOy3B,eAAiB1qC,KAAKC,IAAIgU,EAAQ5G,EAAE4F,OAAOoX,MAAM1qB,UAE1F,QAAX6qC,GAAgC,SAAXA,GAAiC,QAAXA,GAAgC,OAAXA,GAA+B,SAAXA,GACvFrL,EAAekD,wBAAwB5K,QAG3C,IACE8S,EAAcH,GAAkB9pC,EAAIuQ,GAChC,GAAwB,EAC9B,CAAE,MAAOxD,GAET,CACIk9B,EACFjqC,EAAGoT,eAAexC,GAAS5Q,GAAK0C,EAASunC,GAAc,KAEvDI,GAAqBrqC,GACrBA,EAAGwP,SAAS25B,EAAkBx6B,KAAMw6B,EAAkB75B,KAE1D,CACA,SAASm6B,EAAgB18B,EAAGwD,EAAOuI,GACjC,IAAIoxB,EAAU1rC,EAAW0rC,QAAQn9B,GAClB,OAAXm9B,GAA+B,UAAXA,GAAkC,UAAXA,GAC/B,aAAXA,GAAmC,IAAT35B,GAC7BsuB,EAAekD,wBAAwB4F,UAAUp3B,GACjDsuB,EAAekD,wBAAwB5K,QACvC2S,GAAkB9pC,EAAIipC,GACtBoB,GAAqBrqC,GACrBA,EAAGwP,SAAS25B,EAAkBx6B,KAAMw6B,EAAkB75B,KACtD9Q,EAAWy2B,OAAOloB,GAClBw3B,EAAgBvkC,GAChB8Y,IACA9Y,EAAGygB,SACiB,MAAXypB,GAA8B,QAAXA,EAC5B1rC,EAAWy2B,OAAOloB,GACE,UAAXm9B,IAET1rC,EAAWy2B,OAAOloB,GAClB+L,EAAM,IAEV,CAgDF,EACA0vB,UAAW,SAASxoC,EAAI+3B,EAAKqM,GAC3B,SAASkF,EAAc3iC,GAGrBk4B,EAAeoD,2BAA2B0F,UAAUhhC,GACpDk4B,EAAeoD,2BAA2B9K,QAC1C8L,GAAoB0C,eAAe3lC,EAAI2G,GACvC49B,EAAgBvkC,EAClB,CACA,SAASypC,EAAgB18B,EAAGpG,EAAOmS,GACjC,IAAqC2uB,EAAI9zB,EAArCu2B,EAAU1rC,EAAW0rC,QAAQn9B,IAClB,OAAXm9B,GAA+B,UAAXA,GAAkC,UAAXA,GAC/B,aAAXA,GAAmC,IAATvjC,KAC7Bk4B,EAAeoD,2BAA2B0F,UAAUhhC,GACpDk4B,EAAeoD,2BAA2B9K,QAC1C34B,EAAWy2B,OAAOloB,GAClBw3B,EAAgBvkC,GAChB8Y,IACA9Y,EAAGygB,SAEU,MAAXypB,GAA8B,QAAXA,GACrB1rC,EAAWy2B,OAAOloB,GAClB06B,EAAgB,MAAXyC,EACLv2B,EAAS5G,EAAE4F,OAAS5F,EAAE4F,OAAOw3B,aAAe,EAC5CxjC,EAAQk4B,EAAeoD,2BAA2BuF,UAAU7gC,EAAO8gC,IAAO,GAC1E3uB,EAAMnS,GACFgN,GAAU5G,EAAE4F,SAAQ5F,EAAE4F,OAAOw3B,aAAep9B,EAAE4F,OAAOy3B,eAAiB1qC,KAAKC,IAAIgU,EAAQ5G,EAAE4F,OAAOoX,MAAM1qB,UACtF,UAAX6qC,GAET1rC,EAAWy2B,OAAOloB,GAClB+L,EAAM,KAEU,QAAXoxB,GAAgC,SAAXA,GAAiC,QAAXA,GAAgC,OAAXA,GAA+B,SAAXA,GACvFrL,EAAeoD,2BAA2B9K,OAEhD,CACoB,WAAhBiN,EAAQv3B,KAEVo2B,GAAoB0C,eAAe3lC,EAAIokC,EAAQkG,OAAO3jC,OAElDoxB,EAAIiJ,WACNqI,GAAWrpC,EAAI,CAAEs0B,QAASgV,EAAexlC,OAAQ,IAAKimB,MAAO,QACzD8K,UAAW4U,EAAiBhV,mBAAmB,IAEnD4U,GAAWrpC,EAAI,CAAEs0B,QAASgV,EAAexlC,OAAQ,IAC7C+wB,UAAW4U,GAGrB,EACAf,UAAW,SAAS1oC,EAAI+3B,GAGtB,IAYItpB,EAASD,EACTs4B,EAbAtG,EAAazI,EAAIyI,WACjBn8B,EAASm8B,EAAWn8B,OACpBi0B,EAAakI,EAAWlI,YAAc,CAAC,EACvCnT,EAAWqb,EAAWrb,SACtBgU,EAAeqH,EAAWrH,cAAgB,CAAC,EAC3CiJ,EAAe5B,EAAW4B,aAC1BlhC,EAAM62B,EAAI72B,IAEVqpC,EAAWC,GAAWzS,EAAIiJ,WAAayJ,GAAoBzqC,EAAIkB,EAAIwD,MAAO1E,EAAGoE,UAAU,SACvFsmC,EAAaF,GAAWzS,EAAIiJ,WAAayJ,GAAoBzqC,EAAIkB,EAAI4D,QAAU9E,EAAGoE,UAAU,WAC5FumC,EAAUH,GAAWD,GACrBK,EAAYJ,GAAWE,GA2B3B,GAxBIvlB,GACFxN,KAAKkxB,eAAe9Q,EAAKyI,GAKzBsG,OAHgCn1B,IAA9B6uB,EAAW0H,eAGJ1H,EAAW0H,eAEX1H,EAAWqG,YAElBC,EAAS,GAAKxO,EAAWM,eAC3BN,EAAWsQ,kBAAmB,GACrBtQ,EAAWuS,WAChBvS,EAAWM,gBAA6B,IAAXkO,KACjCA,EAAS,EACTxO,EAAWsQ,kBAAmB,GAE5BpI,EAAWoB,oBAEbtJ,EAAWsJ,kBAAoBzI,EAAayI,kBACxCpB,EAAWoB,mBAEjBtJ,EAAWwO,OAASA,EACpBvC,EAAgBvkC,GACZqE,EAAQ,CACV,IAAIymC,EAAeC,EAAQ1mC,GAAQrE,EAAIuqC,EAAUjS,EAAYP,EAAKyI,GAElE,GADAzI,EAAI+I,WAAaiK,EAAQ1mC,IACpBymC,EACH,OAEF,GAAIxS,EAAWE,WAAY,CACzB,IAAIgJ,EAAW3C,EAAe2C,SAE1B3B,EAAe2B,EAAS3B,aACxBA,GACFmL,GAAmBhrC,EAAI6/B,EAAciL,UAC9BtJ,EAAS3B,cAEhBmL,GAAmBhrC,EAAIuqC,EAAUO,EAErC,CACIA,aAAwB3L,OAC1B3wB,EAAYs8B,EAAa,GACzBr8B,EAAUq8B,EAAa,IAEvBr8B,EAAUq8B,EAGPr8B,IACHA,EAAU+7B,GAAWD,IAEnBxS,EAAIiJ,YACAjJ,EAAIE,aAAexpB,EAAQzP,KAAOisC,MACtCx8B,EAAUg8B,GAAoBzqC,EAAIyO,IAEhCD,IACFA,EAAYi8B,GAAoBzqC,EAAIwO,IAEtCA,EAAYA,GAAao8B,EACzB1pC,EAAI4D,OAAS0J,EACbtN,EAAIwD,KAAO+J,EACXk6B,GAAkB3oC,GAClBkrC,GAAWlrC,EAAI+3B,EAAK,IAChBoT,GAAe38B,EAAWC,GAAWD,EAC/BC,GACVy8B,GAAWlrC,EAAI+3B,EAAK,IAChBoT,GAAe38B,EAAWC,GAAWA,EAC/BD,IACA2W,IACV1W,EAAUg8B,GAAoBzqC,EAAIyO,GAClCzO,EAAGqG,UAAUoI,EAAQ1P,KAAM0P,EAAQzP,IAEvC,CACA,GAAImmB,EAAU,CACZ,GAAIgU,EAAaiS,QAAS,CAExB58B,EAAYo8B,EACZ,IAAIQ,EAAUjS,EAAaiS,QACvBC,EAAa3rC,KAAK4rC,IAAIF,EAAQ1mC,KAAK3F,KAAOqsC,EAAQtmC,OAAO/F,MACzDwsC,EAAW7rC,KAAK4rC,IAAIF,EAAQ1mC,KAAK1F,GAAKosC,EAAQtmC,OAAO9F,IAGvDyP,EAFE28B,EAAQ7R,WAEA,IAAI56B,EAAIisC,EAAU7rC,KAAOssC,EAAYT,EAAU5rC,IAChDosC,EAAQnT,YAEP,IAAIt5B,EAAIisC,EAAU7rC,KAAOssC,EAAYT,EAAU5rC,GAAKusC,GACrDH,EAAQ1mC,KAAK3F,MAAQqsC,EAAQtmC,OAAO/F,KAEnC,IAAIJ,EAAIisC,EAAU7rC,KAAM6rC,EAAU5rC,GAAKusC,GAIvC,IAAI5sC,EAAIisC,EAAU7rC,KAAOssC,EAAYT,EAAU5rC,IAE3D+4B,EAAIiJ,YAAa,EACjBjJ,EAAIwB,WAAa6R,EAAQ7R,WACzBxB,EAAIE,YAAcmT,EAAQnT,YAC1B/2B,EAAM62B,EAAI72B,IAAM,CACd4D,OAAQ0J,EACR9J,KAAM+J,GAERk6B,GAAkB3oC,EACpB,MAAW+3B,EAAIiJ,aACb7H,EAAaiS,QAAU,CACrBtmC,OAAQ0lC,GAAWtpC,EAAI4D,QACvBJ,KAAM8lC,GAAWtpC,EAAIwD,MACrBuzB,YAAaF,EAAIE,YACjBsB,WAAYxB,EAAIwB,aAGpB,IAAIiS,EAAUC,EAAQlT,EAAUqC,EAC5B8Q,EACJ,GAAI3T,EAAIiJ,YAYN,GAVAwK,EAAWG,GAAUzqC,EAAIwD,KAAMxD,EAAI4D,QACnC2mC,EAASG,GAAU1qC,EAAIwD,KAAMxD,EAAI4D,QACjCyzB,EAAWR,EAAIwB,YAAcJ,EAAaZ,SAC1CqC,EAAO7C,EAAIE,YAAc,QAClBM,EAAW,OACX,OACPmT,EAAQG,GAAgB7rC,EAAI,CAC1B8E,OAAQ0mC,EACR9mC,KAAM+mC,GACL7Q,GACCrC,EAAU,CACZ,IAAIjqB,EAASo9B,EAAMp9B,OACnB,GAAY,SAARssB,EAEF,IAAK,IAAI72B,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IACjCuK,EAAOvK,GAAGW,KAAK1F,GAAK8sC,GAAW9rC,EAAIsO,EAAOvK,GAAGW,KAAK3F,UAEnC,QAAR67B,IACTtsB,EAAO,GAAG5J,KAAO,IAAI/F,EAAI2P,EAAO,GAAG5J,KAAK3F,KAAO,EAAG,GAEtD,MACK,CAIL,GAFAysC,EAAWhB,GAAWh8B,GAAao8B,GACnCa,EAASjB,GAAW/7B,GAAWk8B,GAC3BQ,GAAeM,EAAQD,GAAW,CACpC,IAAIh1B,EAAMg1B,EACVA,EAAWC,EACXA,EAASj1B,CACX,CACA+hB,EAAWD,EAAWC,UAAYY,EAAaZ,SAC3CA,EAEFwT,GAAsB/rC,EAAIwrC,EAAUC,GAC3BnT,EAAW51B,SAEpBspC,GAAWhsC,EAAIwrC,EAAUC,GAE3B7Q,EAAO,OACP,IAAIqR,GAAa3T,EAAWK,WAAaJ,EACzCmT,EAAQG,GAAgB7rC,EAAI,CAC1B8E,OAAQ0mC,EACR9mC,KAAM+mC,GACL7Q,EAAMqR,EACX,CACAjsC,EAAGkO,cAAcw9B,EAAMp9B,OAAQo9B,EAAMQ,SACrCnU,EAAI+I,WAAa,KACjB3H,EAAa2N,OAASA,EACtB3N,EAAaiJ,aAAeA,EAE5BjJ,EAAaZ,SAAWA,EACxB,IAAI4T,EAAiBC,GAAUjnB,GAC7BnlB,EAAIm5B,EAAcuS,EAAMp9B,OAAQs8B,EAAWn8B,GACzCspB,EAAIiJ,YACN0D,GAAe1kC,EAAsB,MAAlBmsC,GAEjBA,GACFnsC,EAAGqG,UAAU8lC,EAEjB,CACF,EACAtD,eAAgB,SAAS9Q,EAAKyI,EAAY6L,GACxC,IAAI5K,EAAiB5C,EAAe4C,eAChCA,EAAetB,YACnBpI,EAAI2I,mBAAqBF,EACzBzI,EAAI4I,sBAAwB0L,EAC5B5K,EAAelB,sBAAsBR,QAAU,GAC/C0B,EAAelB,sBAAsBP,+BAAgC,EACrEyB,EAAelB,sBAAsBtI,YAAcF,EAAIE,YAAcF,EAAI72B,IAAIwD,KAAK3F,KAAOg5B,EAAI72B,IAAI4D,OAAO/F,KAAO,EACjH,GAQEgsC,EAAU,CACZuB,cAAe,SAAStsC,EAAIusC,EAAOjU,GACjC,IAAIv5B,EAAOytC,GAAoBxsC,GAAIsP,IAAMgpB,EAAWwO,OAAQ,EAC5D,OAAO,IAAInoC,EAAII,EAAM0tC,GAAgCzsC,EAAGuB,QAAQxC,IAClE,EACA2tC,iBAAkB,SAAS1sC,GACzB,IAAIoN,EAAQo/B,GAAoBxsC,GAC5BjB,EAAOW,KAAKsc,MAAmC,IAA5B5O,EAAMkC,IAAMlC,EAAMhG,SACzC,OAAO,IAAIzI,EAAII,EAAM0tC,GAAgCzsC,EAAGuB,QAAQxC,IAClE,EACA4tC,iBAAkB,SAAS3sC,EAAIusC,EAAOjU,GACpC,IAAIv5B,EAAOytC,GAAoBxsC,GAAIoH,OAASkxB,EAAWwO,OAAQ,EAC/D,OAAO,IAAInoC,EAAII,EAAM0tC,GAAgCzsC,EAAGuB,QAAQxC,IAClE,EACA6tC,aAAc,SAASC,EAAKnoC,EAAM4zB,GAGhC,IAAI7nB,EAAM/L,EACV,OAAO,IAAI/F,EAAI8R,EAAI1R,KAAOu5B,EAAWwO,OAAS,EAAGmE,IACnD,EACAr6B,SAAU,SAAS5Q,EAAIusC,EAAOjU,GAC5B,IAAIh1B,EAAQwlC,GAAe9oC,GACvBuQ,EAAQjN,EAAM4lC,WAClB,GAAK34B,EAAL,CAGA,IAAIyC,GAAQslB,EAAW51B,QAIvB,OAFAsQ,EAAQ1P,EAAMwpC,cAAiB95B,EAAOA,EACtC+5B,GAAuB/sC,EAAIuQ,GACpBK,GAAS5Q,EAAIgT,EAAiBzC,EAAO+nB,EAAWwO,OALvD,CAMF,EAaAkG,2BAA4B,SAAShtC,EAAIusC,EAAOjU,EAAYP,EAAKkV,GAC/D,IAAI3pC,EAAQwlC,GAAe9oC,GACvBuQ,EAAQjN,EAAM4lC,WAElB,GAAK34B,EAAL,CAIA,IAAIyC,GAAQslB,EAAW51B,QACvBsQ,EAAQ1P,EAAMwpC,cAAiB95B,EAAOA,EAGtC,IAAI7Q,EAAO+qC,GAA2BltC,EAAIgT,EAAMzC,EAAO+nB,EAAWwO,OAAQ/O,GAG1E,GAAK51B,EAAL,CAKA,GAAI8qC,EAAe9nB,SACjB,OAAOhjB,EAMT,IAAIlC,EAAOkC,EAAK,GAIZjC,EAAK,IAAIvB,EAAIwD,EAAK,GAAGpD,KAAMoD,EAAK,GAAGnD,GAAK,GAE5C,GAAI+4B,EAAIiJ,WAAY,EAEdjJ,EAAIwB,YAAcxB,EAAIE,eACxBF,EAAIwB,YAAa,EACjBxB,EAAIE,aAAc,EAClBz5B,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,SAAUuS,QAAS,MAKrE,IAAIroC,EAASizB,EAAI72B,IAAI4D,OACrB,GAAIA,EACF,OAAIxB,EAAMwpC,aACJxU,EAAW51B,QACN,CAACoC,EAAQ7E,GAGX,CAAC6E,EAAQ5E,GAEZo4B,EAAW51B,QACN,CAACoC,EAAQ5E,GAGX,CAAC4E,EAAQ7E,EAGtB,MAEE83B,EAAIiJ,YAAa,EACjBjJ,EAAIwB,YAAa,EACjBxB,EAAIE,aAAc,EAClBz5B,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,SAAUuS,QAAS,KAGrE,OAAOn6B,EAAO,CAAC9S,EAAID,GAAQ,CAACA,EAAMC,EAlDlC,CAXA,CA8DF,EACAktC,SAAU,SAASptC,EAAIusC,EAAOjU,EAAYP,GACxC,IAAIz3B,EAAM+sC,GAAWrtC,EAAI+3B,EAAKO,EAAWsJ,mBACzC,OAAIthC,EACKg4B,EAAWC,SAAW,CAAEx5B,KAAMuB,EAAIvB,KAAMC,GAAIytC,GAAgCzsC,EAAGuB,QAAQjB,EAAIvB,QAAWuB,EAExG,IACT,EACAgtC,0BAA2B,SAASttC,EAAIusC,EAAOjU,EAAYP,GACzD,GAAIA,EAAIE,aAAeK,EAAWY,SAAU,CAC1C,IAAIh4B,EAAM62B,EAAI72B,IACd,MAAO,CACLupC,GAAoBzqC,EAAI,IAAIrB,EAAIuC,EAAI4D,OAAO/F,KAAMmC,EAAIwD,KAAK1F,KAC1DyrC,GAAoBzqC,EAAI,IAAIrB,EAAIuC,EAAIwD,KAAK3F,KAAMmC,EAAI4D,OAAO9F,KAE9D,CACE,MAAO,CAAE+4B,EAAI72B,IAAIwD,KAAMqzB,EAAI72B,IAAI4D,OAEnC,EACAyoC,WAAY,SAASvtC,EAAI0E,EAAM4zB,EAAYP,GAEzC,IADA,IAAIyV,EAAO9oC,EACFX,EAAI,EAAGA,EAAIu0B,EAAWwO,OAAQ/iC,IAAK,CAC1C,IAAIQ,EAASipC,EACb,IAAK,IAAIpyB,KAAO2c,EAAI1jB,MAClB,GAAK0pB,EAAY3iB,GAAjB,CAGA,IAAIqY,EAAOsE,EAAI1jB,MAAM+G,GAAK5G,OACtBi5B,EAAoBnV,EAAkB,QACxC6S,GAAe1X,EAAMlvB,GAAU4mC,GAAe5mC,EAAQkvB,GAExD,IAAIga,KAGAnV,EAAWC,UAAa9E,EAAK10B,MAAQwF,EAAOxF,MAAhD,CAIA,IAAI2uC,EAAQhO,GAAYn7B,EAAQipC,GAC5BG,EAAWrV,EAAkB,QAC/BsV,GAAgBrpC,EAAQkvB,EAAM+Z,GAC9BI,GAAgBJ,EAAM/Z,EAAMlvB,IAE1BmpC,GAASC,KACXH,EAAO/Z,EART,CAVA,CAqBJ,CAQA,OANI6E,EAAWC,WAIbiV,EAAO,IAAI7uC,EAAI6uC,EAAKzuC,KAAM0tC,GAAgCzsC,EAAGuB,QAAQisC,EAAKzuC,SAErEyuC,CACT,EACAK,iBAAkB,SAAShB,EAAKnoC,EAAM4zB,GACpC,IAAI7nB,EAAM/L,EACNoiC,EAASxO,EAAWwO,OACpB9nC,EAAKs5B,EAAW51B,QAAU+N,EAAIzR,GAAK8nC,EAASr2B,EAAIzR,GAAK8nC,EACzD,OAAO,IAAInoC,EAAI8R,EAAI1R,KAAMC,EAC3B,EACA8uC,YAAa,SAAS9tC,EAAI0E,EAAM4zB,EAAYP,GAC1C,IAAItnB,EAAM/L,EACNqpC,EAAQt9B,EAAIzR,GAMhB,OAAQ+4B,EAAI+I,YACV,KAAKnpB,KAAKm2B,YACV,KAAKn2B,KAAKq2B,mBACV,KAAKr2B,KAAKs2B,aACV,KAAKt2B,KAAKu2B,aACV,KAAKv2B,KAAKw2B,UACRJ,EAAQhW,EAAI6I,SACZ,MACF,QACE7I,EAAI6I,SAAWmN,EAEnB,IAAIjH,EAASxO,EAAWwO,QAAQxO,EAAWQ,cAAc,GACrD/5B,EAAOu5B,EAAW51B,QAAU+N,EAAI1R,KAAO+nC,EAASr2B,EAAI1R,KAAO+nC,EAC3DnkC,EAAQ3C,EAAG4B,YACXmM,EAAO/N,EAAG8B,WACVssC,EAAOpuC,EAAGgB,SAASyP,EAAM6nB,EAAW51B,QAAUokC,GAAUA,EAAS,OAAQ/O,EAAI8I,WAC7EwN,EAAgB/V,EAAW51B,QAAU0rC,EAAKrvC,KAAOA,EAAOqvC,EAAKrvC,KAAOA,EAOxE,OANIsvC,IACFtvC,EAAOqvC,EAAKrvC,KACZgvC,EAAQK,EAAKpvC,IAIXD,EAAO4D,GAAS8N,EAAI1R,MAAQ4D,EACvBgV,KAAK22B,kBAAkBtuC,EAAI0E,EAAM4zB,EAAYP,GAC3Ch5B,EAAOgP,GAAQ0C,EAAI1R,MAAQgP,EAC3BogC,GAAUnuC,EAAI0E,EAAM4zB,EAAYP,GAAK,IAE5CO,EAAWO,cACbkV,EAAMtB,GAAgCzsC,EAAGuB,QAAQxC,IACjDg5B,EAAI6I,SAAWmN,GAEjBhW,EAAI8I,UAAY7gC,EAAGuuC,WAAW,IAAI5vC,EAAII,EAAMgvC,GAAO,OAAOp/B,KACnD,IAAIhQ,EAAII,EAAMgvC,GACvB,EACAC,mBAAoB,SAAShuC,EAAI0E,EAAM4zB,EAAYP,GACjD,IAAItnB,EAAM/L,EACV,OAAQqzB,EAAI+I,YACV,KAAKnpB,KAAKq2B,mBACV,KAAKr2B,KAAKs2B,aACV,KAAKt2B,KAAKm2B,YACV,KAAKn2B,KAAKu2B,aACV,KAAKv2B,KAAKw2B,UACR,MACF,QACEpW,EAAI8I,UAAY7gC,EAAGuuC,WAAW99B,EAAI,OAAO9B,KAE7C,IAAIm4B,EAASxO,EAAWwO,OACpB0H,EAAIxuC,EAAGgB,SAASyP,EAAK6nB,EAAW51B,QAAUokC,GAAUA,EAAQ,OAAO/O,EAAI8I,WAC3E,GAAI2N,EAAIC,QACN,GAAInW,EAAW51B,QACb,KAAIgsC,EAAiB1uC,EAAGuuC,WAAWC,EAAK,OACpCG,EAAa,CAAEr/B,IAAKo/B,EAAep/B,IAAM,EAAGX,KAAMopB,EAAI8I,WACtD2N,EAAMxuC,EAAG4uC,WAAWD,EAAY,MAFU,KAGzC,CACL,IAAIE,EAAY7uC,EAAGuuC,WAAW,IAAI5vC,EAAIqB,EAAG4B,YAAa,GAAI,OAC1DitC,EAAUlgC,KAAOopB,EAAI8I,UACrB2N,EAAMxuC,EAAG4uC,WAAWC,EAAW,MACjC,CAGF,OADA9W,EAAI6I,SAAW4N,EAAIxvC,GACZwvC,CACT,EACAM,WAAY,SAAS9uC,EAAI0E,EAAM4zB,GAI7B,IAAIkT,EAAW9mC,EACXoiC,EAASxO,EAAWwO,OACxB,OAAO9mC,EAAGgB,SAASwqC,EAAWlT,EAAW51B,QAAUokC,GAAUA,EAAS,OACxE,EACAiI,gBAAiB,SAAS/uC,EAAI0E,EAAM4zB,GAClC,IAAI13B,EAAM03B,EAAW51B,QAAU,GAAK,EACpC,OAAOssC,GAAchvC,EAAI0E,EAAM4zB,EAAWwO,OAAQlmC,EACpD,EACAquC,eAAgB,SAASjvC,EAAI0E,EAAM4zB,GACjC,IAAI13B,EAAM03B,EAAW51B,QAAU,GAAK,EACpC,OAAOwsC,GAAalvC,EAAI0E,EAAM4zB,EAAWwO,OAAQlmC,EACnD,EACAqtC,aAAc,SAASjuC,EAAI0E,EAAM4zB,EAAYP,GAC3C,IAAIoX,EAAYnvC,EAAGmP,gBACfs8B,EAAS,KACT3E,EAASxO,EAAWwO,OACnBA,IACHA,EAASqI,EAAU5/B,cAAgB,EAAIvP,EAAGyP,sBAE5C,IAAIyiB,EAAOlyB,EAAGuuC,WAAW7pC,EAAM,SAG/B,GAFA4zB,EAAWwO,OAASA,EACpB2E,EAASV,EAAQiD,mBAAmBhuC,EAAI0E,EAAM4zB,EAAYP,IACrD0T,EACH,OAAO,KAET,IAAI2D,EAAOpvC,EAAGuuC,WAAW9C,EAAQ,SAEjC,OADAzrC,EAAGwP,SAAS,KAAM2/B,EAAU7/B,IAAM8/B,EAAK9/B,IAAM4iB,EAAK5iB,KAC3Cm8B,CACT,EACA4D,YAAa,SAASrvC,EAAI0E,EAAM4zB,GAC9B,OAAOgX,GAAWtvC,EAAI0E,EAAM4zB,EAAWwO,SAAUxO,EAAW51B,UACtD41B,EAAWG,UAAWH,EAAWI,QACzC,EACA6W,kBAAmB,SAASvvC,EAAIusC,EAAOjU,GACrC,IAAIwO,EAASxO,EAAWwO,OACpB2E,EAAS+D,GAAgBxvC,EAAI8mC,EAAQxO,EAAW51B,QAChD41B,EAAWsJ,mBACXD,EAAYrJ,EAAW51B,SAAW,EAAI,EAE1C,OADA+sC,GAA0B9N,EAAWrJ,GAChCmT,GACLA,EAAOzsC,IAAM2iC,EACN8J,GAFa,IAGtB,EACA+D,gBAAiB,SAASxvC,EAAI0E,EAAM4zB,GAClC,IAAIwO,EAASxO,EAAWwO,OAExB,OADA2I,GAA0B,EAAGnX,GACtBkX,GAAgBxvC,EAAI8mC,EAAQxO,EAAW51B,QAC1C41B,EAAWsJ,oBAAsBl9B,CACvC,EACAgrC,aAAc,SAAS1vC,EAAI0E,EAAM4zB,GAC/B,IAAIwO,EAASxO,EAAWwO,OACxB,OAAO6I,GAAW3vC,EAAI8mC,EAAQxO,EAAW51B,QACrC41B,EAAWsJ,oBAAsBl9B,CACvC,EACAwpC,aAAc,SAASluC,EAAI0E,EAAM4zB,EAAYP,GAC3C,IAAI+O,EAASxO,EAAWwO,OAIxB,OAFA/O,EAAI6I,SAAWkG,EAAS,EACxB/O,EAAI8I,UAAY7gC,EAAGuuC,WAAW7pC,EAAK,OAAOiK,KACnCu/B,GAAaluC,EAAI8mC,EAC1B,EACAqH,UAAW,SAASnuC,EAAI0E,EAAM4zB,EAAYP,GACxC,OAAOoW,GAAUnuC,EAAI0E,EAAM4zB,EAAYP,GAAK,EAC9C,EACA6X,kCAAmC,SAAS5vC,EAAI0E,GAG9C,IAAIH,EAASG,EACb,OAAO,IAAI/F,EAAI4F,EAAOxF,KACX0tC,GAAgCzsC,EAAGuB,QAAQgD,EAAOxF,OAC/D,EACA8wC,oBAAqB,SAAS7vC,EAAI0E,GAMhC,IALA,IAIIorC,EAJAvrC,EAASG,EACT3F,EAAOwF,EAAOxF,KACdC,EAAKuF,EAAOvF,GACZ+wC,EAAW/vC,EAAGuB,QAAQxC,GAEnBC,EAAK+wC,EAAS1wC,OAAQL,IAE3B,GADA8wC,EAASC,EAAS3tC,OAAOpD,GACrB8wC,GAAU9R,EAAkB8R,GAAS,CACvC,IAAIhpC,EAAQ9G,EAAG+S,eAAe,IAAIpU,EAAII,EAAMC,EAAK,IACjD,GAAc,WAAV8H,GAAgC,YAAVA,EACxB,KAEJ,CAEF,GAAI9H,EAAK+wC,EAAS1wC,OAAQ,CAExB,IAAIokB,EAAa,MAAPzkB,GAAqB,MAAPA,EAAc,cAAgB,YAClDgxC,EAAUhwC,EAAGuC,oBAAoB,IAAI5D,EAAII,EAAMC,GAAK,CAACixC,aAAcxsB,IACvE,OAAOusB,EAAQ9vC,EACjB,CACE,OAAOqE,CAEX,EACA+pC,kBAAmB,SAASzB,EAAKnoC,GAC/B,OAAO,IAAI/F,EAAI+F,EAAK3F,KAAM,EAC5B,EACAmxC,2BAA4B,SAASlwC,EAAIusC,EAAOjU,GAC9C,IAAI6X,EAAU7X,EAAW51B,QAAU1C,EAAG8B,WAAa9B,EAAG4B,YAItD,OAHI02B,EAAWsQ,mBACbuH,EAAU7X,EAAWwO,OAAS9mC,EAAGoL,UAAU,oBAEtC,IAAIzM,EAAIwxC,EACJ1D,GAAgCzsC,EAAGuB,QAAQ4uC,IACxD,EACAC,yBAA0B,SAASpwC,GAEjC,OADAA,EAAG6D,YAAY,cACR7D,EAAGoE,WACZ,EACAisC,uBAAwB,SAASrwC,GAC/BA,EAAG6D,YAAY,eACf,IAAIa,EAAO1E,EAAGoE,YAEd,MADmB,UAAfM,EAAK4rC,QAAoB5rC,EAAK1F,KAC3B0F,CACT,EACA6rC,uBAAwB,SAASvwC,EAAI0E,EAAM4zB,EAAYP,GAGrD,IAAIyY,EAAgB,CAAC,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,KAChCC,EAAa,CAAC,KAAM,EAAM,KAAK,EAAM,KAAK,GAE1CzI,EAAY1P,EAAWsJ,kBAGV,KAAboG,EACFA,EAAY,IACU,KAAbA,IACTA,EAAY,KAQd,IAEIxxB,EAFAmiB,GAAaL,EAAW2B,gBAG5B,GAAIuW,EAAcxI,GAChBxxB,EAAMk6B,GAAsB1wC,EAAI0E,EAAMsjC,EAAWrP,QAC5C,GAAI8X,EAAWzI,GACpBxxB,EAAMm6B,GAAoB3wC,EAAI0E,EAAMsjC,EAAWrP,QAC1C,GAAkB,MAAdqP,EACTxxB,EAAMkzB,GAAsB1pC,EAAI24B,GAAW,GACA,QACtC,GAAkB,MAAdqP,EACTxxB,EAAMkzB,GAAsB1pC,EAAI24B,GAAW,GACA,QACtC,GAAkB,MAAdqP,EAGT,GAFAxxB,EAAMw4B,GAAchvC,EAAI0E,EAAM4zB,EAAWwO,OAAQ,EAAGnO,GACpDL,EAAWC,UAAW,EAClBR,EAAIiJ,WACDjJ,EAAIwB,aAAcxB,EAAIwB,YAAa,OACnC,CACL,IAAIJ,EAAepB,EAAIyI,WAAWrH,aAC9BA,IAAgBA,EAAaZ,UAAW,GAC5C/hB,EAAIxT,IAAIjE,MACV,MACK,GAAkB,MAAdipC,EACTxxB,EAAMo6B,GAAqB5wC,EAAI0E,EAAMi0B,OAChC,IAAkB,MAAdqP,EAgBT,OAAO,KAdP,IAAIjqC,EAAUiC,EAAGuB,QAAQmD,EAAK3F,MAC1B2F,EAAK1F,GAAK,GAAKm/B,EAAsBpgC,EAAQ2G,EAAK1F,OACpD0F,EAAK1F,IAAM,GAEb,IAAIgE,EAAM6tC,GAAY7wC,EAAI0E,EAAM4zB,EAAWwO,OAAQ,EAAGnO,GAClD51B,EAAQ8tC,GAAY7wC,EAAI0E,EAAM4zB,EAAWwO,QAAS,EAAGnO,GAErDuF,EAAmBl+B,EAAGuB,QAAQwB,EAAMhE,MAAMgE,EAAM/D,MAC7Ck/B,EAAmBl+B,EAAGuB,QAAQyB,EAAIjE,MAAMiE,EAAIhE,GAAI,MACrD+D,EAAQ,CAAChE,KAAMgE,EAAMhE,KAAMC,GAAI+D,EAAM/D,GAAK,IAE5CwX,EAAM,CAACzT,MAAOA,EAAOC,IAAKA,EAI5B,CAEA,OAAKhD,EAAGsD,MAAMy0B,IAAIiJ,WAGT8P,GAAgB9wC,EAAIwW,EAAIzT,MAAOyT,EAAIxT,KAFnC,CAACwT,EAAIzT,MAAOyT,EAAIxT,IAI3B,EAEA+tC,0BAA2B,SAAS/wC,EAAI0E,EAAM4zB,GAC5C,IAAI0Y,EAAanS,EAAe6C,oBAC5BoF,EAASxO,EAAWwO,OACpBpkC,EAAU41B,EAAW51B,UAAYsuC,EAAWtuC,QAC5Ci/B,GAAaqP,EAAWrP,UAAY,EAAI,IAAMj/B,GAAW,EAAI,GACjE1C,EAAGixC,OAAOtP,EAAW,QACrBrJ,EAAWK,YAAYj2B,EACvB,IAAI+oC,EAAS+D,GAAgBxvC,EAAI8mC,EAAQpkC,EAASsuC,EAAWpP,mBAC7D,OAAK6J,GAILA,EAAOzsC,IAAM2iC,EACN8J,IAJLzrC,EAAGixC,MAAMtP,EAAW,QACbj9B,EAIX,GAGF,SAASmhC,GAAahe,EAAMzO,GAC1B2xB,EAAQljB,GAAQzO,CAClB,CAEA,SAAS83B,GAAU71B,EAAK81B,GAEtB,IADA,IAAI9S,EAAM,GACDt6B,EAAI,EAAGA,EAAIotC,EAAOptC,IACzBs6B,EAAIj/B,KAAKic,GAEX,OAAOgjB,CACT,CAMA,IAAI+N,GAAY,CACdgF,OAAQ,SAASpxC,EAAIqxC,EAAM/iC,GACzB,IAAIgjC,EAAWlxC,EACX23B,EAAM/3B,EAAGsD,MAAMy0B,IACfjzB,EAASwJ,EAAO,GAAGxJ,OACnBJ,EAAO4J,EAAO,GAAG5J,KACrB,GAAKqzB,EAAIiJ,WA4BF,GAAIqQ,EAAKxX,SACZn1B,EAAK1F,GAAKyE,OAAO8tC,UACjB7sC,EAAK3F,OACLiB,EAAGiI,aAAanD,EAAQJ,GACxBtE,EAAOJ,EAAG+H,eACV/H,EAAG+F,iBAAiB,IACpBurC,EAAYxsC,MACT,CACL1E,EAAOJ,EAAG+H,eACV,IAAIypC,EAAcN,GAAU,GAAI5iC,EAAOjP,QACvCW,EAAGwS,kBAAkBg/B,GACrBF,EAAY3F,GAAUr9B,EAAO,GAAG5J,KAAM4J,EAAO,GAAGxJ,OAClD,KAxCqB,CACnB1E,EAAOJ,EAAGK,SAASyE,EAAQJ,GAC3B,IAAI+sC,EAAY1Z,EAAI2I,oBAAsB,CAAC,EAC3C,GAAwB,eAApB+Q,EAAUptC,SAA4B65B,EAAmB99B,GAAO,CAElE,IAAIqC,EAAQ,OAASqR,KAAK1T,GACtBqC,GAASgvC,EAAUnZ,YAAcmZ,EAAUnZ,WAAW51B,UACxDgC,EAAOo4B,GAAap4B,EAAM,GAAKjC,EAAM,GAAGpD,QACxCe,EAAOA,EAAKsB,MAAM,GAAKe,EAAM,GAAGpD,QAEpC,CACA,IAAIqyC,EAAc,IAAI/yC,EAAImG,EAAO/F,KAAO,EAAG0E,OAAO8tC,WAC9CI,EAAc3xC,EAAG4B,aAAe5B,EAAG8B,WACnC4C,EAAK3F,KAAOiB,EAAG8B,YAAcuvC,EAAK9Y,WAAaoZ,EACjD3xC,EAAGS,aAAa,GAAIixC,EAAahtC,GAEjC1E,EAAGS,aAAa,GAAIqE,EAAQJ,GAE1B2sC,EAAK9Y,WAEFoZ,IACH3xC,EAAGqG,UAAUqrC,GACblzC,EAAWE,SAASkzC,iBAAiB5xC,IAGvC8E,EAAO9F,GAAKyE,OAAO8tC,WAErBD,EAAYxsC,CACd,CAaA+5B,EAAegD,mBAAmBoF,SAC9BoK,EAAKjP,aAAc,SAAUhiC,EAC7BixC,EAAK9Y,SAAUjqB,EAAOjP,OAAS,GACnC09B,GAAQC,gBAAgBh9B,EAAI,CAAC0E,KAAM4sC,GAAYtxC,EAAGsD,MAAMy0B,IAC1D,EAEA,OAAU,SAAS/3B,EAAIqxC,EAAM/iC,GAC3B,IAAIgjC,EAAWlxC,EACX23B,EAAM/3B,EAAGsD,MAAMy0B,IACnB,GAAKA,EAAIE,YAoBF,CACL73B,EAAOJ,EAAG+H,eACV,IAAIypC,EAAcN,GAAU,GAAI5iC,EAAOjP,QACvCW,EAAGwS,kBAAkBg/B,GACrBF,EAAY3F,GAAUr9B,EAAO,GAAG5J,KAAM4J,EAAO,GAAGxJ,OAClD,KAzBsB,CACpB,IAAIA,EAASwJ,EAAO,GAAGxJ,OACnBJ,EAAO4J,EAAO,GAAG5J,KACjB2sC,EAAK9Y,UACL7zB,EAAK3F,MAAQiB,EAAG4B,aAChBkD,EAAO/F,MAAQiB,EAAG8B,YAClBgD,EAAO/F,MAAQ2F,EAAK3F,KAAO,IAEzB+F,EAAO/F,MAAQiB,EAAG4B,YACpBkD,EAAO9F,GAAK,EAEZ8F,EAAS,IAAInG,EAAImG,EAAO/F,KAAO,EAAG+sC,GAAW9rC,EAAI8E,EAAO/F,KAAO,KAGnEqB,EAAOJ,EAAGK,SAASyE,EAAQJ,GAC3B1E,EAAGS,aAAa,GAAIqE,EAAQJ,GAC5B4sC,EAAYxsC,EACRusC,EAAK9Y,WACP+Y,EAAYvG,EAAQ6E,kCAAkC5vC,EAAI8E,GAE9D,CASA,OAHA+5B,EAAegD,mBAAmBoF,SAC9BoK,EAAKjP,aAAc,SAAUhiC,EAC7BixC,EAAK9Y,SAAUR,EAAIE,aAChBwS,GAAoBzqC,EAAIsxC,EACjC,EACA99B,OAAQ,SAASxT,EAAIqxC,EAAM/iC,GACzB,IAAIypB,EAAM/3B,EAAGsD,MAAMy0B,IACnB,GAAI/3B,EAAG6xC,WAEL,IADA,IAAI/K,EAAU/O,EAAc,WAAIsZ,EAAKvK,OAAS,EACrChyB,EAAI,EAAGA,EAAIgyB,EAAQhyB,IACtBu8B,EAAKjY,YAAap5B,EAAG6xC,aACpB7xC,EAAG8xC,iBAEL,CACL,IAAIrgB,EAAYnjB,EAAO,GAAGxJ,OAAO/F,KAC7B4kB,EAAUoU,EAAIE,YAChB3pB,EAAOA,EAAOjP,OAAS,GAAGyF,OAAO/F,KACjCuP,EAAO,GAAG5J,KAAK3F,KAGb+nC,EAAU/O,EAAc,WAAIsZ,EAAKvK,OAAS,EAC1CuK,EAAK9Y,UAIP5U,IAEF,IAAK,IAAI5f,EAAI0tB,EAAW1tB,GAAK4f,EAAS5f,IACpC,IAAS+Q,EAAI,EAAGA,EAAIgyB,EAAQhyB,IAC1B9U,EAAGiO,WAAWlK,EAAGstC,EAAKjY,YAG5B,CACA,OAAO2R,EAAQ6E,kCAAkC5vC,EAAIsO,EAAO,GAAGxJ,OACjE,EACAitC,WAAY,SAAS/xC,EAAIgyC,EAAO1jC,GAE9B,OADAtO,EAAG6D,YAAY,cACRknC,EAAQ6E,kCAAkC5vC,EAAIsO,EAAO,GAAGxJ,OACjE,EACAmtC,WAAY,SAASjyC,EAAIqxC,EAAM/iC,EAAQs8B,EAAWn8B,GAIhD,IAHA,IAAIjK,EAAaxE,EAAGkyC,gBAChBC,EAAU,GACV9Y,EAAUgY,EAAKhY,QACVvkB,EAAI,EAAGA,EAAItQ,EAAWnF,OAAQyV,IAAK,CAC1C,IAAIs9B,EAAS5tC,EAAWsQ,GACpB1U,EAAO,GACX,IAAgB,IAAZi5B,EACFj5B,EAAOgyC,EAAO3nC,mBACT,IAAgB,IAAZ4uB,EACTj5B,EAAOgyC,EAAO5nC,mBAEd,IAAK,IAAIzG,EAAI,EAAGA,EAAIquC,EAAO/yC,OAAQ0E,IAAK,CACtC,IAAIikC,EAAYoK,EAAOhwC,OAAO2B,GAC9B3D,GAAQw8B,EAAYoL,GAAaA,EAAUv9B,cACvCu9B,EAAUx9B,aAChB,CAEF2nC,EAAQ/yC,KAAKgB,EACf,CAEA,OADAJ,EAAGwS,kBAAkB2/B,GACjBd,EAAK7X,iBACA/qB,GACGzO,EAAGsD,MAAMy0B,IAAIiJ,YAAcqQ,EAAK9Y,UAAYjqB,EAAO,GAAGxJ,OAAO/F,KAAO,GAAKuP,EAAO,GAAG5J,KAAK3F,KAC3FgsC,EAAQ6E,kCAAkC5vC,EAAI4qC,GAC5CyG,EAAK9Y,SACPqS,EAEAe,GAAUr9B,EAAO,GAAGxJ,OAAQwJ,EAAO,GAAG5J,KAEjD,EACAsD,KAAM,SAAShI,EAAIqxC,EAAM/iC,EAAQs8B,GAC/B,IAAI7S,EAAM/3B,EAAGsD,MAAMy0B,IACf33B,EAAOJ,EAAG+H,eACVsqC,EAASta,EAAIiJ,WACb2K,GAAU5T,EAAI72B,IAAI4D,OAAQizB,EAAI72B,IAAIwD,KAAM4J,EAAO,GAAG5J,KAAM4J,EAAO,GAAGxJ,QAClE8lC,EAIJ,OAHA/L,EAAegD,mBAAmBoF,SAC9BoK,EAAKjP,aAAc,OACnBhiC,EAAMixC,EAAK9Y,SAAUR,EAAIE,aACtBoa,CACT,GAGF,SAAStM,GAAele,EAAMzO,GAC5BgzB,GAAUvkB,GAAQzO,CACpB,CAEA,IAAI2jB,GAAU,CACZuV,aAAc,SAAStyC,EAAIg5B,EAAYjB,GACrC,IAAIA,EAAIiJ,WAAR,CAGA,IAAI8F,EAAS9N,EAAW8N,OACpBpkC,EAAUs2B,EAAWt2B,QACrB8+B,EAAW3C,EAAe2C,SAE1B/N,EAAO+N,EAASt9B,KAAKlE,EAAI0C,EAAUokC,GAAUA,GAC7CrH,EAAUhM,EAAOA,EAAKjf,YAAS7C,EACnC8tB,EAAUA,GAAoBz/B,EAAGoE,YACjCpE,EAAGqG,UAAUo5B,EARb,CASF,EACA1vB,OAAQ,SAAS/P,EAAIg5B,EAAYjB,GAC/B,IAAIA,EAAIiJ,WAAR,CAGA,IAAI8F,EAAS9N,EAAW8N,QAAU,EAC9ByL,EAAavyC,EAAGyP,oBAChBH,EAAMtP,EAAGmP,gBAAgBG,IACzBkjC,EAAQD,EAAazL,EACrB5jC,EAAS81B,EAAWt2B,QAAU4M,EAAMkjC,EAAQljC,EAAMkjC,EAClDjuC,EAASimC,GAAWxqC,EAAGoE,aACvBsK,EAAe1O,EAAGuuC,WAAWhqC,EAAQ,SACzC,GAAIy0B,EAAWt2B,QACTQ,EAASwL,EAAaY,KACvB/K,EAAOxF,OAASmE,EAASwL,EAAaY,KAAOijC,EAC7ChuC,EAAOxF,KAAOW,KAAK+yC,KAAKluC,EAAOxF,MAC/BiB,EAAGqG,UAAU9B,GACbmK,EAAe1O,EAAGuuC,WAAWhqC,EAAQ,SACrCvE,EAAGwP,SAAS,KAAMd,EAAaY,MAG/BtP,EAAGwP,SAAS,KAAMtM,OAEhB,CACL,IAAIwvC,EAAYxvC,EAASlD,EAAGmP,gBAAgBI,aACxCmjC,EAAYhkC,EAAatH,QAC1B7C,EAAOxF,OAAS2P,EAAatH,OAASsrC,GAAaH,EACnDhuC,EAAOxF,KAAOW,KAAKsc,MAAMzX,EAAOxF,MAChCiB,EAAGqG,UAAU9B,GACbmK,EAAe1O,EAAGuuC,WAAWhqC,EAAQ,SACrCvE,EAAGwP,SACC,KAAMd,EAAatH,OAASpH,EAAGmP,gBAAgBI,eAGnDvP,EAAGwP,SAAS,KAAMtM,EAEvB,CAhCA,CAiCF,EACAyvC,eAAgB,SAAS3yC,EAAIg5B,GAC3B,IAAImX,EAAUnwC,EAAGoE,YAAYrF,KACzBwvC,EAAavuC,EAAGuuC,WAAW,IAAI5vC,EAAIwxC,EAAS,GAAI,SAChDnxB,EAAShf,EAAGmP,gBAAgBI,aAC5BqjC,EAAIrE,EAAWj/B,IACnB,OAAQ0pB,EAAWvb,UACjB,IAAK,SAAUm1B,EAAIrE,EAAWnnC,OAAS4X,EAAS,EAC9C,MACF,IAAK,SACH,IAAI6zB,EAAkB,IAAIl0C,EAAIwxC,EAASnwC,EAAGuB,QAAQ4uC,GAAS9wC,OAAS,GAChEyzC,EAAqB9yC,EAAGuuC,WAAWsE,EAAiB,SACpDN,EAAaO,EAAmB1rC,OAASwrC,EAC7CA,EAAIA,EAAI5zB,EAASuzB,EACjB,MAEJvyC,EAAGwP,SAAS,KAAMojC,EACpB,EACAG,YAAa,SAAS/yC,EAAIg5B,EAAYjB,GACpC,IAAIqK,EAAepJ,EAAW4I,kBAC1BkF,EAAS9N,EAAW8N,OACpBrF,EAAiB5C,EAAe4C,eAChB,KAAhBW,EACFA,EAAeX,EAAevB,eAE9BuB,EAAevB,eAAiBkC,EAElC,MAAM0E,IACJkM,GAAqBhzC,EAAI+3B,EAAK0J,EAAgBW,EAElD,EACAD,qBAAsB,SAASniC,EAAIg5B,GACjC,IAAIyI,EAAiB5C,EAAe4C,eAChCW,EAAepJ,EAAW4I,kBAC1B/C,EAAegD,mBAAmBwF,gBAAgBjF,IACpDX,EAAeU,qBAAqBniC,EAAIoiC,EAE5C,EACA6Q,gBAAiB,SAASjzC,GACnBA,EAAGsD,MAAM4vC,WAKZlzC,EAAGizC,iBAAgB,GACnBjzC,EAAG26B,UAAU,SAAU,cACvBn8B,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,aANhD56B,EAAGizC,iBAAgB,GACnBjzC,EAAG26B,UAAU,SAAU,eACvBn8B,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,YAMpD,EACAoC,gBAAiB,SAASh9B,EAAIg5B,EAAYjB,GACxC,IAAI/3B,EAAGoL,UAAU,YAAjB,CACA2sB,EAAIC,YAAa,EACjBD,EAAIgJ,iBAAmB/H,GAAcA,EAAW8N,QAAU,EAC1D,IAAIrN,EAAW,EAAeT,EAAWS,SAAW,KAChDv4B,EAAM62B,EAAI72B,IACVwD,EAAOs0B,EAAWt0B,MAAQ1E,EAAGoE,UAAU,QACvC4a,EAAShf,EAAGyE,iBAAiBpF,OACjC,GAAgB,OAAZo6B,EACF/0B,EAAO,IAAI/F,EAAI+F,EAAK3F,KAAM+sC,GAAW9rC,EAAI0E,EAAK3F,YACzC,GAAgB,OAAZ06B,EACT/0B,EAAO,IAAI/F,EAAI+F,EAAK3F,KAAM,QACrB,GAAgB,aAAZ06B,EACT/0B,EAAOo4B,GAAap4B,EAAM,EAAG,QACxB,GAAgB,iBAAZ+0B,EACT/0B,EAAOqmC,EAAQ6E,kCAAkC5vC,EAAI0E,QAChD,GAAgB,uBAAZ+0B,EAAmC,CAC5C,IAAK1B,EAAIiJ,WACL,OACCjJ,EAAIE,aAOPvzB,EAAO,IAAI/F,EACPe,KAAKC,IAAIuB,EAAIwD,KAAK3F,KAAMmC,EAAI4D,OAAO/F,MACnCW,KAAKC,IAAIuB,EAAIwD,KAAK1F,GAAIkC,EAAI4D,OAAO9F,KACrCggB,EAAStf,KAAK4rC,IAAIpqC,EAAIwD,KAAK3F,KAAOmC,EAAI4D,OAAO/F,MAAQ,GARnD2F,EADExD,EAAIwD,KAAK3F,KAAOmC,EAAI4D,OAAO/F,KACtBmC,EAAIwD,KAEJ,IAAI/F,EAAIuC,EAAI4D,OAAO/F,KAAM,EAQtC,MAAO,GAAgB,qBAAZ06B,EAAiC,CACxC,IAAK1B,EAAIiJ,WACP,OACCjJ,EAAIE,aAOPvzB,EAAO,IAAI/F,EACPe,KAAKC,IAAIuB,EAAIwD,KAAK3F,KAAMmC,EAAI4D,OAAO/F,MACnCW,KAAKwe,IAAIhd,EAAIwD,KAAK1F,GAAIkC,EAAI4D,OAAO9F,IAAM,GAC3CggB,EAAStf,KAAK4rC,IAAIpqC,EAAIwD,KAAK3F,KAAOmC,EAAI4D,OAAO/F,MAAQ,GARnD2F,EADExD,EAAIwD,KAAK3F,MAAQmC,EAAI4D,OAAO/F,KACvB+9B,GAAa57B,EAAIwD,KAAM,EAAG,GAE1B,IAAI/F,EAAIuC,EAAI4D,OAAO/F,KAAM,EAQtC,MAAO,GAAgB,WAAZ06B,GACT,GAAI1B,EAAIiJ,WACN,WAEmB,YAAZvH,IACT/0B,EAAOyuC,GAAenzC,IAAO0E,GAE/B1E,EAAG26B,UAAU,gBAAgB,GACzB3B,GAAcA,EAAWxW,SAE3BxiB,EAAGizC,iBAAgB,GACnBjzC,EAAG26B,UAAU,SAAU,eACvBn8B,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,cAEhD56B,EAAGizC,iBAAgB,GACnBjzC,EAAG26B,UAAU,SAAU,cACvBn8B,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,YAE7CiE,EAAe4C,eAAetB,YAEjCngC,EAAGiF,GAAG,SAAUkxB,IAChB33B,EAAWyG,GAAGjF,EAAGoc,gBAAiB,UAAWg3B,KAE3Crb,EAAIiJ,YACN0D,GAAe1kC,GAEjBqzC,GAAgBrzC,EAAI0E,EAAMsa,EAvEc,CAwE1C,EACAs0B,iBAAkB,SAAStzC,EAAIg5B,EAAYjB,GACzC,IAEIrzB,EAFAoiC,EAAS9N,EAAW8N,OACpBhiC,EAAS9E,EAAGoE,YAKX2zB,EAAIiJ,WAeEjJ,EAAIwB,WAAaP,EAAWT,UACnCR,EAAIE,YAAce,EAAWW,WAE/B5B,EAAIwB,aAAeP,EAAWT,SAC9BR,EAAIE,cAAgBe,EAAWW,UAC/Bn7B,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,SAAUuS,QAASpV,EAAIwB,WAAa,WAAaxB,EAAIE,YAAc,YAAc,KACjI0Q,GAAkB3oC,IAElB0kC,GAAe1kC,IArBf+3B,EAAIiJ,YAAa,EACjBjJ,EAAIwB,aAAeP,EAAWT,SAC9BR,EAAIE,cAAgBe,EAAWW,UAC/Bj1B,EAAO+lC,GACHzqC,EAAI,IAAIrB,EAAImG,EAAO/F,KAAM+F,EAAO9F,GAAK8nC,EAAS,IAClD/O,EAAI72B,IAAM,CACR4D,OAAQA,EACRJ,KAAMA,GAERlG,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,SAAUuS,QAASpV,EAAIwB,WAAa,WAAaxB,EAAIE,YAAc,YAAc,KACjI0Q,GAAkB3oC,GAClBkrC,GAAWlrC,EAAI+3B,EAAK,IAAK4T,GAAU7mC,EAAQJ,IAC3CwmC,GAAWlrC,EAAI+3B,EAAK,IAAK6T,GAAU9mC,EAAQJ,IAW/C,EACA6uC,sBAAuB,SAASvzC,EAAIwzC,EAAazb,GAC/C,IAAIkJ,EAAgBlJ,EAAIkJ,cAIxB,GAHIlJ,EAAIiJ,YACNyS,GAAoBzzC,EAAI+3B,GAEtBkJ,EAAe,CACjB,IAAIn8B,EAASm8B,EAAcyS,WAAWl/B,OAClC9P,EAAOu8B,EAAc0S,SAASn/B,OAClC,IAAK1P,IAAWJ,EAEd,OAEFqzB,EAAI72B,IAAM,CACR4D,OAAQA,EACRJ,KAAMA,GAERqzB,EAAIiJ,YAAa,EACjBjJ,EAAIwB,WAAa0H,EAAc1H,WAC/BxB,EAAIE,YAAcgJ,EAAchJ,YAChC0Q,GAAkB3oC,GAClBkrC,GAAWlrC,EAAI+3B,EAAK,IAAK4T,GAAU7mC,EAAQJ,IAC3CwmC,GAAWlrC,EAAI+3B,EAAK,IAAK6T,GAAU9mC,EAAQJ,IAC3ClG,EAAWwa,OAAOhZ,EAAI,kBAAmB,CACvC46B,KAAM,SACNuS,QAASpV,EAAIwB,WAAa,WACjBxB,EAAIE,YAAc,YAAc,IAC7C,CACF,EACAxkB,UAAW,SAASzT,EAAIg5B,EAAYjB,GAClC,IAAIyT,EAAUC,EACd,GAAI1T,EAAIiJ,WAAY,CAGlB,GAFAwK,EAAWxrC,EAAGoE,UAAU,UACxBqnC,EAASzrC,EAAGoE,UAAU,QAClB+mC,GAAeM,EAAQD,GAAW,CACpC,IAAIh1B,EAAMi1B,EACVA,EAASD,EACTA,EAAWh1B,CACb,CACAi1B,EAAOzsC,GAAK8sC,GAAW9rC,EAAIyrC,EAAO1sC,MAAQ,CAC5C,KAAO,CAEL,IAAI+nC,EAASpnC,KAAKwe,IAAI8a,EAAW8N,OAAQ,GACzC0E,EAAWxrC,EAAGoE,YACdqnC,EAAShB,GAAoBzqC,EAAI,IAAIrB,EAAI6sC,EAASzsC,KAAO+nC,EAAS,EAC7BmE,KACvC,CAEA,IADA,IAAI2I,EAAU,EACL7vC,EAAIynC,EAASzsC,KAAMgF,EAAI0nC,EAAO1sC,KAAMgF,IAAK,CAChD6vC,EAAU9H,GAAW9rC,EAAIwrC,EAASzsC,MAC9ByX,EAAM,IAAI7X,EAAI6sC,EAASzsC,KAAO,EACpB+sC,GAAW9rC,EAAIwrC,EAASzsC,KAAO,IAD7C,IAEIqB,EAAOJ,EAAGK,SAASmrC,EAAUh1B,GACjCpW,EAAO44B,EAAWY,WACdx5B,EAAKoiB,QAAQ,SAAU,IACvBpiB,EAAKoiB,QAAQ,SAAU,KAC3BxiB,EAAGS,aAAaL,EAAMorC,EAAUh1B,EAClC,CACA,IAAIq9B,EAAc,IAAIl1C,EAAI6sC,EAASzsC,KAAM60C,GACrC7b,EAAIiJ,YACN0D,GAAe1kC,GAAI,GAErBA,EAAGqG,UAAUwtC,EACf,EACAC,0BAA2B,SAAS9zC,EAAIg5B,EAAYjB,GAClDA,EAAIC,YAAa,EACjB,IAAIyB,EAAW+Q,GAAWxqC,EAAGoE,aAC7B,GAAIq1B,EAAS16B,OAASiB,EAAG4B,aAAgBo3B,EAAWl2B,MAI7C,CACL22B,EAAS16B,KAAQi6B,EAAgB,MAAIS,EAAS16B,KAC1C06B,EAAS16B,KAAO,EACpB06B,EAASz6B,GAAK8sC,GAAW9rC,EAAIy5B,EAAS16B,MACtCiB,EAAGqG,UAAUozB,GACb,IAAIsa,EAAYv1C,EAAWE,SAASs1C,iCAChCx1C,EAAWE,SAASkzC,iBACxBmC,EAAU/zC,EACZ,MAVEA,EAAGS,aAAa,KAAM,IAAI9B,EAAIqB,EAAG4B,YAAa,IAC9C5B,EAAGqG,UAAUrG,EAAG4B,YAAa,GAU/B+V,KAAKqlB,gBAAgBh9B,EAAI,CAAE8mC,OAAQ9N,EAAW8N,QAAU/O,EAC1D,EACAkc,MAAO,SAASj0C,EAAIg5B,EAAYjB,GAC9B,IAAItnB,EAAM+5B,GAAWxqC,EAAGoE,aACpBwkB,EAAWiW,EAAegD,mBAAmBQ,YAC7CrJ,EAAWoJ,cACXhiC,EAAOwoB,EAASwe,WACpB,GAAKhnC,EAAL,CAGA,GAAI44B,EAAWC,YAAa,CAC1B,IAAIib,EAAUl0C,EAAGoL,UAAU,WAEvB+oC,EAAmB,SAASh1C,GAC9B,IAAIi1C,EAAQj1C,EAAIoyB,MAAM,MAAMlyB,OAAS,EACjCg1C,EAAUl1C,EAAIoyB,MAAM,KAAKlyB,OAAS,EACtC,OAAO+0C,EAAOF,EAAmB,EAATG,CAC1B,EACIC,EAAct0C,EAAGuB,QAAQvB,EAAGoE,YAAYrF,MACxCyU,EAAS2gC,EAAiBG,EAAY7xC,MAAM,QAAQ,IAEpD8xC,EAAcn0C,EAAKoiB,QAAQ,MAAO,IAClCgyB,EAAap0C,IAASm0C,EACtBE,EAAcN,EAAiB/zC,EAAKqC,MAAM,QAAQ,IAClDrC,EAAOm0C,EAAY/xB,QAAQ,SAAU,SAASkyB,GAChD,IAAIC,EAAYnhC,GAAU2gC,EAAiBO,GAAUD,GACrD,GAAIE,EAAY,EACd,MAAO,GAEJ,GAAI30C,EAAGoL,UAAU,kBAAmB,CACvC,IAAIwpC,EAAWl1C,KAAKsc,MAAM24B,EAAYT,GACtC,OAAO/U,MAAMyV,EAAW,GAAG/uC,KAAK,KAClC,CAEE,OAAOs5B,MAAMwV,EAAY,GAAG9uC,KAAK,IAErC,GACAzF,GAAQo0C,EAAa,KAAO,EAC9B,CACA,GAAIxb,EAAW8N,OAAS,EAClB1mC,EAAO++B,MAAMnG,EAAW8N,OAAS,GAAGjhC,KAAKzF,GAE/C,IA0BIy0C,EACAC,EA3BAvc,EAAW3P,EAAS2P,SACpBoB,EAAY/Q,EAAS+Q,UACzB,GAAIA,EAAW,CACbv5B,EAAOA,EAAKmxB,MAAM,MACdgH,GACAn4B,EAAKP,MAET,IAAK,IAAIkE,EAAI,EAAGA,EAAI3D,EAAKf,OAAQ0E,IAC/B3D,EAAK2D,GAAiB,IAAX3D,EAAK2D,GAAY,IAAM3D,EAAK2D,GAEzC0M,EAAIzR,IAAMg6B,EAAWl2B,MAAQ,EAAI,EACjC2N,EAAIzR,GAAKU,KAAKC,IAAImsC,GAAW9rC,EAAIyQ,EAAI1R,MAAO0R,EAAIzR,GAClD,MAAWu5B,EACNR,EAAIiJ,WACL5gC,EAAO23B,EAAIwB,WAAan5B,EAAKsB,MAAM,GAAI,GAAK,KAAOtB,EAAKsB,MAAM,EAAGtB,EAAKf,OAAS,GAAK,KAC3E25B,EAAWl2B,OAGpB1C,EAAO,KAAOA,EAAKsB,MAAM,EAAGtB,EAAKf,OAAS,GAC1CoR,EAAIzR,GAAK8sC,GAAW9rC,EAAIyQ,EAAI1R,OAE5B0R,EAAIzR,GAAK,EAGXyR,EAAIzR,IAAMg6B,EAAWl2B,MAAQ,EAAI,EAInC,GAAIi1B,EAAIiJ,WAAY,CAGlB,IAAI+T,EADJhd,EAAImJ,eAAiB9gC,EAErB,IAAI40C,EAAeC,GAAqBj1C,EAAI+3B,GACxCqS,EAAiB4K,EAAa,GAC9B7K,EAAe6K,EAAa,GAC5BE,EAAel1C,EAAG+H,eAClBvD,EAAaxE,EAAGyE,iBAChB0wC,EAAe,IAAIhW,MAAM36B,EAAWnF,QAAQwG,KAAK,KAAK0rB,MAAM,KAE5DwG,EAAIkJ,gBACN8T,EAAsBhd,EAAIkJ,cAAc0S,SAASn/B,QAGnDqqB,EAAegD,mBAAmB4E,gBAAgBO,QAAQkO,GACtDvb,GAEF35B,EAAGwS,kBAAkB2iC,GAErBhL,EAAe,IAAIxrC,EAAIyrC,EAAerrC,KAAOqB,EAAKf,OAAO,EAAG+qC,EAAeprC,IAC3EgB,EAAGqG,UAAU+jC,GACbgL,GAAYp1C,EAAImqC,GAChBnqC,EAAGwS,kBAAkBpS,GACrBy0C,EAAczK,GACLrS,EAAIE,aACbj4B,EAAGwS,kBAAkB2iC,GACrBn1C,EAAGqG,UAAU+jC,GACbpqC,EAAGS,aAAaL,EAAMgqC,EAAgBA,GACtCyK,EAAczK,IAEdpqC,EAAGS,aAAaL,EAAMgqC,EAAgBD,GACtC0K,EAAc70C,EAAGq1C,aAAar1C,EAAGs1C,aAAalL,GAAkBhqC,EAAKf,OAAS,IAG7E01C,IACDhd,EAAIkJ,cAAc0S,SAAW3zC,EAAGqW,YAAY0+B,IAE1Cxc,IACFsc,EAAY71C,GAAG,EAEnB,MACE,GAAI26B,EAAW,CACb35B,EAAGqG,UAAUoK,GACb,IAAS1M,EAAI,EAAGA,EAAI3D,EAAKf,OAAQ0E,IAAK,CACpC,IAAIhF,EAAO0R,EAAI1R,KAAKgF,EAChBhF,EAAOiB,EAAG8B,YACZ9B,EAAGS,aAAa,KAAO,IAAI9B,EAAII,EAAM,IAEvC,IAAIw2C,EAASzJ,GAAW9rC,EAAIjB,GACxBw2C,EAAS9kC,EAAIzR,IACfw2C,GAAmBx1C,EAAIjB,EAAM0R,EAAIzR,GAErC,CACAgB,EAAGqG,UAAUoK,GACb2kC,GAAYp1C,EAAI,IAAIrB,EAAI8R,EAAI1R,KAAOqB,EAAKf,OAAO,EAAGoR,EAAIzR,KACtDgB,EAAGwS,kBAAkBpS,GACrBy0C,EAAcpkC,CAChB,MACEzQ,EAAGS,aAAaL,EAAMqQ,GAElB8nB,GAAYS,EAAWl2B,MACzB+xC,EAAc,IAAIl2C,EAClB8R,EAAI1R,KAAO,EACX0tC,GAAgCzsC,EAAGuB,QAAQkP,EAAI1R,KAAO,KAC7Cw5B,IAAaS,EAAWl2B,MACjC+xC,EAAc,IAAIl2C,EAChB8R,EAAI1R,KACJ0tC,GAAgCzsC,EAAGuB,QAAQkP,EAAI1R,SACvCw5B,GAAYS,EAAWl2B,OACjCgyC,EAAM90C,EAAGs1C,aAAa7kC,GACtBokC,EAAc70C,EAAGq1C,aAAaP,EAAM10C,EAAKf,OAAS,KAElDy1C,EAAM90C,EAAGs1C,aAAa7kC,GACtBokC,EAAc70C,EAAGq1C,aAAaP,EAAM10C,EAAKf,SAI3C04B,EAAIiJ,YACN0D,GAAe1kC,GAAI,GAErBA,EAAGqG,UAAUwuC,EA9Ib,CA+IF,EACAY,KAAM,SAASz1C,EAAIg5B,GACjBh5B,EAAG4N,UAAU,WACX8nC,GAAS11C,EAAIxB,EAAWE,SAAS+2C,KAAMzc,EAAW8N,OAAlD4O,GACA11C,EAAGqG,UAAUrG,EAAGoE,UAAU,UAC5B,EACF,EACAuxC,KAAM,SAAS31C,EAAIg5B,GACjB0c,GAAS11C,EAAIxB,EAAWE,SAASi3C,KAAM3c,EAAW8N,OAAlD4O,EACF,EACAE,YAAa,SAAS/I,EAAK7T,EAAYjB,GACrCA,EAAIyI,WAAW4B,aAAepJ,EAAW4I,iBAC3C,EACAl6B,QAAS,SAAS1H,EAAIg5B,EAAYjB,GAChC,IAAI8d,EAAW7c,EAAW4I,kBAC1BsJ,GAAWlrC,EAAI+3B,EAAK8d,EAAU71C,EAAGoE,YACnC,EACAoe,QAAS,SAASxiB,EAAIg5B,EAAYjB,GAChC,IAEI+d,EACArK,EAHAsK,EAAc/c,EAAW4I,kBACzB4J,EAAWxrC,EAAGoE,YAGdI,EAAaxE,EAAGyE,iBACpB,GAAIszB,EAAIiJ,WACNwK,EAAWxrC,EAAGoE,UAAU,SACxBqnC,EAASzrC,EAAGoE,UAAU,WACjB,CACL,IAAIrF,EAAOiB,EAAGuB,QAAQiqC,EAASzsC,MAC/B+2C,EAAYtK,EAASxsC,GAAKg6B,EAAW8N,OACjCgP,EAAY/2C,EAAKM,SACnBy2C,EAAU/2C,EAAKM,QAEjBosC,EAAS,IAAI9sC,EAAI6sC,EAASzsC,KAAM+2C,EAClC,CACA,GAAiB,MAAbC,EACGhe,EAAIiJ,YAAYhhC,EAAGS,aAAa,GAAI+qC,EAAUC,IAElDjtC,EAAWE,SAASs1C,iCAAmCx1C,EAAWE,SAASkzC,kBAAkB5xC,OACzF,CACL,IAAIg2C,EAAiBh2C,EAAGK,SAASmrC,EAAUC,GAG3C,GADAuK,EAAiBA,EAAexzB,QAAQ,SAAUuzB,GAC9Che,EAAIE,YAAa,CAEnB,IAAIoc,EAAS,IAAIlV,MAAMn/B,EAAGoL,UAAU,WAAW,GAAGvF,KAAK,KACvDmwC,EAAiBh2C,EAAG+H,eACpBiuC,EAAiBA,EAAexzB,QAAQ,MAAO6xB,GAAQ7xB,QAAQ,SAAUuzB,GAAaxkB,MAAM,MAC5FvxB,EAAGwS,kBAAkBwjC,EACvB,MACEh2C,EAAGS,aAAau1C,EAAgBxK,EAAUC,GAExC1T,EAAIiJ,YACNwK,EAAWL,GAAe3mC,EAAW,GAAGM,OAAQN,EAAW,GAAGE,MACjDF,EAAW,GAAGM,OAASN,EAAW,GAAGE,KAClD1E,EAAGqG,UAAUmlC,GACb9G,GAAe1kC,GAAI,IAEnBA,EAAGqG,UAAUy2B,GAAa2O,EAAQ,GAAI,GAE1C,CACF,EACAwK,qBAAsB,SAASj2C,EAAIg5B,GACjC,IAGIv2B,EACAM,EACAC,EACAkzC,EANAzlC,EAAMzQ,EAAGoE,YACT+xC,EAAUn2C,EAAGuB,QAAQkP,EAAI1R,MACzB0kB,EAAK,wCAKT,MAAsC,QAA9BhhB,EAAQghB,EAAG3P,KAAKqiC,IAGtB,GAFApzC,EAAQN,EAAMwkB,MACdjkB,EAAMD,EAAQN,EAAM,GAAGpD,OACnBoR,EAAIzR,GAAKgE,EAAI,MAEnB,IAAKg2B,EAAWgB,aAAch3B,GAAOyN,EAAIzR,MACrCyD,EAAJ,CACE,IAAI2zC,EAAU3zC,EAAM,IAAMA,EAAM,GAC5BY,EAASZ,EAAM,IAAMA,EAAM,GAC3Bk/B,EAAY3I,EAAWe,SAAW,GAAK,EACvCsc,EAAO,CAAC,KAAM,EAAG,EAAK,EAAG,GAAI,GAAI,KAAM,IAAID,EAAQ3rC,eACnD6rC,EAASvP,SAAStkC,EAAM,GAAKY,EAAQgzC,GAAS1U,EAAY3I,EAAW8N,OACzEoP,EAAYI,EAAOlP,SAASiP,GAC5B,IAAIE,EAAcH,EAAU,IAAIjX,MAAM97B,EAAOhE,OAAS62C,EAAU72C,OAAS,EAAIoD,EAAM,GAAGpD,QAAQwG,KAAK,KAAO,GAExGqwC,EAD0B,MAAxBA,EAAU9zC,OAAO,GACP,IAAMg0C,EAAUG,EAAcL,EAAUlzB,OAAO,GAE/CozB,EAAUG,EAAcL,EAEtC,IAAIj2C,EAAO,IAAItB,EAAI8R,EAAI1R,KAAMgE,GACzB7C,EAAK,IAAIvB,EAAI8R,EAAI1R,KAAMiE,GAC3BhD,EAAGS,aAAay1C,EAAWj2C,EAAMC,GAInCF,EAAGqG,UAAU,IAAI1H,EAAI8R,EAAI1R,KAAMgE,EAAQmzC,EAAU72C,OAAS,GAD1D,CAEF,EACAm3C,eAAgB,SAASx2C,EAAIg5B,EAAYjB,GACvC,IAAI2I,EAAqB3I,EAAI2I,mBAC7B,GAAKA,EAAL,CACA,IAAIoG,EAAS9N,EAAW8N,OACpBA,GAAU9N,EAAW4P,iBACvB7Q,EAAI2I,mBAAmBwH,eAAiBpB,EAExCA,EAAS/O,EAAI2I,mBAAmBwH,gBAAkBpB,EAEpD0P,GAAex2C,EAAI+3B,EAAK+O,GAAQ,EAPG,CAQrC,EACAtzB,OAAQ,SAASxT,EAAIg5B,GACnBh5B,EAAGiO,WAAWjO,EAAGoE,YAAYrF,KAAMi6B,EAAWI,YAChD,EACAuL,eAAgBA,IAGlB,SAASmB,GAAaje,EAAMzO,GAC1B2jB,GAAQlV,GAAQzO,CAClB,CAUA,SAASqxB,GAAoBzqC,EAAIyQ,GAC/B,IAAIsnB,EAAM/3B,EAAGsD,MAAMy0B,IACf0e,EAAmB1e,EAAIC,YAAcD,EAAIiJ,WACzCjiC,EAAOW,KAAKC,IAAID,KAAKwe,IAAIle,EAAG4B,YAAa6O,EAAI1R,MAAOiB,EAAG8B,YACvD40C,EAAQ5K,GAAW9rC,EAAIjB,GAAQ,IAAM03C,EACrCz3C,EAAKU,KAAKC,IAAID,KAAKwe,IAAI,EAAGzN,EAAIzR,IAAK03C,GACvC,OAAO,IAAI/3C,EAAII,EAAMC,EACvB,CACA,SAASypC,GAAS4I,GAChB,IAAI1rB,EAAM,CAAC,EACX,IAAK,IAAIlN,KAAQ44B,EACXA,EAAK9rC,eAAekT,KACtBkN,EAAIlN,GAAQ44B,EAAK54B,IAGrB,OAAOkN,CACT,CACA,SAASmX,GAAarsB,EAAKkmC,EAAYC,GAKrC,MAJ0B,kBAAfD,IACTC,EAAWD,EAAW33C,GACtB23C,EAAaA,EAAW53C,MAEnB,IAAIJ,EAAI8R,EAAI1R,KAAO43C,EAAYlmC,EAAIzR,GAAK43C,EACjD,CACA,SAAS/O,GAAe1P,EAAMxsB,EAAQoc,EAASyY,GAK7C,IADA,IAAI/9B,EAAOslC,EAAU,GAAID,EAAO,GACvB/jC,EAAI,EAAGA,EAAI4H,EAAOtM,OAAQ0E,IAAK,CACtC,IAAIqgC,EAAUz4B,EAAO5H,GACN,UAAXgkB,GAA0C,UAAnBqc,EAAQrc,SAC/Bqc,EAAQrc,SAAWqc,EAAQrc,SAAWA,GACtCyY,EAAWrb,UAA4B,UAAhBif,EAAQv3B,QAC7BpK,EAAQo0C,GAAa1e,EAAMiM,EAAQjM,SAC5B,WAAT11B,GAAsBslC,EAAQ3oC,KAAKglC,GAC1B,QAAT3hC,GAAmBqlC,EAAK1oC,KAAKglC,GACnC,CACA,MAAO,CACL2D,QAASA,EAAQ1oC,QAAU0oC,EAC3BD,KAAMA,EAAKzoC,QAAUyoC,EAEzB,CACA,SAAS+O,GAAaC,EAASC,GAC7B,GAAyB,eAArBA,EAAOr1C,OAAO,IAAsB,CAEtC,IAAIs1C,EAAYD,EAAO13C,OAAS,GAC5B43C,EAAgBH,EAAQp1C,MAAM,EAAGs1C,GACjCE,EAAeH,EAAOr1C,MAAM,EAAGs1C,GACnC,OAAOC,GAAiBC,GAAgBJ,EAAQz3C,OAAS23C,EAAY,OACvB,GAAvCE,EAAazlC,QAAQwlC,IAAsB,SACpD,CACE,OAAOH,GAAWC,EAAS,OACO,GAA3BA,EAAOtlC,QAAQqlC,IAAgB,SAE1C,CACA,SAAS7O,GAAS9P,GAChB,IAAI11B,EAAQ,gBAAgBqR,KAAKqkB,GAC7ByJ,EAAoBn/B,EAAQA,EAAM,GAAK01B,EAAKz2B,OAAO,GACvD,GAAIkgC,EAAkBviC,OAAS,EAC7B,OAAOuiC,GACL,IAAK,OACHA,EAAkB,KAClB,MACF,IAAK,UACHA,EAAkB,IAClB,MACF,QACEA,EAAkB,GAClB,MAGN,OAAOA,CACT,CACA,SAAS8T,GAAS11C,EAAIoZ,EAAI0tB,GACxB,OAAO,WACL,IAAK,IAAI/iC,EAAI,EAAGA,EAAI+iC,EAAQ/iC,IAC1BqV,EAAGpZ,EAEP,CACF,CACA,SAASwqC,GAAW/5B,GAClB,OAAO,IAAI9R,EAAI8R,EAAI1R,KAAM0R,EAAIzR,GAC/B,CACA,SAAS0gC,GAAYyX,EAAMC,GACzB,OAAOD,EAAKn4C,IAAMo4C,EAAKp4C,IAAMm4C,EAAKp4C,MAAQq4C,EAAKr4C,IACjD,CACA,SAASosC,GAAegM,EAAMC,GAC5B,OAAID,EAAKp4C,KAAOq4C,EAAKr4C,MAGjBo4C,EAAKp4C,MAAQq4C,EAAKr4C,MAAQo4C,EAAKn4C,GAAKo4C,EAAKp4C,EAI/C,CACA,SAAS2sC,GAAUwL,EAAMC,GAIvB,OAHI3uB,UAAUppB,OAAS,IACrB+3C,EAAOzL,GAAUjjB,WAAM/W,EAAWwtB,MAAMtd,UAAUngB,MAAMqiB,KAAK0E,UAAW,KAEnE0iB,GAAegM,EAAMC,GAAQD,EAAOC,CAC7C,CACA,SAASxL,GAAUuL,EAAMC,GAIvB,OAHI3uB,UAAUppB,OAAS,IACrB+3C,EAAOxL,GAAUljB,WAAM/W,EAAWwtB,MAAMtd,UAAUngB,MAAMqiB,KAAK0E,UAAW,KAEnE0iB,GAAegM,EAAMC,GAAQA,EAAOD,CAC7C,CACA,SAASvJ,GAAgBuJ,EAAMC,EAAMC,GAEnC,IAAIC,EAAcnM,GAAegM,EAAMC,GACnCG,EAAcpM,GAAeiM,EAAMC,GACvC,OAAOC,GAAeC,CACxB,CACA,SAASzL,GAAW9rC,EAAImwC,GACtB,OAAOnwC,EAAGuB,QAAQ4uC,GAAS9wC,MAC7B,CACA,SAASs3B,GAAK6gB,GACZ,OAAIA,EAAE7gB,KACG6gB,EAAE7gB,OAEJ6gB,EAAEh1B,QAAQ,aAAc,GACjC,CACA,SAASonB,GAAY4N,GACnB,OAAOA,EAAEh1B,QAAQ,4BAA6B,OAChD,CACA,SAASgzB,GAAmBx1C,EAAImwC,EAASx6B,GACvC,IAAIo4B,EAAQjC,GAAW9rC,EAAImwC,GACvBkE,EAAS,IAAIlV,MAAMxpB,EAAOo4B,EAAM,GAAGloC,KAAK,KAC5C7F,EAAGqG,UAAU,IAAI1H,EAAIwxC,EAASpC,IAC9B/tC,EAAGS,aAAa4zC,EAAQr0C,EAAGoE,YAC7B,CAOA,SAASgxC,GAAYp1C,EAAImqC,GACvB,IAAI3lC,EAAa,GAAI8J,EAAStO,EAAGyE,iBAC7BC,EAAO8lC,GAAWxqC,EAAG+B,QAAQooC,IAC7BsN,GAAa/X,GAAYyK,EAAczlC,GACvCgzC,EAAU13C,EAAGoE,UAAU,QACvBuzC,EAAYC,GAAStpC,EAAQopC,GAC7BG,EAAanY,GAAYpxB,EAAOqpC,GAAWjzC,KAAM4J,EAAOqpC,GAAW7yC,QACnEoZ,EAAM5P,EAAOjP,OAAS,EACtB4nB,EAAQ/I,EAAMy5B,EAAYA,EAAYz5B,EAAM,EAC5Cm4B,EAAO/nC,EAAO2Y,GAAOniB,OAErBlD,EAAYlC,KAAKC,IAAI02C,EAAKt3C,KAAM2F,EAAK3F,MACrC+C,EAAWpC,KAAKwe,IAAIm4B,EAAKt3C,KAAM2F,EAAK3F,MACpC+4C,EAASzB,EAAKr3C,GAAI+4C,EAASrzC,EAAK1F,GAEhC4B,EAAM0N,EAAO2Y,GAAOviB,KAAK1F,GAAK84C,EAC9BE,EAASD,EAASD,EAClBl3C,EAAM,GAAKo3C,GAAU,GACvBF,IACKL,GAAaM,KACTn3C,EAAM,GAAKo3C,GAAU,GAC9BF,IACKD,GAAcE,KACVn3C,EAAM,IAAgB,GAAXo3C,IACpBF,IACAC,KAEF,IAAK,IAAIh5C,EAAO6C,EAAW7C,GAAQ+C,EAAU/C,IAAQ,CACnD,IAAIqO,EAAQ,CAACtI,OAAQ,IAAInG,EAAII,EAAM+4C,GAASpzC,KAAM,IAAI/F,EAAII,EAAMg5C,IAChEvzC,EAAWpF,KAAKgO,EAClB,CAIA,OAHApN,EAAGkO,cAAc1J,GACjB2lC,EAAanrC,GAAK+4C,EAClB1B,EAAKr3C,GAAK84C,EACHzB,CACT,CACA,SAAShD,GAAgBrzC,EAAI0E,EAAMsa,GAEjC,IADA,IAAI9d,EAAM,GACD6C,EAAI,EAAGA,EAAIib,EAAQjb,IAAK,CAC/B,IAAIk0C,EAAWnb,GAAap4B,EAAMX,EAAG,GACrC7C,EAAI9B,KAAK,CAAC0F,OAAQmzC,EAAUvzC,KAAMuzC,GACpC,CACAj4C,EAAGkO,cAAchN,EAAK,EACxB,CAEA,SAAS02C,GAAStpC,EAAQ/J,EAAQvB,GAChC,IAAK,IAAIe,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IAAK,CACtC,IAAIm0C,EAAkB,QAAPl1C,GAAiB08B,GAAYpxB,EAAOvK,GAAGe,OAAQP,GAC1D4zC,EAAgB,UAAPn1C,GAAmB08B,GAAYpxB,EAAOvK,GAAGW,KAAMH,GAC5D,GAAI2zC,GAAYC,EACd,OAAOp0C,CAEX,CACA,OAAQ,CACV,CACA,SAASkxC,GAAqBj1C,EAAI+3B,GAChC,IAAIkJ,EAAgBlJ,EAAIkJ,cACpBmX,EAA8B,WAChC,IAAI5zC,EAAaxE,EAAGyE,iBAChB1B,EAASyB,EAAW,GACpBxB,EAAMwB,EAAWA,EAAWnF,OAAO,GACnC+qC,EAAiBe,GAAepoC,EAAM+B,OAAQ/B,EAAM2B,MAAQ3B,EAAM+B,OAAS/B,EAAM2B,KACjFylC,EAAegB,GAAenoC,EAAI8B,OAAQ9B,EAAI0B,MAAQ1B,EAAI0B,KAAO1B,EAAI8B,OACzE,MAAO,CAACslC,EAAgBD,EAC1B,EACIkO,EAA2B,WAC7B,IAAIjO,EAAiBpqC,EAAGoE,YACpB+lC,EAAenqC,EAAGoE,YAClBykB,EAAQoY,EAAchJ,YAC1B,GAAIpP,EAAO,CACT,IAAI9hB,EAAQ8hB,EAAM9hB,MACdiY,EAAS6J,EAAM7J,OACnBmrB,EAAe,IAAIxrC,EAAIyrC,EAAerrC,KAAOigB,EAAQorB,EAAeprC,GAAK+H,GAIzE,IAHA,IAAIvC,EAAa,GAGRT,EAAIqmC,EAAerrC,KAAMgF,EAAIomC,EAAaprC,KAAMgF,IAAK,CAC5D,IAAIe,EAAS,IAAInG,EAAIoF,EAAGqmC,EAAeprC,IACnC0F,EAAO,IAAI/F,EAAIoF,EAAGomC,EAAanrC,IAC/BoO,EAAQ,CAACtI,OAAQA,EAAQJ,KAAMA,GACnCF,EAAWpF,KAAKgO,EAClB,CACApN,EAAGkO,cAAc1J,EACnB,KAAO,CACL,IAAIzB,EAAQk+B,EAAcyS,WAAWl/B,OACjCxR,EAAMi+B,EAAc0S,SAASn/B,OAC7BzV,EAAOiE,EAAIjE,KAAOgE,EAAMhE,KACxBC,EAAKgE,EAAIhE,GAAK+D,EAAM/D,GACxBmrC,EAAe,CAACprC,KAAMorC,EAAaprC,KAAOA,EAAMC,GAAID,EAAOorC,EAAanrC,GAAKA,EAAKmrC,EAAanrC,IAC3FiiC,EAAc1H,aAChB6Q,EAAiB,IAAIzrC,EAAIyrC,EAAerrC,KAAM,GAC9CorC,EAAe,IAAIxrC,EAAIwrC,EAAaprC,KAAM+sC,GAAW9rC,EAAImqC,EAAaprC,QAExEiB,EAAGiI,aAAamiC,EAAgBD,EAClC,CACA,MAAO,CAACC,EAAgBD,EAC1B,EACA,OAAKpS,EAAIiJ,WAIAoX,IAFAC,GAIX,CAGA,SAAS5E,GAAoBzzC,EAAI+3B,GAC/B,IAAIjzB,EAASizB,EAAI72B,IAAI4D,OACjBJ,EAAOqzB,EAAI72B,IAAIwD,KAEfqzB,EAAImJ,iBACNx8B,EAAO1E,EAAGq1C,aAAar1C,EAAGs1C,aAAaxwC,GAAUizB,EAAImJ,eAAe7hC,QACpE04B,EAAImJ,eAAiB,MAEvBnJ,EAAIkJ,cAAgB,CAAC,WAAcjhC,EAAGqW,YAAYvR,GAC7B,SAAY9E,EAAGqW,YAAY3R,GAC3B,OAAU8lC,GAAW1lC,GACrB,KAAQ0lC,GAAW9lC,GACnB,WAAcqzB,EAAIiJ,WAClB,WAAcjJ,EAAIwB,WAClB,YAAexB,EAAIE,YAC1C,CACA,SAAS6Y,GAAgB9wC,EAAI+C,EAAOC,GAClC,IAGIwT,EAHAtV,EAAMlB,EAAGsD,MAAMy0B,IAAI72B,IACnBwD,EAAOxD,EAAIwD,KACXI,EAAS5D,EAAI4D,OAkBjB,OAhBIqmC,GAAenoC,EAAKD,KACtByT,EAAMxT,EACNA,EAAMD,EACNA,EAAQyT,GAEN20B,GAAezmC,EAAMI,IACvBJ,EAAOinC,GAAU5oC,EAAO2B,GACxBI,EAAS8mC,GAAU9mC,EAAQ9B,KAE3B8B,EAAS6mC,GAAU5oC,EAAO+B,GAC1BJ,EAAOknC,GAAUlnC,EAAM1B,GACvB0B,EAAOo4B,GAAap4B,EAAM,GAAI,IACd,GAAZA,EAAK1F,IAAY0F,EAAK3F,MAAQiB,EAAG4B,cACnC8C,EAAO,IAAI/F,EAAI+F,EAAK3F,KAAO,EAAG+sC,GAAW9rC,EAAI0E,EAAK3F,KAAO,MAGtD,CAAC+F,EAAQJ,EAClB,CAKA,SAASikC,GAAkB3oC,EAAIkB,EAAK05B,GAClC,IAAI7C,EAAM/3B,EAAGsD,MAAMy0B,IACnB72B,EAAMA,GAAO62B,EAAI72B,IACb05B,EAAOA,GACT7C,EAAIwB,WAAa,OAASxB,EAAIE,YAAc,QAAU,OADxD,IAEIyT,EAAQG,GAAgB7rC,EAAIkB,EAAK05B,GACrC56B,EAAGkO,cAAcw9B,EAAMp9B,OAAQo9B,EAAMQ,QACvC,CACA,SAASL,GAAgB7rC,EAAIkB,EAAK05B,EAAMqR,GACtC,IAAIvnC,EAAO8lC,GAAWtpC,EAAIwD,MACtBI,EAAS0lC,GAAWtpC,EAAI4D,QAC5B,GAAY,QAAR81B,EAAgB,CAClB,IAAI0d,EAAcrM,GAAcd,GAAejqC,EAAIwD,KAAMxD,EAAI4D,QAAc,EAAJ,EACnEyzC,EAAepN,GAAejqC,EAAIwD,KAAMxD,EAAI4D,QAAU,EAAI,EAG9D,OAFAJ,EAAOo4B,GAAa57B,EAAIwD,KAAM,EAAG4zC,GACjCxzC,EAASg4B,GAAa57B,EAAI4D,OAAQ,EAAGyzC,GAC9B,CACLjqC,OAAQ,CAAC,CAACxJ,OAAQA,EAAQJ,KAAMA,IAChCwnC,QAAS,EAEb,CAAO,GAAY,QAARtR,EAAgB,CACzB,GAAKuQ,GAAejqC,EAAIwD,KAAMxD,EAAI4D,QAShCJ,EAAK1F,GAAK,EACV8F,EAAO9F,GAAK8sC,GAAW9rC,EAAI8E,EAAO/F,UAVO,CACzC+F,EAAO9F,GAAK,EAEZ,IAAI8C,EAAW9B,EAAG8B,WACd4C,EAAK3F,KAAO+C,IACd4C,EAAK3F,KAAO+C,GAEd4C,EAAK1F,GAAK8sC,GAAW9rC,EAAI0E,EAAK3F,KAChC,CAIA,MAAO,CACLuP,OAAQ,CAAC,CAACxJ,OAAQA,EAAQJ,KAAMA,IAChCwnC,QAAS,EAEb,CAAO,GAAY,SAARtR,EAAiB,CAC1B,IAAItrB,EAAM5P,KAAKC,IAAImF,EAAO/F,KAAM2F,EAAK3F,MACjCy5C,EAAS1zC,EAAO9F,GAChBoI,EAAS1H,KAAKwe,IAAIpZ,EAAO/F,KAAM2F,EAAK3F,MACpC05C,EAAO/zC,EAAK1F,GACZw5C,EAASC,EAAQA,GAAQ,EACtBD,GAAU,EAGjB,IAH6B,IAAIx5B,EAAS5X,EAASkI,EAAM,EACrD48B,EAAUxnC,EAAK3F,MAAQuQ,EAAM,EAAI0P,EAAS,EAC1C1Q,EAAS,GACJvK,EAAI,EAAGA,EAAIib,EAAQjb,IAC1BuK,EAAOlP,KAAK,CACV0F,OAAQ,IAAInG,EAAI2Q,EAAMvL,EAAGy0C,GACzB9zC,KAAM,IAAI/F,EAAI2Q,EAAMvL,EAAG00C,KAG3B,MAAO,CACLnqC,OAAQA,EACR49B,QAASA,EAEb,CACF,CACA,SAASwM,GAAQ14C,GACf,IAAIyQ,EAAMzQ,EAAGoE,UAAU,QAMvB,OALgC,GAA5BpE,EAAG+H,eAAe1I,SAGpBoR,EAAMk7B,GAAUl7B,EAAKzQ,EAAGoE,UAAU,YAE7BqM,CACT,CAOA,SAASi0B,GAAe1kC,EAAI24C,GAC1B,IAAI5gB,EAAM/3B,EAAGsD,MAAMy0B,KACF,IAAb4gB,GACF34C,EAAGqG,UAAUokC,GAAoBzqC,EAAI+3B,EAAI72B,IAAIwD,OAE/C+uC,GAAoBzzC,EAAI+3B,GACxBA,EAAIiJ,YAAa,EACjBjJ,EAAIwB,YAAa,EACjBxB,EAAIE,aAAc,EACbF,EAAIC,YAAYx5B,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,UACvE,CAMA,SAASoR,GAAWhsC,EAAIwrC,EAAUC,GAChC,IAAI5mC,EAAY7E,EAAGK,SAASmrC,EAAUC,GAEtC,GAAI,SAAShqC,KAAKoD,GAAY,CAC5B,IAAIoN,EAAQpN,EAAU0sB,MAAM,MAE5Btf,EAAMpS,MAQN,IAAK,IAAId,EAAOkT,EAAMpS,MAAOoS,EAAM5S,OAAS,GAAKN,GAAQm/B,EAAmBn/B,GAAOA,EAAOkT,EAAMpS,MAC9F4rC,EAAO1sC,OACP0sC,EAAOzsC,GAAK,EAGVD,GACF0sC,EAAO1sC,OACP0sC,EAAOzsC,GAAK8sC,GAAW9rC,EAAIyrC,EAAO1sC,OAElC0sC,EAAOzsC,GAAK,CAEhB,CACF,CAGA,SAAS+sC,GAAsBc,EAAKrB,EAAUC,GAC5CD,EAASxsC,GAAK,EACdysC,EAAOzsC,GAAK,EACZysC,EAAO1sC,MACT,CAEA,SAAS0tC,GAAgCrsC,GACvC,IAAKA,EACH,OAAO,EAET,IAAIw4C,EAAax4C,EAAKmK,OAAO,MAC7B,OAAsB,GAAfquC,EAAmBx4C,EAAKf,OAASu5C,CAC1C,CAEA,SAASlP,GAAsB1pC,EAAI24B,EAAWkgB,EAAUngB,EAASogB,GAC/D,IAAIroC,EAAMioC,GAAQ14C,GACdjB,EAAOiB,EAAGuB,QAAQkP,EAAI1R,MACtB+1C,EAAMrkC,EAAIzR,GAIVyC,EAAOq3C,EAAW5b,EAAa,GAAKC,EAAiB,GACzD,OAAQ17B,EAAK1C,EAAKqD,OAAO0yC,IAEvB,GADAA,IACIA,GAAO/1C,EAAKM,OAAU,OAAO,KAG/Bq5B,EACFj3B,EAAO07B,EAAgB,IAEvB17B,EAAOy7B,EAAa,GACfz7B,EAAK1C,EAAKqD,OAAO0yC,MACpBrzC,EAAOy7B,EAAa,KAIxB,IAAIl6B,EAAM8xC,EAAK/xC,EAAQ+xC,EACvB,MAAOrzC,EAAK1C,EAAKqD,OAAOY,KAASA,EAAMjE,EAAKM,OAAU2D,IACtD,MAAOvB,EAAK1C,EAAKqD,OAAOW,KAAWA,GAAS,EAAKA,IAGjD,GAFAA,IAEI41B,EAAW,CAGb,IAAIF,EAAUz1B,EACd,MAAO,KAAKvB,KAAK1C,EAAKqD,OAAOY,KAASA,EAAMjE,EAAKM,OAAU2D,IAC3D,GAAIy1B,GAAWz1B,EAAK,CAClB,IAAI+1C,EAAYh2C,EAChB,MAAO,KAAKtB,KAAK1C,EAAKqD,OAAOW,EAAQ,KAAOA,EAAQ,EAAKA,IACpDA,IAASA,EAAQg2C,EACxB,CACF,CACA,MAAO,CAAEh2C,MAAO,IAAIpE,EAAI8R,EAAI1R,KAAMgE,GAAQC,IAAK,IAAIrE,EAAI8R,EAAI1R,KAAMiE,GACnE,CA4BA,SAAS4tC,GAAqB5wC,EAAI0E,EAAMi0B,GACtC,IAAIloB,EAAM/L,EACV,IAAKlG,EAAWw6C,kBAAoBx6C,EAAWy6C,iBAC7C,MAAO,CAAEl2C,MAAO0N,EAAKzN,IAAKyN,GAG5B,IAAIyoC,EAAO16C,EAAWw6C,gBAAgBh5C,EAAI0E,IAASlG,EAAWy6C,iBAAiBj5C,EAAI0E,GACnF,OAAKw0C,GAASA,EAAKC,MAASD,EAAKpgC,MAI7B6f,EACK,CAAE51B,MAAOm2C,EAAKC,KAAKl5C,KAAM+C,IAAKk2C,EAAKpgC,MAAM5Y,IAE3C,CAAE6C,MAAOm2C,EAAKC,KAAKj5C,GAAI8C,IAAKk2C,EAAKpgC,MAAM7Y,MANrC,CAAE8C,MAAO0N,EAAKzN,IAAKyN,EAO9B,CAEA,SAASu6B,GAAmBhrC,EAAIo/B,EAAQC,GACjCK,GAAYN,EAAQC,IACvBR,EAAe2C,SAASljC,IAAI0B,EAAIo/B,EAAQC,EAE5C,CAEA,SAASoQ,GAA0B9N,EAAW0P,GAC1CxS,EAAe6C,oBAAoBC,UAAYA,EAC/C9C,EAAe6C,oBAAoBh/B,QAAU2uC,EAAK3uC,QAClDm8B,EAAe6C,oBAAoBE,kBAAoByP,EAAKzP,iBAChE,CAEA,IAAIwX,GAAe,CACf,IAAK,UAAW,IAAK,UAAW,IAAK,UAAW,IAAK,UACrD,IAAK,UAAW,IAAK,UACrB,IAAK,UAAW,IAAK,UACrB,EAAK,SAAU,EAAK,SACpB,IAAK,cAELC,GAAkB,CACpBjyB,QAAS,CACPkyB,WAAY,SAASh2C,GACnB,GAAIA,EAAMi2C,SAAWj2C,EAAMk2C,MAEzB,GADAl2C,EAAM4jB,QACF5jB,EAAM4jB,OAAS,EAAE,OAAO,OACnB5jB,EAAMi2C,SAAWj2C,EAAMm2C,aAChCn2C,EAAM4jB,QAER,OAAO,CACT,GAEFwyB,QAAS,CACPC,KAAM,SAASr2C,GACbA,EAAMs2C,gBAAiB,EACvBt2C,EAAMk2C,MAAQl2C,EAAMZ,QAAU,IAAM,OAASY,EAAMk2C,KAAO,IAAM,GAClE,EACAF,WAAY,SAASh2C,GACnB,OAAuB,IAAhBA,EAAM2jB,OAAe3jB,EAAMi2C,SAAWj2C,EAAMk2C,IACrD,GAEFK,QAAS,CACPP,WAAY,SAASh2C,GACnB,IAAIqN,EAAyB,MAAjBrN,EAAMiyC,QAAmC,MAAjBjyC,EAAMi2C,OAE1C,OADAj2C,EAAMiyC,OAASjyC,EAAMi2C,OACd5oC,CACT,GAKFmpC,OAAQ,CACNH,KAAM,SAASr2C,GACbA,EAAMk2C,KAAuB,MAAfl2C,EAAMk2C,KAAe,IAAM,IACzCl2C,EAAMm2C,YAA6B,MAAfn2C,EAAMk2C,KAAe,IAAM,GACjD,EACAF,WAAY,SAASh2C,GACnB,OAAIA,EAAMi2C,SAAWj2C,EAAMk2C,IAE7B,GAEFO,WAAY,CACVJ,KAAM,SAASr2C,GACbA,EAAM2jB,MAAQ,CAChB,EACAqyB,WAAY,SAASh2C,GACnB,GAAqB,MAAjBA,EAAMi2C,OAAgB,CACxB,IAAI32C,EAAQU,EAAMysC,SAASttC,MAAM,WAAW,GAC5C,GAAc,UAAVG,EAAmB,CACrB,GAAIU,EAAMZ,SAA2B,IAAhBY,EAAM4jB,MACzB,OAAO,EAET5jB,EAAM4jB,OACR,MAAO,GAAc,OAAVtkB,EAAgB,CACzB,IAAKU,EAAMZ,SAA2B,IAAhBY,EAAM4jB,MAC1B,OAAO,EAET5jB,EAAM4jB,OACR,CACA,GAAc,SAAVtkB,GAAoC,IAAhBU,EAAM4jB,MAAY,OAAO,CACnD,CACA,OAAO,CACT,IAGJ,SAASyoB,GAAW3vC,EAAI8mC,EAAQpkC,EAAS82C,GACvC,IAAI/oC,EAAM+5B,GAAWxqC,EAAGoE,aACpBu9B,EAAYj/B,EAAU,GAAK,EAC3BihB,EAAUjhB,EAAU1C,EAAGg6C,aAAe,EACtCC,EAAQxpC,EAAIzR,GACZD,EAAO0R,EAAI1R,KACXgxC,EAAW/vC,EAAGuB,QAAQxC,GACtBuE,EAAQ,CACVysC,SAAUA,EACVwJ,OAAQxJ,EAAS3tC,OAAO63C,GACxB1E,OAAQ,KACRtuB,MAAOgzB,EACPT,KAAMA,EACNC,aAAc/2C,EAAW,CAAE,IAAK,IAAK,IAAK,KAAQ,CAAE,IAAK,IAAK,IAAK,MAAO82C,GAC1E92C,QAASA,EACTwkB,MAAO,EACP0yB,gBAAgB,GAEdhf,EAAOwe,GAAaI,GACxB,IAAK5e,EAAK,OAAOnqB,EACjB,IAAIkpC,EAAON,GAAgBze,GAAM+e,KAC7BL,EAAaD,GAAgBze,GAAM0e,WACnCK,GAAQA,EAAKr2C,GACjB,MAAOvE,IAAS4kB,GAAWmjB,EAAQ,CAGjC,GAFAxjC,EAAM2jB,OAAS0a,EACfr+B,EAAMi2C,OAASj2C,EAAMysC,SAAS3tC,OAAOkB,EAAM2jB,QACtC3jB,EAAMi2C,OAAQ,CAGjB,GAFAx6C,GAAQ4iC,EACRr+B,EAAMysC,SAAW/vC,EAAGuB,QAAQxC,IAAS,GACjC4iC,EAAY,EACdr+B,EAAM2jB,MAAQ,MACT,CACL,IAAIizB,EAAU52C,EAAMysC,SAAS1wC,OAC7BiE,EAAM2jB,MAASizB,EAAU,EAAMA,EAAQ,EAAK,CAC9C,CACA52C,EAAMi2C,OAASj2C,EAAMysC,SAAS3tC,OAAOkB,EAAM2jB,MAC7C,CACIqyB,EAAWh2C,KACbmN,EAAI1R,KAAOA,EACX0R,EAAIzR,GAAKsE,EAAM2jB,MACf6f,IAEJ,CACA,OAAIxjC,EAAMi2C,QAAUj2C,EAAMs2C,eACjB,IAAIj7C,EAAII,EAAMuE,EAAM2jB,OAEtBxW,CACT,CAmBA,SAAS0pC,GAASn6C,EAAIyQ,EAAK/N,EAASg2B,EAAS0hB,GAC3C,IAAIjK,EAAU1/B,EAAI1R,KACduB,EAAMmQ,EAAIzR,GACVD,EAAOiB,EAAGuB,QAAQ4uC,GAClBvvC,EAAM8B,EAAU,GAAK,EACrB23C,EAAY3hB,EAAUyE,EAAiBD,EAE3C,GAAIkd,GAA2B,IAARr7C,EAAY,CAGjC,GAFAoxC,GAAWvvC,EACX7B,EAAOiB,EAAGuB,QAAQ4uC,IACbrS,EAAO99B,EAAImwC,GACd,OAAO,KAET7vC,EAAM,EAAY,EAAIvB,EAAKM,MAC7B,CAEA,MAAO,EAAM,CACX,GAAI+6C,GAA2B,IAARr7C,EACrB,MAAO,CAAEkB,KAAM,EAAGC,GAAI,EAAGnB,KAAMoxC,GAEjC,IAAImK,EAAQ15C,EAAM,EAAK7B,EAAKM,QAAU,EAClC05C,EAAYuB,EAAM7hB,EAAU6hB,EAEhC,MAAOh6C,GAAOg6C,EAAM,CAElB,IADA,IAAIC,GAAY,EACPx2C,EAAI,EAAGA,EAAIs2C,EAAUh7C,SAAWk7C,IAAax2C,EACpD,GAAIs2C,EAAUt2C,GAAGhF,EAAKqD,OAAO9B,IAAO,CAClCy4C,EAAYz4C,EAEZ,MAAOA,GAAOg6C,GAAQD,EAAUt2C,GAAGhF,EAAKqD,OAAO9B,IAC7CA,GAAOM,EAIT,GAFA63B,EAAUn4B,EACVi6C,EAAYxB,GAAatgB,EACrBsgB,GAAatoC,EAAIzR,IAAMmxC,GAAW1/B,EAAI1R,MACtC05B,GAAWsgB,EAAYn4C,EAEzB,SAEA,MAAO,CACLX,KAAMP,KAAKC,IAAIo5C,EAAWtgB,EAAU,GACpCv4B,GAAIR,KAAKwe,IAAI66B,EAAWtgB,GACxB15B,KAAMoxC,EAEZ,CAEGoK,IACHj6C,GAAOM,EAEX,CAGA,GADAuvC,GAAWvvC,GACNk9B,EAAO99B,EAAImwC,GACd,OAAO,KAETpxC,EAAOiB,EAAGuB,QAAQ4uC,GAClB7vC,EAAOM,EAAM,EAAK,EAAI7B,EAAKM,MAC7B,CACF,CAcA,SAASiwC,GAAWtvC,EAAIyQ,EAAKq2B,EAAQpkC,EAAS+1B,EAASC,GACrD,IAAI8S,EAAWhB,GAAW/5B,GACtB4Q,EAAQ,IACR3e,IAAY+1B,IAAY/1B,GAAW+1B,IACrCqO,IAIF,IADA,IAAIsT,IAAoB13C,GAAW+1B,GAC1B10B,EAAI,EAAGA,EAAI+iC,EAAQ/iC,IAAK,CAC/B,IAAIqK,EAAO+rC,GAASn6C,EAAIyQ,EAAK/N,EAASg2B,EAAS0hB,GAC/C,IAAKhsC,EAAM,CACT,IAAIosC,EAAQ1O,GAAW9rC,EAAIA,EAAG8B,YAC9Buf,EAAMjiB,KAAKsD,EACL,CAAC3D,KAAMiB,EAAG8B,WAAY7B,KAAMu6C,EAAOt6C,GAAIs6C,GACvC,CAACz7C,KAAM,EAAGkB,KAAM,EAAGC,GAAI,IAC7B,KACF,CACAmhB,EAAMjiB,KAAKgP,GACXqC,EAAM,IAAI9R,EAAIyP,EAAKrP,KAAM2D,EAAW0L,EAAKlO,GAAK,EAAKkO,EAAKnO,KAC1D,CACA,IAAIw6C,EAAep5B,EAAMhiB,QAAUynC,EAC/B4T,EAAYr5B,EAAM,GAClBs5B,EAAWt5B,EAAMxhB,MACrB,OAAI6C,IAAY+1B,GAETgiB,GAAiBC,EAAUz6C,MAAQurC,EAASxsC,IAAM07C,EAAU37C,MAAQysC,EAASzsC,OAEhF47C,EAAWt5B,EAAMxhB,OAEZ,IAAIlB,EAAIg8C,EAAS57C,KAAM47C,EAAS16C,OAC9ByC,GAAW+1B,EACb,IAAI95B,EAAIg8C,EAAS57C,KAAM47C,EAASz6C,GAAK,IAClCwC,GAAW+1B,GAEhBgiB,GAAiBC,EAAUx6C,IAAMsrC,EAASxsC,IAAM07C,EAAU37C,MAAQysC,EAASzsC,OAE9E47C,EAAWt5B,EAAMxhB,OAEZ,IAAIlB,EAAIg8C,EAAS57C,KAAM47C,EAASz6C,KAGhC,IAAIvB,EAAIg8C,EAAS57C,KAAM47C,EAAS16C,KAE3C,CAEA,SAASkuC,GAAUnuC,EAAI0E,EAAM4zB,EAAYP,EAAK6iB,GAC5C,IAAInqC,EAAM/L,EACNm2C,EAAQ,IAAIl8C,EAAI8R,EAAI1R,KAAOu5B,EAAWwO,OAAS,EAAGmE,KAClDjoC,EAAIhD,EAAG+B,QAAQ84C,GAMnB,OALA73C,EAAIhE,KACC47C,IACH7iB,EAAI6I,SAAWqK,IACflT,EAAI8I,UAAY7gC,EAAGuuC,WAAWvrC,EAAI,OAAO2L,MAEpCksC,CACT,CAEA,SAASrL,GAAgBxvC,EAAI8mC,EAAQpkC,EAASslC,GAI5C,IAHA,IAEI8M,EAFArkC,EAAMzQ,EAAGoE,YACTrB,EAAQ0N,EAAIzR,GAEP+E,EAAI,EAAGA,EAAI+iC,EAAQ/iC,IAAM,CAChC,IAAIhF,EAAOiB,EAAGuB,QAAQkP,EAAI1R,MAE1B,GADA+1C,EAAMgG,GAAc/3C,EAAOhE,EAAMipC,EAAWtlC,GAAS,IACzC,GAARoyC,EACF,OAAO,KAET/xC,EAAQ+xC,CACV,CACA,OAAO,IAAIn2C,EAAIqB,EAAGoE,YAAYrF,KAAM+1C,EACtC,CAEA,SAAS5G,GAAaluC,EAAI8mC,GAGxB,IAAI/nC,EAAOiB,EAAGoE,YAAYrF,KAC1B,OAAO0rC,GAAoBzqC,EAAI,IAAIrB,EAAII,EAAM+nC,EAAS,GACxD,CAEA,SAASoE,GAAWlrC,EAAI+3B,EAAK8d,EAAUv1C,GAChC89B,EAAQyX,EAAUlY,KAGnB5F,EAAI1jB,MAAMwhC,IACZ9d,EAAI1jB,MAAMwhC,GAAU7gC,QAEtB+iB,EAAI1jB,MAAMwhC,GAAY71C,EAAGqW,YAAY/V,GACvC,CAEA,SAASw6C,GAAc/3C,EAAOhE,EAAMipC,EAAWtlC,EAASq4C,GAMtD,IAAIjG,EAYJ,OAXIpyC,GACFoyC,EAAM/1C,EAAK0S,QAAQu2B,EAAWjlC,EAAQ,IAC1B,GAAR+xC,GAAciG,IAChBjG,GAAO,KAGTA,EAAM/1C,EAAK8kB,YAAYmkB,EAAWjlC,EAAQ,IAC9B,GAAR+xC,GAAciG,IAChBjG,GAAO,IAGJA,CACT,CAEA,SAAS9F,GAAchvC,EAAI0E,EAAMoiC,EAAQlmC,EAAK+3B,GAC5C,IAGI51B,EAAOC,EAHPjE,EAAO2F,EAAK3F,KACZY,EAAMK,EAAG4B,YACTsc,EAAMle,EAAG8B,WACGiC,EAAIhF,EACpB,SAASi8C,EAAQj3C,GAAK,OAAQ/D,EAAGuB,QAAQwC,EAAI,CAC7C,SAASk3C,EAAWl3C,EAAGnD,EAAKs6C,GAC1B,OAAIA,EAAcF,EAAQj3C,IAAMi3C,EAAQj3C,EAAInD,IACpCo6C,EAAQj3C,IAAMi3C,EAAQj3C,EAAInD,EACpC,CACA,GAAIA,EAAK,CACP,MAAOjB,GAAOoE,GAAKA,GAAKma,GAAO4oB,EAAS,EAClCmU,EAAWl3C,EAAGnD,IAAQkmC,IAC1B/iC,GAAKnD,EAEP,OAAO,IAAIjC,EAAIoF,EAAG,EACpB,CAEA,IAAIg0B,EAAM/3B,EAAGsD,MAAMy0B,IACnB,GAAIA,EAAIwB,YAAc0hB,EAAWl8C,EAAM,GAAG,GAAO,CAC/C,IAAI+F,EAASizB,EAAI72B,IAAI4D,OACjBm2C,EAAWn2C,EAAO/F,MAAO,GAAG,KACzB45B,GAAa7zB,EAAO/F,MAAQA,IAC/BA,GAAQ,GAGd,CACA,IAAI6vB,EAAaosB,EAAQj8C,GACzB,IAAKgF,EAAIhF,EAAMgF,GAAKma,GAAO4oB,EAAQ/iC,IAC7Bk3C,EAAWl3C,EAAG,GAAG,KACd40B,GAAaqiB,EAAQj3C,IAAM6qB,GAC9BkY,KAQN,IAJA9jC,EAAM,IAAIrE,EAAIoF,EAAG,GAEbA,EAAIma,IAAQ0Q,EAAcA,GAAa,EACpC+J,GAAY,EACd50B,EAAIhF,EAAMgF,EAAIpE,EAAKoE,IACtB,KAAK40B,GAAaqiB,EAAQj3C,IAAM6qB,GAAc7qB,GAAKhF,IAC7Ck8C,EAAWl3C,GAAI,GAAG,GAAS,MAInC,OADAhB,EAAQ,IAAIpE,EAAIoF,EAAG,GACZ,CAAEhB,MAAOA,EAAOC,IAAKA,EAC9B,CACF,SAAS6tC,GAAY7wC,EAAIyQ,EAAKq2B,EAAQlmC,EAAK+3B,GAazC,SAASwiB,EAASC,GACZA,EAAK96C,IAAM86C,EAAKx6C,IAAM,GAAKw6C,EAAK96C,IAAM86C,EAAKx6C,KAAOw6C,EAAKr8C,KAAKM,OAC5D+7C,EAAKr8C,KAAO,KAGdq8C,EAAK96C,KAAO86C,EAAKx6C,GAErB,CAKA,SAAS8B,EAAQ1C,EAAIq7C,EAAI/6C,EAAKM,GAC5B,IAAI7B,EAAOiB,EAAGuB,QAAQ85C,GAElBD,EAAO,CACTr8C,KAAMA,EACNs8C,GAAIA,EACJ/6C,IAAKA,EACLM,IAAKA,GAGP,GAAkB,KAAdw6C,EAAKr8C,KACP,MAAO,CAAEs8C,GAAID,EAAKC,GAAI/6C,IAAK86C,EAAK96C,KAGlC,IAAIg7C,EAAkBF,EAAK96C,IAG3B66C,EAASC,GAET,MAAqB,OAAdA,EAAKr8C,KAAe,CAEzB,GADAu8C,EAAkBF,EAAK96C,IACnB69B,EAAsBid,EAAKr8C,KAAKq8C,EAAK96C,MAAO,CAC9C,GAAKq4B,EAEE,CACLwiB,EAASC,GACT,MAAqB,OAAdA,EAAKr8C,KAAgB,CAC1B,IAAIm/B,EAAmBkd,EAAKr8C,KAAKq8C,EAAK96C,MAIpC,MAHAg7C,EAAkBF,EAAK96C,IACvB66C,EAASC,EAIb,CACA,MAAO,CAAEC,GAAID,EAAKC,GAAI/6C,IAAKg7C,EAAkB,EAC/C,CAZE,MAAO,CAAED,GAAID,EAAKC,GAAI/6C,IAAK86C,EAAK96C,IAAM,EAa1C,CACA66C,EAASC,EACX,CACA,MAAO,CAAEC,GAAID,EAAKC,GAAI/6C,IAAKg7C,EAAkB,EAC/C,CAMA,SAASvoB,EAAQ/yB,EAAIq7C,EAAI/6C,EAAKM,GAC5B,IAAI7B,EAAOiB,EAAGuB,QAAQ85C,GAElBD,EAAO,CACTr8C,KAAMA,EACNs8C,GAAIA,EACJ/6C,IAAKA,EACLM,IAAKA,GAGP,GAAkB,KAAdw6C,EAAKr8C,KACP,MAAO,CAAEs8C,GAAID,EAAKC,GAAI/6C,IAAK86C,EAAK96C,KAGlC,IAAIg7C,EAAkBF,EAAK96C,IAG3B66C,EAASC,GAET,MAAqB,OAAdA,EAAKr8C,KAAe,CACzB,GAAKm/B,EAAmBkd,EAAKr8C,KAAKq8C,EAAK96C,OAAU69B,EAAsBid,EAAKr8C,KAAKq8C,EAAK96C,OAIjF,GAAI69B,EAAsBid,EAAKr8C,KAAKq8C,EAAK96C,MAC5C,OAAKq4B,GAGGuF,EAAmBkd,EAAKr8C,KAAKq8C,EAAK96C,IAAM,IACnC,CAAE+6C,GAAID,EAAKC,GAAI/6C,IAAK86C,EAAK96C,IAAM,GAHnC,CAAE+6C,GAAID,EAAKC,GAAI/6C,IAAKg7C,QAL7BA,EAAkBF,EAAK96C,IAezB66C,EAASC,EACX,CAEA,OADAA,EAAKr8C,KAAOA,EACR45B,GAAauF,EAAmBkd,EAAKr8C,KAAKq8C,EAAK96C,MAC1C,CAAE+6C,GAAID,EAAKC,GAAI/6C,IAAK86C,EAAK96C,KAEzB,CAAE+6C,GAAID,EAAKC,GAAI/6C,IAAKg7C,EAG/B,CAEA,IAAIC,EAAa,CACfF,GAAI5qC,EAAI1R,KACRuB,IAAKmQ,EAAIzR,IAGX,MAAO8nC,EAAS,EAEZyU,EADE36C,EAAM,EACKmyB,EAAQ/yB,EAAIu7C,EAAWF,GAAIE,EAAWj7C,IAAKM,GAG3C8B,EAAQ1C,EAAIu7C,EAAWF,GAAIE,EAAWj7C,IAAKM,GAE1DkmC,IAGF,OAAO,IAAInoC,EAAI48C,EAAWF,GAAIE,EAAWj7C,IAC3C,CAEA,SAAS4uC,GAAalvC,EAAIyQ,EAAKq2B,EAAQlmC,GAcnC,SAASu6C,EAASn7C,EAAI80C,GACpB,GAAIA,EAAIx0C,IAAMw0C,EAAIl0C,IAAM,GAAKk0C,EAAIx0C,IAAMw0C,EAAIl0C,KAAOk0C,EAAI/1C,KAAKM,OAAQ,CAEjE,GADAy1C,EAAIuG,IAAMvG,EAAIl0C,KACTk9B,EAAO99B,EAAI80C,EAAIuG,IAIlB,OAHAvG,EAAI/1C,KAAO,KACX+1C,EAAIuG,GAAK,UACTvG,EAAIx0C,IAAM,MAGZw0C,EAAI/1C,KAAOiB,EAAGuB,QAAQuzC,EAAIuG,IAC1BvG,EAAIx0C,IAAOw0C,EAAIl0C,IAAM,EAAK,EAAIk0C,EAAI/1C,KAAKM,OAAS,CAClD,MAEEy1C,EAAIx0C,KAAOw0C,EAAIl0C,GAEnB,CAMA,SAAS8B,EAAQ1C,EAAIq7C,EAAI/6C,EAAKM,GAC5B,IAAI7B,EAAOiB,EAAGuB,QAAQ85C,GAClBf,EAAiB,KAATv7C,EAERq8C,EAAO,CACTr8C,KAAMA,EACNs8C,GAAIA,EACJ/6C,IAAKA,EACLM,IAAKA,GAGH46C,EAAa,CACfH,GAAID,EAAKC,GACT/6C,IAAK86C,EAAK96C,KAGRm7C,EAAkC,KAAdL,EAAKr8C,KAG7Bo8C,EAASn7C,EAAIo7C,GAEb,MAAqB,OAAdA,EAAKr8C,KAAe,CAIzB,GAHAy8C,EAAWH,GAAKD,EAAKC,GACrBG,EAAWl7C,IAAM86C,EAAK96C,IAEJ,KAAd86C,EAAKr8C,OAAgB08C,EACvB,MAAO,CAAEJ,GAAID,EAAKC,GAAI/6C,IAAK86C,EAAK96C,KAE7B,GAAIg6C,GAAsB,KAAdc,EAAKr8C,OAAgBm/B,EAAmBkd,EAAKr8C,KAAKq8C,EAAK96C,MACtE,MAAO,CAAE+6C,GAAID,EAAKC,GAAI/6C,IAAK86C,EAAK96C,MAEzB69B,EAAsBid,EAAKr8C,KAAKq8C,EAAK96C,OACxCg6C,GACAc,EAAK96C,MAAQ86C,EAAKr8C,KAAKM,OAAS,IAC/B6+B,EAAmBkd,EAAKr8C,KAAKq8C,EAAK96C,IAAM,MAC7Cg6C,GAAO,GAGTa,EAASn7C,EAAIo7C,EACf,CAMIr8C,EAAOiB,EAAGuB,QAAQi6C,EAAWH,IACjCG,EAAWl7C,IAAM,EACjB,IAAI,IAAIyD,EAAIhF,EAAKM,OAAS,EAAG0E,GAAK,IAAKA,EACrC,IAAKm6B,EAAmBn/B,EAAKgF,IAAK,CAChCy3C,EAAWl7C,IAAMyD,EACjB,KACF,CAGF,OAAOy3C,CAET,CAMA,SAASzoB,EAAQ/yB,EAAIq7C,EAAI/6C,EAAKM,GAC5B,IAAI7B,EAAOiB,EAAGuB,QAAQ85C,GAElBD,EAAO,CACTr8C,KAAMA,EACNs8C,GAAIA,EACJ/6C,IAAKA,EACLM,IAAKA,GAGH46C,EAAa,CACfH,GAAID,EAAKC,GACT/6C,IAAK,MAGHm7C,EAAkC,KAAdL,EAAKr8C,KAG7Bo8C,EAASn7C,EAAIo7C,GAEb,MAAqB,OAAdA,EAAKr8C,KAAe,CAEzB,GAAkB,KAAdq8C,EAAKr8C,OAAgB08C,EACvB,OAAuB,OAAnBD,EAAWl7C,IACNk7C,EAGA,CAAEH,GAAID,EAAKC,GAAI/6C,IAAK86C,EAAK96C,KAG/B,GAAI69B,EAAsBid,EAAKr8C,KAAKq8C,EAAK96C,OACpB,OAAnBk7C,EAAWl7C,MACT86C,EAAKC,KAAOG,EAAWH,IAAMD,EAAK96C,IAAM,IAAMk7C,EAAWl7C,KAChE,OAAOk7C,EAEc,KAAdJ,EAAKr8C,MAAgBm/B,EAAmBkd,EAAKr8C,KAAKq8C,EAAK96C,QAC9Dm7C,GAAmB,EACnBD,EAAa,CAAEH,GAAID,EAAKC,GAAI/6C,IAAK86C,EAAK96C,MAGxC66C,EAASn7C,EAAIo7C,EACf,CAMIr8C,EAAOiB,EAAGuB,QAAQi6C,EAAWH,IACjCG,EAAWl7C,IAAM,EACjB,IAAI,IAAIyD,EAAI,EAAGA,EAAIhF,EAAKM,SAAU0E,EAChC,IAAKm6B,EAAmBn/B,EAAKgF,IAAK,CAChCy3C,EAAWl7C,IAAMyD,EACjB,KACF,CAEF,OAAOy3C,CACT,CAEA,IAAID,EAAa,CACfF,GAAI5qC,EAAI1R,KACRuB,IAAKmQ,EAAIzR,IAGX,MAAO8nC,EAAS,EAEZyU,EADE36C,EAAM,EACKmyB,EAAQ/yB,EAAIu7C,EAAWF,GAAIE,EAAWj7C,IAAKM,GAG3C8B,EAAQ1C,EAAIu7C,EAAWF,GAAIE,EAAWj7C,IAAKM,GAE1DkmC,IAGF,OAAO,IAAInoC,EAAI48C,EAAWF,GAAIE,EAAWj7C,IAC3C,CAIA,SAASowC,GAAsB1wC,EAAI0E,EAAM80C,EAAM7gB,GAC7C,IAAgB51B,EAAOC,EAAnByN,EAAM/L,EAENg3C,EAAgB,CAClB,IAAK,OAAQ,IAAK,OAClB,IAAK,QAAS,IAAK,QACnB,IAAK,OAAQ,IAAK,OAClB,IAAK,OAAQ,IAAK,QAASlC,GACzBmC,EAAU,CACZ,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,KAAMnC,GACnBoC,EAAU57C,EAAGuB,QAAQkP,EAAI1R,MAAMqD,OAAOqO,EAAIzR,IAG1C2U,EAASioC,IAAYD,EAAU,EAAI,EAKvC,GAHA54C,EAAQ/C,EAAGuR,eAAe,IAAI5S,EAAI8R,EAAI1R,KAAM0R,EAAIzR,GAAK2U,IAAU,OAAGhC,EAAW,CAAC,aAAgB+pC,IAC9F14C,EAAMhD,EAAGuR,eAAe,IAAI5S,EAAI8R,EAAI1R,KAAM0R,EAAIzR,GAAK2U,GAAS,OAAGhC,EAAW,CAAC,aAAgB+pC,KAEtF34C,IAAUC,EACb,MAAO,CAAED,MAAO0N,EAAKzN,IAAKyN,GAM5B,GAHA1N,EAAQA,EAAMzC,IACd0C,EAAMA,EAAI1C,IAELyC,EAAMhE,MAAQiE,EAAIjE,MAAQgE,EAAM/D,GAAKgE,EAAIhE,IACtC+D,EAAMhE,KAAOiE,EAAIjE,KAAO,CAC9B,IAAIyX,EAAMzT,EACVA,EAAQC,EACRA,EAAMwT,CACR,CAQA,OANImiB,EACF31B,EAAIhE,IAAM,EAEV+D,EAAM/D,IAAM,EAGP,CAAE+D,MAAOA,EAAOC,IAAKA,EAC9B,CAKA,SAAS2tC,GAAoB3wC,EAAI0E,EAAM80C,EAAM7gB,GAC3C,IAGI51B,EAAOC,EAAKe,EAAG8J,EAHf4C,EAAM+5B,GAAW9lC,GACjB3F,EAAOiB,EAAGuB,QAAQkP,EAAI1R,MACtB88C,EAAQ98C,EAAKwyB,MAAM,IAEnBuqB,EAAaD,EAAMpqC,QAAQ+nC,GAiB/B,GAZI/oC,EAAIzR,GAAK88C,EACXrrC,EAAIzR,GAAK88C,EAKFA,EAAarrC,EAAIzR,IAAM68C,EAAMprC,EAAIzR,KAAOw6C,IAC/Cx2C,EAAMyN,EAAIzR,KACRyR,EAAIzR,IAIJ68C,EAAMprC,EAAIzR,KAAOw6C,GAASx2C,EAI5B,IAAKe,EAAI0M,EAAIzR,GAAI+E,GAAK,IAAMhB,EAAOgB,IAC7B83C,EAAM93C,IAAMy1C,IACdz2C,EAAQgB,EAAI,QALhBhB,EAAQ0N,EAAIzR,GAAK,EAWnB,GAAI+D,IAAUC,EACZ,IAAKe,EAAIhB,EAAO8K,EAAMguC,EAAMx8C,OAAQ0E,EAAI8J,IAAQ7K,EAAKe,IAC/C83C,EAAM93C,IAAMy1C,IACdx2C,EAAMe,GAMZ,OAAKhB,GAAUC,GAKX21B,MACA51B,IAASC,GAGN,CACLD,MAAO,IAAIpE,EAAI8R,EAAI1R,KAAMgE,GACzBC,IAAK,IAAIrE,EAAI8R,EAAI1R,KAAMiE,KAVhB,CAAED,MAAO0N,EAAKzN,IAAKyN,EAY9B,CAIA,SAASsrC,KAAe,CA2BxB,SAASjT,GAAe9oC,GACtB,IAAI+3B,EAAM/3B,EAAGsD,MAAMy0B,IACnB,OAAOA,EAAIikB,eAAiBjkB,EAAIikB,aAAe,IAAID,GACrD,CACA,SAASE,GAAaC,GACpB,OAAOC,GAAiBD,EAAW,IACrC,CAEA,SAASE,GAAqBF,GAC5B,OAAOG,GAAwBH,EAAW,IAC5C,CAEA,SAASC,GAAiBD,EAAWI,GACnC,IAAIC,EAAUF,GAAwBH,EAAWI,IAAc,GAC/D,IAAKC,EAAQl9C,OAAQ,MAAO,GAC5B,IAAIm9C,EAAS,GAEb,GAAmB,IAAfD,EAAQ,GAAZ,CACA,IAAK,IAAIx4C,EAAI,EAAGA,EAAIw4C,EAAQl9C,OAAQ0E,IACT,iBAAdw4C,EAAQx4C,IACjBy4C,EAAOp9C,KAAK88C,EAAUrX,UAAU0X,EAAQx4C,GAAK,EAAGw4C,EAAQx4C,EAAE,KAE9D,OAAOy4C,CALqB,CAM9B,CAEA,SAASH,GAAwBl9C,EAAKm9C,GAC/BA,IACHA,EAAY,KAId,IAFA,IAAIG,GAAiB,EACjBF,EAAU,GACLx4C,EAAI,EAAGA,EAAI5E,EAAIE,OAAQ0E,IAAK,CACnC,IAAImrB,EAAI/vB,EAAIiD,OAAO2B,GACd04C,GAAkBvtB,GAAKotB,GAC1BC,EAAQn9C,KAAK2E,GAEf04C,GAAkBA,GAAwB,MAALvtB,CACvC,CACA,OAAOqtB,CACT,CAGA,SAASG,GAAev9C,GAOtB,IALA,IAAIw9C,EAAW,OAEXC,EAAW,IACXH,GAAiB,EACjB/iC,EAAM,GACD3V,GAAK,EAAGA,EAAI5E,EAAIE,OAAQ0E,IAAK,CACpC,IAAImrB,EAAI/vB,EAAIiD,OAAO2B,IAAM,GACrBtE,EAAIN,EAAIiD,OAAO2B,EAAE,IAAM,GACvB84C,EAAoBp9C,IAA6B,GAAxBk9C,EAASlrC,QAAQhS,GAC1Cg9C,GACQ,OAANvtB,GAAe2tB,GACjBnjC,EAAIta,KAAK8vB,GAEXutB,GAAiB,GAEP,OAANvtB,GACFutB,GAAiB,EAEbh9C,IAA6B,GAAxBm9C,EAASnrC,QAAQhS,KACxBo9C,GAAmB,GAGhBA,GAA0B,OAANp9C,GACvBia,EAAIta,KAAK8vB,KAGXxV,EAAIta,KAAK8vB,GACL2tB,GAA0B,OAANp9C,GACtBia,EAAIta,KAAK,MAIjB,CACA,OAAOsa,EAAI7T,KAAK,GAClB,CA1GAsd,EAAa,QAAQ,EAAM,WAE3B44B,GAAYl6B,UAAY,CACtBqnB,SAAU,WACR,OAAOrK,EAAetuB,KACxB,EACAusC,SAAU,SAASvsC,GACjBsuB,EAAetuB,MAAQA,CACzB,EACAwsC,WAAY,WACV,OAAOplC,KAAKqlC,aACd,EACAC,WAAY,SAASC,GACnBvlC,KAAKqlC,cAAgBE,CACvB,EACApQ,WAAY,WACV,OAAOjO,EAAeiO,UACxB,EACA/D,YAAa,SAASoU,GACpBte,EAAeiO,WAAaqQ,CAC9B,EACAC,qBAAsB,WACpB,OAAOzlC,KAAK0lC,QACd,EACAC,qBAAsB,SAASD,GAC7B1lC,KAAK0lC,SAAWA,CAClB,GAqFF,IAAIE,GAAgB,CAAC,MAAO,KAAM,MAAO,KAAM,MAAO,MACtD,SAASC,GAAsBr+C,GAG7B,IAFA,IAAIs9C,GAAiB,EACjB/iC,EAAM,GACD3V,GAAK,EAAGA,EAAI5E,EAAIE,OAAQ0E,IAAK,CACpC,IAAImrB,EAAI/vB,EAAIiD,OAAO2B,IAAM,GACrBtE,EAAIN,EAAIiD,OAAO2B,EAAE,IAAM,GACvBw5C,GAAcruB,EAAIzvB,IACpBia,EAAIta,KAAKm+C,GAAcruB,EAAEzvB,IACzBsE,KACS04C,GAGT/iC,EAAIta,KAAK8vB,GACTutB,GAAiB,GAEP,OAANvtB,GACFutB,GAAiB,EACZxe,EAASx+B,IAAY,MAANA,EAClBia,EAAIta,KAAK,KACM,MAANK,GAAmB,OAANA,GACtBia,EAAIta,KAAK,QAGD,MAAN8vB,GACFxV,EAAIta,KAAK,KAEXsa,EAAIta,KAAK8vB,GACC,MAANzvB,GACFia,EAAIta,KAAK,MAIjB,CACA,OAAOsa,EAAI7T,KAAK,GAClB,CAGA,IAAI43C,GAAY,CAAC,MAAO,IAAK,OAAQ,KAAM,MAAO,KAAM,MAAO,KAAM,MAAO,KAAM,MAAM,KACxF,SAASC,GAAqBv+C,GAC5B,IAAIqmB,EAAS,IAAIhnB,EAAWqxB,aAAa1wB,GACrCw+C,EAAS,GACb,OAAQn4B,EAAOo4B,MAAO,CAEpB,MAAOp4B,EAAOc,QAA2B,MAAjBd,EAAOc,OAC7Bq3B,EAAOv+C,KAAKomB,EAAOrjB,QAErB,IAAI6tC,GAAU,EACd,IAAK,IAAI6N,KAAWJ,GAClB,GAAIj4B,EAAO/iB,MAAMo7C,GAAS,GAAO,CAC/B7N,GAAU,EACV2N,EAAOv+C,KAAKq+C,GAAUI,IACtB,KACF,CAEG7N,GAEH2N,EAAOv+C,KAAKomB,EAAOrjB,OAEvB,CACA,OAAOw7C,EAAO93C,KAAK,GACrB,CAYA,SAASi4C,GAAWvtC,EAAOsgB,EAAYgZ,GAErC,IAAIkU,EAAqBlf,EAAegD,mBAAmBQ,YAAY,KAGvE,GAFA0b,EAAmB/W,QAAQz2B,GAEvBA,aAAiBC,OAAU,OAAOD,EAItC,IACIytC,EACAC,EAFA1B,EAAUH,GAAqB7rC,GAGnC,GAAKgsC,EAAQl9C,OAGN,CAEL2+C,EAAYztC,EAAMs0B,UAAU,EAAG0X,EAAQ,IACvC,IAAI2B,EAAY3tC,EAAMs0B,UAAU0X,EAAQ,IACxC0B,GAA8C,GAA3BC,EAAUzsC,QAAQ,IACvC,MANEusC,EAAYztC,EAOd,IAAKytC,EACH,OAAO,KAEJ5yC,EAAU,UACb4yC,EAAYtB,GAAesB,IAEzBnU,IACFhZ,EAAa,YAAcpvB,KAAKu8C,IAElC,IAAIrtB,EAAS,IAAIngB,OAAOwtC,EACnBntB,GAAcotB,EAAmB,KAAO,KAC7C,OAAOttB,CACT,CAYA,SAAS2R,GAAI7iC,GACM,kBAANA,IAAgBA,EAAIgH,SAASG,cAAcnH,IACtD,IAAK,IAAIZ,EAAGkF,EAAI,EAAGA,EAAI0kB,UAAUppB,OAAQ0E,IACvC,GAAMlF,EAAI4pB,UAAU1kB,GAEpB,GADiB,kBAANlF,IAAgBA,EAAI4H,SAASQ,eAAepI,IACnDA,EAAEs/C,SAAU1+C,EAAEuH,YAAYnI,QACzB,IAAK,IAAIuc,KAAOvc,EACdilB,OAAOjC,UAAUtc,eAAewe,KAAKllB,EAAGuc,KAC9B,MAAXA,EAAI,GAAY3b,EAAEqH,MAAMsU,EAAI1Z,MAAM,IAAM7C,EAAEuc,GACzC3b,EAAEoH,aAAauU,EAAKvc,EAAEuc,KAG/B,OAAO3b,CACT,CAEA,SAASsqC,GAAY/pC,EAAI4zB,GACvB,IAAIwqB,EAAM9b,GAAI,MAAO,CAAC+b,OAAQ,MAAOC,YAAa,MAAO/b,MAAO,kBAAmB3O,GAC/E5zB,EAAGu+C,iBACLv+C,EAAGu+C,iBAAiBH,EAAK,CAACh3C,QAAQ,EAAMsuB,SAAU,MAElD8oB,MAAMJ,EAAIK,UAEd,CAEA,SAASn4C,GAAWxC,EAAQylC,GAC1B,OAAOjH,GAAI77B,SAASC,yBACX47B,GAAI,OAAQ,CAACoc,YAAa,YAAaJ,YAAa,OAClDx6C,EACAw+B,GAAI,QAAS,CAACz1B,KAAM,OAAQ8xC,YAAa,MAC3BC,eAAgB,MAAOC,WAAY,WACnDtV,GAAQjH,GAAI,OAAQ,CAAC+b,OAAQ,QAAS9U,GACjD,CAEA,SAASF,GAAWrpC,EAAI0X,GACtB,IAAIkc,EAAWttB,GAAWoR,EAAQ5T,OAAQ4T,EAAQ6xB,MAClD,GAAIvpC,EAAGmH,WACLnH,EAAGmH,WAAWysB,EAAUlc,EAAQ4c,QAAS,CACvCO,UAAWnd,EAAQmd,UAAWD,QAASld,EAAQkd,QAC/CxtB,QAAQ,EAAMqtB,mBAAmB,EAAO1K,MAAOrS,EAAQqS,YAGtD,CACH,IAAI+0B,EAAY,GACa,iBAAlBpnC,EAAQ5T,QAAsB4T,EAAQ5T,SAAQg7C,GAAapnC,EAAQ5T,OAAOi7C,aACjFrnC,EAAQ6xB,OAAMuV,GAAa,IAAMpnC,EAAQ6xB,MAC7C7xB,EAAQ4c,QAAQjtB,OAAOy3C,EAAW,IACpC,CACF,CAEA,SAASE,GAAWC,EAAIC,GACtB,GAAID,aAAczuC,QAAU0uC,aAAc1uC,OAAQ,CAE9C,IADA,IAAI2uC,EAAQ,CAAC,SAAU,YAAa,aAAc,UACzCp7C,EAAI,EAAGA,EAAIo7C,EAAM9/C,OAAQ0E,IAAK,CACnC,IAAI0U,EAAO0mC,EAAMp7C,GACjB,GAAIk7C,EAAGxmC,KAAUymC,EAAGzmC,GAChB,OAAO,CAEf,CACA,OAAO,CACX,CACA,OAAO,CACT,CAEA,SAASqxB,GAAkB9pC,EAAIo/C,EAAUvuB,EAAYgZ,GACnD,GAAKuV,EAAL,CAGA,IAAI97C,EAAQwlC,GAAe9oC,GACvBuQ,EAAQutC,GAAWsB,IAAYvuB,IAAcgZ,GACjD,GAAKt5B,EAIL,OADAw8B,GAAuB/sC,EAAIuQ,GACvByuC,GAAWzuC,EAAOjN,EAAM4lC,aAG5B5lC,EAAMw5C,SAASvsC,GAFNA,CART,CAYF,CACA,SAASysC,GAAczsC,GACrB,GAA8B,KAA1BA,EAAMmT,OAAOthB,OAAO,GACtB,IAAIi9C,GAAW,EAEjB,MAAO,CACLz8C,MAAO,SAAS4iB,GACd,IAAI65B,GAAa75B,EAAOsJ,MAAxB,CAIA,IAAIrsB,EAAQ+iB,EAAO/iB,MAAM8N,GAAO,GAChC,GAAI9N,EACF,OAAuB,GAAnBA,EAAM,GAAGpD,QAEXmmB,EAAOrjB,OACA,aAEJqjB,EAAOsJ,QAEVtJ,EAAOyG,OAAO,GACT1b,EAAMuD,KAAK0R,EAAOrjB,OAASM,EAAM,MAKxC+iB,EAAO/iB,MAAM8N,GACN,cALHiV,EAAOrjB,OACA,MAMb,OAAQqjB,EAAOo4B,MAEb,GADAp4B,EAAOrjB,OACHqjB,EAAO/iB,MAAM8N,GAAO,GAAQ,KArBlC,MAFEiV,EAAOW,WAyBX,EACA5V,MAAOA,EAEX,CACA,IAAIyqB,GAAmB,EACvB,SAAS+R,GAAuB/sC,EAAIuQ,GAClCgJ,aAAayhB,IACbA,GAAmB3hB,WAAW,WAC5B,GAAKrZ,EAAGsD,MAAMy0B,IAAd,CACA,IAAIunB,EAAcxW,GAAe9oC,GAC7Bk9C,EAAUoC,EAAYvC,aACrBG,GAAW3sC,GAAS2sC,EAAQ3sC,QAC3B2sC,GACFl9C,EAAGu/C,cAAcrC,GAEnBA,EAAUF,GAAczsC,GACxBvQ,EAAGg3B,WAAWkmB,GACVl9C,EAAGw/C,yBACDF,EAAYlC,wBACdkC,EAAYlC,uBAAuBpoC,QAErCsqC,EAAYhC,qBAAqBt9C,EAAGw/C,uBAAuBjvC,KAE7D+uC,EAAYrC,WAAWC,GAfA,CAiB3B,EAAG,GACL,CACA,SAAStsC,GAAS5Q,EAAIgT,EAAMzC,EAAOu2B,GAEjC,YADen1B,IAAXm1B,IAAwBA,EAAS,GAC9B9mC,EAAG4N,UAAU,WAGlB,IAFA,IAAItN,EAAMN,EAAGoE,YACTG,EAASvE,EAAG0Q,gBAAgBH,EAAOjQ,GAC9ByD,EAAI,EAAGA,EAAI+iC,EAAQ/iC,IAAK,CAC/B,IAAI4M,EAAQpM,EAAOiQ,KAAKxB,GACxB,GAAS,GAALjP,GAAU4M,GAAS+uB,GAAYn7B,EAAOtE,OAAQK,GAAM,CACtD,IAAIm/C,EAAazsC,EAAOzO,EAAOtE,OAASsE,EAAOrE,KAC/CyQ,EAAQpM,EAAOiQ,KAAKxB,GAChBrC,IAAUA,EAAM,IAAM+uB,GAAYn7B,EAAOtE,OAAQw/C,IAC/Cz/C,EAAGuB,QAAQk+C,EAAW1gD,MAAMM,QAAUogD,EAAWzgD,KACnD2R,EAAQpM,EAAOiQ,KAAKxB,GAE1B,CACA,IAAKrC,IAGHpM,EAASvE,EAAG0Q,gBAAgBH,EACxB,EAAS,IAAI5R,EAAIqB,EAAG8B,YAAc,IAAInD,EAAIqB,EAAG4B,YAAa,KACzD2C,EAAOiQ,KAAKxB,IACf,MAGN,CACA,OAAOzO,EAAOtE,MAChB,EACF,CAQA,SAASitC,GAA2BltC,EAAIgT,EAAMzC,EAAOu2B,EAAQ/O,GAE3D,YADepmB,IAAXm1B,IAAwBA,EAAS,GAC9B9mC,EAAG4N,UAAU,WAClB,IAAItN,EAAMN,EAAGoE,YACTG,EAASvE,EAAG0Q,gBAAgBH,EAAOjQ,GAGnCqQ,EAAQpM,EAAOiQ,MAAMxB,IAGpB+kB,EAAIiJ,YAAcrwB,GAAS+uB,GAAYn7B,EAAOtE,OAAQK,IACzDiE,EAAOiQ,MAAMxB,GAGf,IAAK,IAAIjP,EAAI,EAAGA,EAAI+iC,EAAQ/iC,IAE1B,GADA4M,EAAQpM,EAAOiQ,KAAKxB,IACfrC,IAGHpM,EAASvE,EAAG0Q,gBAAgBH,EACxB,EAAS,IAAI5R,EAAIqB,EAAG8B,YAAc,IAAInD,EAAIqB,EAAG4B,YAAa,KACzD2C,EAAOiQ,KAAKxB,IACf,OAIN,MAAO,CAACzO,EAAOtE,OAAQsE,EAAOrE,KAChC,EACF,CACA,SAASmqC,GAAqBrqC,GAC5B,IAAIsD,EAAQwlC,GAAe9oC,GAC3BA,EAAGu/C,cAAczW,GAAe9oC,GAAI+8C,cACpCz5C,EAAM25C,WAAW,MACb35C,EAAM85C,yBACR95C,EAAM85C,uBAAuBpoC,QAC7B1R,EAAMg6C,qBAAqB,MAE/B,CAYA,SAASoC,GAAUp/C,EAAKyC,EAAOC,GAK7B,MAJkB,iBAAP1C,IAETA,EAAMA,EAAIvB,MAERgE,aAAiBo8B,MACZf,EAAQ99B,EAAKyC,GAEF,iBAAPC,EACD1C,GAAOyC,GAASzC,GAAO0C,EAExB1C,GAAOyC,CAGpB,CACA,SAASypC,GAAoBxsC,GAC3B,IAAI2/C,EAAa3/C,EAAGmP,gBAChBywC,EAAsB,EACtBC,EAAyB,GACzB5/C,EAAOD,EAAG4uC,WAAW,CAACjgC,KAAK,EAAGW,IAAKswC,EAAsBD,EAAWrwC,KAAM,SAC1EwwC,EAAUH,EAAWpwC,aAAeswC,EAAyBF,EAAWrwC,IACxEpP,EAAKF,EAAG4uC,WAAW,CAACjgC,KAAK,EAAGW,IAAKwwC,GAAU,SAC/C,MAAO,CAACxwC,IAAKrP,EAAKlB,KAAMqI,OAAQlH,EAAGnB,KACrC,CAEA,SAASsuC,GAAWrtC,EAAI+3B,EAAK8d,GAC3B,GAAgB,KAAZA,GAAgC,KAAZA,EACtB,OAAOhX,EAAe2C,SAAShtB,KAAKxU,GAAK,IAAM,IAAIrB,EAAI,EAAG,GACrD,GAAgB,KAAZk3C,EACT,OAAO1C,GAAenzC,GAGxB,IAAIyzB,EAAOsE,EAAI1jB,MAAMwhC,GACrB,OAAOpiB,GAAQA,EAAKjf,MACtB,CAEA,SAAS2+B,GAAenzC,GAEtB,IADA,IAAI+/C,EAAO//C,EAAGiB,IAAI++C,QAAQD,KACjBh8C,EAAIg8C,EAAK1gD,OAAQ0E,KACxB,GAAIg8C,EAAKh8C,GAAGg8B,QACV,OAAOyK,GAAWuV,EAAKh8C,GAAGg8B,QAAQ,GAAG7/B,GAG3C,CAEA,IAAI+/C,GAAsB,WACxBtoC,KAAKuoC,kBACP,EACAD,GAAoBp+B,UAAY,CAC9B8jB,eAAgB,SAAS3lC,EAAI2G,EAAOw5C,GAClC,IAAIC,EAAOzoC,KACX3X,EAAG4N,UAAU,WACX5N,EAAGq7B,MAAMqK,SAAU,EACnB0a,EAAKC,gBAAgBrgD,EAAI2G,EAAOw5C,EAClC,EACF,EACAE,gBAAiB,SAASrgD,EAAI2G,EAAOw5C,GACnC,IAAIpoB,EAAM/3B,EAAGsD,MAAMy0B,IACfuoB,EAAyBzhB,EAAegD,mBAAmBQ,YAAY,KACvEke,EAAkBD,EAAuBlZ,WACzCrP,EAAIiJ,YACN0D,GAAe1kC,GAEjB,IAAIwgD,EAAc,IAAIhiD,EAAWqxB,aAAalpB,GAE9C25C,EAAuBtZ,QAAQrgC,GAC/B,IAQIy9B,EACAqc,EATAC,EAASP,GAAc,CAAC,EAC5BO,EAAO/5C,MAAQA,EACf,IACEgR,KAAKgpC,YAAY3gD,EAAIwgD,EAAaE,EACpC,CAAE,MAAM3zC,GAEN,MADAg9B,GAAY/pC,EAAI+M,EAAEq6B,YACZr6B,CACR,CAGA,GAAK2zC,EAAOD,aAOV,GADArc,EAAUzsB,KAAKipC,cAAcF,EAAOD,aAChCrc,EAAS,CAMX,GALAqc,EAAcrc,EAAQvc,KAClBuc,EAAQ3J,2BACV6lB,EAAuBtZ,QAAQuZ,GAEjC5oC,KAAKkpC,kBAAkBL,EAAaE,EAAQtc,GACxB,WAAhBA,EAAQv3B,KAAmB,CAE7B,IAAK,IAAI9I,EAAI,EAAGA,EAAIqgC,EAAQhM,OAAO/4B,OAAQ0E,IACzC23B,EAAOyI,UAAUnkC,EAAIokC,EAAQhM,OAAOr0B,GAAI,WAE1C,MACF,CAAO,GAAoB,UAAhBqgC,EAAQv3B,KAGjB,YADA8K,KAAKguB,eAAe3lC,EAAIokC,EAAQ0c,QAGpC,YAtBoBnvC,IAAhB+uC,EAAO3hD,OACT0hD,EAAc,QAuBlB,GAAKA,EAIL,IACExc,GAAWwc,GAAazgD,EAAI0gD,GAItBtc,GAAYA,EAAQ5J,gBAAkBkmB,EAAOx/B,UACjDw/B,EAAOx/B,UAEX,CAAE,MAAMnU,GAEN,MADAg9B,GAAY/pC,EAAI+M,EAAEq6B,YACZr6B,CACR,MAdEg9B,GAAY/pC,EAAI,2BAA6B2G,EAAQ,IAezD,EACAg6C,YAAa,SAAS3gD,EAAIwgD,EAAax/B,GACrCw/B,EAAYj6B,SAAS,KAEjBi6B,EAAYv6B,IAAI,MAClBjF,EAAOjiB,KAAOiB,EAAG4B,YACjBof,EAAO+/B,QAAU/gD,EAAG8B,aAEpBkf,EAAOjiB,KAAO4Y,KAAKqpC,eAAehhD,EAAIwgD,QAClB7uC,IAAhBqP,EAAOjiB,MAAsByhD,EAAYv6B,IAAI,OAC/CjF,EAAO+/B,QAAUppC,KAAKqpC,eAAehhD,EAAIwgD,KAK7C,IAAI3J,EAAe2J,EAAY/9C,MAAM,4BAOrC,OALEue,EAAOy/B,YADL5J,EACmBA,EAAa,GAEb2J,EAAY/9C,MAAM,MAAM,GAGxCue,CACT,EACAggC,eAAgB,SAAShhD,EAAIwgD,GAC3B,IAAIS,EAAcT,EAAY/9C,MAAM,UACpC,GAAIw+C,EAGF,OAAOla,SAASka,EAAY,GAAI,IAAM,EAExC,OAAQT,EAAYr+C,QAClB,IAAK,IACH,OAAOwV,KAAKupC,qBAAqBV,EAAaxgD,EAAGoE,YAAYrF,MAC/D,IAAK,IACH,OAAO4Y,KAAKupC,qBAAqBV,EAAaxgD,EAAG8B,YACnD,IAAK,IACH,IAAI+zC,EAAW2K,EAAYr+C,OACvBs9B,EAAU4N,GAAWrtC,EAAIA,EAAGsD,MAAMy0B,IAAK8d,GAC3C,IAAKpW,EAAS,MAAM,IAAIjB,MAAM,gBAC9B,OAAO7mB,KAAKupC,qBAAqBV,EAAa/gB,EAAQ1gC,MACxD,IAAK,IACL,IAAK,IAGH,OAFAyhD,EAAYv0B,OAAO,GAEZtU,KAAKupC,qBAAqBV,EAAaxgD,EAAGoE,YAAYrF,MAC/D,QAEE,YADAyhD,EAAYv0B,OAAO,GAGzB,EACAi1B,qBAAsB,SAASV,EAAazhD,GAC1C,IAAIoiD,EAAcX,EAAY/9C,MAAM,iBACpC,GAAI0+C,EAAa,CACf,IAAIxtC,EAASozB,SAASoa,EAAY,GAAI,IAChB,KAAlBA,EAAY,GACdpiD,GAAQ4U,EAER5U,GAAQ4U,CAEZ,CACA,OAAO5U,CACT,EACA8hD,kBAAmB,SAASL,EAAaE,EAAQtc,GAC/C,IAAIoc,EAAY5C,MAAhB,CAGA8C,EAAOxE,UAAYsE,EAAY/9C,MAAM,MAAM,GAE3C,IAAI2+C,EAAQhd,EAAQid,cAAgB,MAChChQ,EAAO1a,GAAK+pB,EAAOxE,WAAW3qB,MAAM6vB,GACpC/P,EAAKhyC,QAAUgyC,EAAK,KACtBqP,EAAOrP,KAAOA,EANhB,CAQF,EACAuP,cAAe,SAASH,GAKtB,IAAK,IAAI18C,EAAI08C,EAAYphD,OAAQ0E,EAAI,EAAGA,IAAK,CAC3C,IAAID,EAAS28C,EAAY5b,UAAU,EAAG9gC,GACtC,GAAI4T,KAAKusB,YAAYpgC,GAAS,CAC5B,IAAIsgC,EAAUzsB,KAAKusB,YAAYpgC,GAC/B,GAA0C,IAAtCsgC,EAAQvc,KAAKpW,QAAQgvC,GACvB,OAAOrc,CAEX,CACF,CACA,OAAO,IACT,EACA8b,iBAAkB,WAChBvoC,KAAKusB,YAAc,CAAC,EACpB,IAAK,IAAIngC,EAAI,EAAGA,EAAIu2B,EAAoBj7B,OAAQ0E,IAAK,CACnD,IAAIqgC,EAAU9J,EAAoBv2B,GAC9BqX,EAAMgpB,EAAQ7J,WAAa6J,EAAQvc,KACvClQ,KAAKusB,YAAY9oB,GAAOgpB,CAC1B,CACF,EACAtN,IAAK,SAASgM,EAAKC,EAAKC,GACtB,GAAW,KAAPF,GAA+B,KAAjBA,EAAI1gC,OAAO,GAAW,CACtC,GAAI4gC,EAAO,MAAMxE,MAAM,sCACvB,IAAIiiB,EAAc3d,EAAI+B,UAAU,GACrB,KAAP9B,GAA+B,KAAjBA,EAAI3gC,OAAO,GAE3BuV,KAAKusB,YAAYuc,GAAe,CAC9B54B,KAAM44B,EACN5zC,KAAM,SACNi0C,QAAS/d,EAAI8B,UAAU,GACvByc,MAAM,GAIR3pC,KAAKusB,YAAYuc,GAAe,CAC9B54B,KAAM44B,EACN5zC,KAAM,UACNurB,OAAQ2K,EACRue,MAAM,EAGZ,MACE,GAAW,KAAPve,GAA+B,KAAjBA,EAAI3gC,OAAO,GAAW,CAEtC,IAAIohC,EAAU,CACZrL,KAAM2K,EACNj2B,KAAM,UACNy9B,OAAQ,CAAE3jC,MAAOo8B,EAAI8B,UAAU,KAE7B7B,IAAOQ,EAAQzb,QAAUib,GAC7B9K,EAAcxjB,QAAQ8uB,EACxB,KAAO,CAEDA,EAAU,CACZrL,KAAM2K,EACNj2B,KAAM,WACNurB,OAAQ2K,GAENC,IAAOQ,EAAQzb,QAAUib,GAC7B9K,EAAcxjB,QAAQ8uB,EACxB,CAEJ,EACAN,MAAO,SAASJ,EAAKE,GACnB,GAAW,KAAPF,GAA+B,KAAjBA,EAAI1gC,OAAO,GAAW,CAEtC,GAAI4gC,EAAO,MAAMxE,MAAM,sCACvB,IAAIiiB,EAAc3d,EAAI+B,UAAU,GAChC,GAAIltB,KAAKusB,YAAYuc,IAAgB9oC,KAAKusB,YAAYuc,GAAaa,KAEjE,cADO3pC,KAAKusB,YAAYuc,IACjB,CAEX,MAGE,IADA,IAAItoB,EAAO2K,EACF/+B,EAAI,EAAGA,EAAIm0B,EAAc74B,OAAQ0E,IACxC,GAAIo0B,GAAQD,EAAcn0B,GAAGo0B,MACtBD,EAAcn0B,GAAGgkB,UAAYib,EAElC,OADA9K,EAAchjB,OAAOnR,EAAG,IACjB,CAIf,GAGF,IAAIkgC,GAAa,CACfsd,YAAa,SAASvhD,EAAI0gD,IACnBA,EAAOrP,MAAQqP,EAAOrP,KAAKhyC,OAAS,EACvC0qC,GAAY/pC,EAAIA,EAAGoL,UAAU,UAG/BpL,EAAG26B,UAAU,QAAS+lB,EAAOrP,KAAK,GACpC,EACAva,IAAK,SAAS92B,EAAI0gD,EAAQ1d,GACxB,IAAIwe,EAAUd,EAAOrP,MAChBmQ,GAAWA,EAAQniD,OAAS,EAC3BW,GACF+pC,GAAY/pC,EAAI,oBAAsB0gD,EAAO/5C,OAIjDs8B,GAAoBnM,IAAI0qB,EAAQ,GAAIA,EAAQ,GAAIxe,EAClD,EACAye,KAAM,SAASzhD,EAAI0gD,GAAU/oC,KAAKmf,IAAI92B,EAAI0gD,EAAQ,SAAW,EAC7DgB,KAAM,SAAS1hD,EAAI0gD,GAAU/oC,KAAKmf,IAAI92B,EAAI0gD,EAAQ,SAAW,EAC7DiB,KAAM,SAAS3hD,EAAI0gD,GAAU/oC,KAAKmf,IAAI92B,EAAI0gD,EAAQ,SAAW,EAC7Dxd,MAAO,SAASljC,EAAI0gD,EAAQ1d,GAC1B,IAAIwe,EAAUd,EAAOrP,OAChBmQ,GAAWA,EAAQniD,OAAS,IAAM4jC,GAAoBC,MAAMse,EAAQ,GAAIxe,KACvEhjC,GACF+pC,GAAY/pC,EAAI,oBAAsB0gD,EAAO/5C,MAGnD,EACAzC,KAAM,SAASlE,EAAI0gD,GACjBzb,EAAkBU,eAAe3lC,EAAIA,EAAGsD,MAAMy0B,IAAK,CAC/ClrB,KAAM,SACNxI,OAAQ,6BACRi0B,WAAY,CAAE51B,SAAS,EAAOk2B,gBAAgB,EAC5CL,UAAU,GACZ2P,eAAgBwY,EAAO3hD,KAAK,GAClC,EACA6iD,IAAK,SAAS5hD,EAAI0gD,GAChB,IAAImB,EAAUnB,EAAOrP,KAGjByQ,EAASpB,EAAOoB,QAAU,CAAC,EAC/B,IAAKD,GAAWA,EAAQxiD,OAAS,EAC3BW,GACF+pC,GAAY/pC,EAAI,oBAAsB0gD,EAAO/5C,WAFjD,CAMA,IAAIolB,EAAO81B,EAAQ,GAAGtwB,MAAM,KACxB6P,EAAarV,EAAK,GAClBhC,EAAQgC,EAAK,GACbg2B,GAAW,EAEf,GAAgD,KAA5C3gB,EAAWh/B,OAAOg/B,EAAW/hC,OAAS,GAAW,CAEnD,GAAI0qB,EAAS,MAAMyU,MAAM,wBAA0BkiB,EAAOxE,WAC1D9a,EAAaA,EAAWyD,UAAU,EAAGzD,EAAW/hC,OAAS,GACzD0iD,GAAW,CACb,MACcpwC,IAAVoY,GAAqD,MAA9BqX,EAAWyD,UAAU,EAAG,KAGjDzD,EAAaA,EAAWyD,UAAU,GAClC9a,GAAQ,GAGV,IAAIi4B,EAAkBtqC,EAAQ0pB,IAA2C,WAA5B1pB,EAAQ0pB,GAAYv0B,KAMjE,GALIm1C,QAA4BrwC,GAAToY,IAErBA,GAAQ,IAGLi4B,QAA6BrwC,IAAVoY,GAAuBg4B,EAAU,CACvD,IAAIE,EAAW72C,EAAUg2B,EAAYphC,EAAI8hD,GACrCG,aAAoBzjB,MACtBuL,GAAY/pC,EAAIiiD,EAASvuB,SAEzBqW,GAAY/pC,GADU,IAAbiiD,IAAkC,IAAbA,EACd,KAAOA,EAAW,GAAK,MAAQ7gB,EAE/B,KAAOA,EAAa,IAAM6gB,EAE9C,KAAO,CACL,IAAIC,EAAkBvnB,EAAUyG,EAAYrX,EAAO/pB,EAAI8hD,GACnDI,aAA2B1jB,OAC7BuL,GAAY/pC,EAAIkiD,EAAgBxuB,QAEpC,CAvCA,CAwCF,EACAyuB,SAAU,SAAUniD,EAAI0gD,GAEtBA,EAAOoB,OAAS,CAACnjB,MAAO,SACxBhnB,KAAKiqC,IAAI5hD,EAAI0gD,EACf,EACA0B,UAAW,SAAUpiD,EAAI0gD,GAEvBA,EAAOoB,OAAS,CAACnjB,MAAO,UACxBhnB,KAAKiqC,IAAI5hD,EAAI0gD,EACf,EACAla,UAAW,SAASxmC,EAAI0gD,GACtB,IAAI2B,EAAU3B,EAAOrP,KACjB7K,EAAY3H,EAAegD,mBAAmB2E,UAC9C8b,EAAU,oCACd,GAAKD,EAOE,CAELA,EAAUA,EAAQx8C,KAAK,IACvB,IAAK,IAAI9B,EAAI,EAAGA,EAAIs+C,EAAQhjD,OAAQ0E,IAElC,GADAq+B,EAAeigB,EAAQjgD,OAAO2B,GACzB86B,EAAegD,mBAAmBwF,gBAAgBjF,GAAvD,CAGA,IAAIxZ,EAAW4d,EAAUpE,IAAiB,IAAIiE,EAC9Cic,GAAW,IAAMlgB,EAAe,OAASxZ,EAASwe,WAAa,IAF/D,CAIJ,MAjBE,IAAK,IAAIhF,KAAgBoE,EAAW,CAClC,IAAIpmC,EAAOomC,EAAUpE,GAAcgF,WAC/BhnC,EAAKf,SACPijD,GAAW,IAAMlgB,EAAe,OAAShiC,EAAO,KAEpD,CAaF2pC,GAAY/pC,EAAIsiD,EAClB,EACApwC,KAAM,SAASlS,EAAI0gD,GACjB,IAAI3tB,EAASlC,EAAY0xB,EAAQjM,EAAQ7rB,EACzC,SAAS+3B,IACP,GAAI9B,EAAOxE,UAAW,CACpB,IAAI7K,EAAO,IAAI7yC,EAAWqxB,aAAa6wB,EAAOxE,WAE9C,GADI7K,EAAKprB,IAAI,OAAQ8M,GAAU,GAC3Bse,EAAKuM,MAAS,OAClB,IAAKvM,EAAKriB,WAAc,MAAO,oBAC/B,IAAIyzB,EAAOpR,EAAK5uC,MAAM,+BACtB,IAAKggD,IAASpR,EAAKuM,MAAS,MAAO,oBACnC,GAAI6E,EAAK,GAAI,CACX5xB,GAAsC,GAAzB4xB,EAAK,GAAGhxC,QAAQ,KAC7B8wC,GAAkC,GAAzBE,EAAK,GAAGhxC,QAAQ,KACzB,IAAIixC,GAAmC,GAAzBD,EAAK,GAAGhxC,QAAQ,OAAuC,GAAzBgxC,EAAK,GAAGhxC,QAAQ,MAAc,EACtEkxC,GAA+B,GAAzBF,EAAK,GAAGhxC,QAAQ,MAAc,EACpCmxC,GAAiC,GAAzBH,EAAK,GAAGhxC,QAAQ,MAAc,EAC1C,GAAIixC,EAAUC,EAAMC,EAAQ,EAAK,MAAO,oBACxCtM,GAASoM,EAAW,UAAaC,GAAO,QAASC,GAAS,OAC5D,CACIH,EAAK,KACPh4B,EAAU,IAAIja,OAAOiyC,EAAK,GAAGz/B,OAAO,EAAGy/B,EAAK,GAAGpjD,OAAS,GAAIwxB,EAAa,IAAM,IAEnF,CACF,CACA,IAAIgyB,EAAML,IACV,GAAIK,EACF9Y,GAAY/pC,EAAI6iD,EAAM,KAAOnC,EAAOxE,eADtC,CAIA,IAAI4G,EAAYpC,EAAO3hD,MAAQiB,EAAG4B,YAC9Bm/C,EAAUL,EAAOK,SAAWL,EAAO3hD,MAAQiB,EAAG8B,WAClD,GAAIghD,GAAa/B,EAAjB,CACA,IAAIvV,EAAW,IAAI7sC,EAAImkD,EAAW,GAC9BrX,EAAS,IAAI9sC,EAAIoiD,EAASjV,GAAW9rC,EAAI+gD,IACzC3gD,EAAOJ,EAAGK,SAASmrC,EAAUC,GAAQla,MAAM,MAC3C0L,EAAcxS,IACJ,WAAV6rB,EAAuB,cACb,OAAVA,EAAmB,0BACT,SAAVA,EAAqB,WAAa,MAClCyM,EAAmB,WAAVzM,EAAuB,GAAgB,OAAVA,EAAmB,GAAgB,SAAVA,EAAqB,EAAI,KACxF0M,EAAU,GAAIC,EAAW,GAC7B,GAAI3M,GAAU7rB,EACZ,IAAK,IAAI1mB,EAAI,EAAGA,EAAI3D,EAAKf,OAAQ0E,IAAK,CACpC,IAAIm/C,EAAYz4B,EAAUrqB,EAAK2D,GAAGtB,MAAMgoB,GAAW,KAC/Cy4B,GAA6B,IAAhBA,EAAU,GACzBF,EAAQ5jD,KAAK8jD,IACHz4B,GAAWwS,EAAYnpB,KAAK1T,EAAK2D,IAC3Ci/C,EAAQ5jD,KAAKgB,EAAK2D,IAElBk/C,EAAS7jD,KAAKgB,EAAK2D,GAEvB,MAEAk/C,EAAW7iD,EAkBb,GADA4iD,EAAQ9wC,KAAKuY,EAAU04B,EAAmBC,GACtC34B,EACF,IAAS1mB,EAAI,EAAGA,EAAIi/C,EAAQ3jD,OAAQ0E,IAClCi/C,EAAQj/C,GAAKi/C,EAAQj/C,GAAG4C,WAEhB2vC,GAAU2M,EAAS/wC,KAAKkxC,GAEpC,GADAhjD,EAAS2yB,EAAsCiwB,EAAQplB,OAAOqlB,GAA1CA,EAASrlB,OAAOolB,GAChCT,EAAQ,CACV,IACIzgD,EADAuhD,EAAUjjD,EAEdA,EAAO,GACP,IAAS2D,EAAI,EAAGA,EAAIs/C,EAAQhkD,OAAQ0E,IAC9Bs/C,EAAQt/C,IAAMjC,GAChB1B,EAAKhB,KAAKikD,EAAQt/C,IAEpBjC,EAAWuhD,EAAQt/C,EAEvB,CACA/D,EAAGS,aAAaL,EAAKyF,KAAK,MAAO2lC,EAAUC,EAzDP,CAHpC,CA2BA,SAAS2X,EAAUvkD,EAAGC,GACL,IAAI0X,EAAfuc,IAAoBvc,EAAM3X,EAAGA,EAAIC,EAAGA,EAAI0X,GACxCqa,IAAchyB,EAAIA,EAAE4L,cAAe3L,EAAIA,EAAE2L,eAC7C,IAAI64C,EAAOhN,GAAUrZ,EAAYnpB,KAAKjV,GAClC0kD,EAAOjN,GAAUrZ,EAAYnpB,KAAKhV,GACtC,OAAKwkD,GACLA,EAAOvc,UAAUuc,EAAK,GAAKA,EAAK,IAAI74C,cAAes4C,GACnDQ,EAAOxc,UAAUwc,EAAK,GAAKA,EAAK,IAAI94C,cAAes4C,GAC5CO,EAAOC,GAHM1kD,EAAIC,GAAK,EAAI,CAInC,CACA,SAASqkD,EAAiBtkD,EAAGC,GACZ,IAAI0X,EAAfuc,IAAoBvc,EAAM3X,EAAGA,EAAIC,EAAGA,EAAI0X,GAE5C,OADIqa,IAAchyB,EAAE,GAAKA,EAAE,GAAG4L,cAAe3L,EAAE,GAAKA,EAAE,GAAG2L,eACjD5L,EAAE,GAAKC,EAAE,IAAO,EAAI,CAC9B,CAoBF,EACA0kD,QAAS,SAASxjD,EAAI0gD,GAEpB/oC,KAAKmZ,OAAO9wB,EAAI0gD,EAClB,EACA5vB,OAAQ,SAAS9wB,EAAI0gD,GAInB,IAAIxE,EAAYwE,EAAOxE,UACvB,GAAKA,EAAL,CAIA,IAM2Bv4C,EANvB8/C,EAAqC,MAA1B/C,EAAOD,YAAY,GAE9BqC,OAA6BnxC,IAAhB+uC,EAAO3hD,KAAsB2hD,EAAO3hD,KAAOiB,EAAG4B,YAC3Dm/C,EAAUL,EAAOK,SAAWL,EAAO3hD,MAAQiB,EAAG8B,WAE9C06C,EAASP,GAAaC,GACtB8B,EAAY9B,EAKhB,GAJIM,EAAOn9C,SACT2+C,EAAYxB,EAAO,GACnB74C,EAAM64C,EAAO96C,MAAM,EAAG86C,EAAOn9C,QAAQwG,KAAK,MAExCm4C,EAGF,IACClU,GAAkB9pC,EAAIg+C,GAAW,GAC/B,EACH,CAAE,MAAOjxC,GAER,YADAg9B,GAAY/pC,EAAI,kBAAoBg+C,EAErC,CAMF,IAFA,IAAIztC,EAAQu4B,GAAe9oC,GAAIkpC,WAC3Bwa,EAAe,GACV3/C,EAAI++C,EAAW/+C,GAAKg9C,EAASh9C,IAAK,CACzC,IAAIhF,EAAOiB,EAAG2jD,cAAc5/C,GACxBisC,EAAUz/B,EAAM9O,KAAK1C,EAAKqB,MAC1B4vC,IAAYyT,GACdC,EAAatkD,KAAKuE,EAAM5E,EAAOA,EAAKqB,KAExC,CAEA,GAAKuD,EAAL,CAIA,IAAIsjB,EAAQ,EACR28B,EAAc,WAChB,GAAI38B,EAAQy8B,EAAarkD,OAAQ,CAC/B,IAAIN,EAAO2kD,EAAaz8B,KACpBkpB,EAAUnwC,EAAG6jD,cAAc9kD,GAC/B,GAAe,MAAXoxC,EAEF,YADAyT,IAGF,IAAIxf,EAAW+L,EAAU,EAAKxsC,EAC9Bs/B,GAAoB0C,eAAe3lC,EAAIokC,EAAS,CAC9CljB,SAAU0iC,GAEd,CACF,EACAA,GAhBA,MAFE7Z,GAAY/pC,EAAI0jD,EAAa79C,KAAK,MApCpC,MAFEkkC,GAAY/pC,EAAI,yCAyDpB,EACA8jD,WAAY,SAAS9jD,EAAI0gD,GACvB,IAAK1gD,EAAG0Q,gBACN,MAAM,IAAI8tB,MAAM,uGAGlB,IAEIwf,EAA6B+F,EAAU7F,EAAW8F,EAFlD9H,EAAYwE,EAAOxE,UACnBM,EAASN,EAAYC,GAAiBD,EAAWA,EAAU,IAAM,GACtD+H,EAAc,GACzBC,GAAU,EACVpzB,GAAS,EACb,GAAI0rB,EAAOn9C,OACT2+C,EAAYxB,EAAO,GACfpxC,EAAU,SAAyB,KAAd4yC,IACrBA,EAAY,IAAIxtC,OAAOwtC,GAAWt6B,QAEtCugC,EAAczH,EAAO,QACD7qC,IAAhBsyC,IAEAA,EADE74C,EAAU,QACEsyC,GAAqBuG,EAAYzhC,QAAQ,YAAY,UAErDg7B,GAAsByG,GAEtCplB,EAAe0C,0BAA4B0iB,GAE7CF,EAAWvH,EAAO,GAAKA,EAAO,GAAGjrB,MAAM,KAAO,QAK9C,GAAI2qB,GAAaA,EAAU78C,OAGzB,YAFA0qC,GAAY/pC,EAAI,2DAwBpB,GAjBI+jD,IACF7F,EAAY6F,EAAS,GACrBC,EAAQjd,SAASgd,EAAS,IACtB7F,KAC6B,GAA3BA,EAAUzsC,QAAQ,OACpByyC,GAAU,IAEmB,GAA3BhG,EAAUzsC,QAAQ,OACpBqf,GAAS,GAGRktB,EADC5yC,EAAU,QACC4yC,EAAY,IAAME,EAElBF,EAAUx7B,QAAQ,MAAO,OAAS,IAAM07B,IAIvDF,EAGF,IACElU,GAAkB9pC,EAAIg+C,GAAW,GAC/B,EACJ,CAAE,MAAOjxC,GAEP,YADAg9B,GAAY/pC,EAAI,kBAAoBg+C,EAEtC,CAGF,GADAiG,EAAcA,GAAeplB,EAAe0C,+BACxB5vB,IAAhBsyC,EAAJ,CAIA,IAAI3gD,EAAQwlC,GAAe9oC,GACvBuQ,EAAQjN,EAAM4lC,WACd4Z,OAA6BnxC,IAAhB+uC,EAAO3hD,KAAsB2hD,EAAO3hD,KAAOiB,EAAGoE,YAAYrF,KACvEgiD,EAAUL,EAAOK,SAAW+B,EAC5BA,GAAa9iD,EAAG4B,aAAem/C,GAAW/gD,EAAG8B,aAC/Ci/C,EAAU9V,KAER+Y,IACFlB,EAAY/B,EACZA,EAAU+B,EAAYkB,EAAQ,GAEhC,IAAIl3C,EAAW29B,GAAoBzqC,EAAI,IAAIrB,EAAImkD,EAAW,IACtDv+C,EAASvE,EAAG0Q,gBAAgBH,EAAOzD,GACvCq3C,GAAUnkD,EAAIkkD,EAASpzB,EAAQgyB,EAAW/B,EAASx8C,EAAQgM,EAAO0zC,EAAavD,EAAOx/B,SAdtF,MAFE6oB,GAAY/pC,EAAI,4CAiBpB,EACA21C,KAAMn3C,EAAWE,SAASi3C,KAC1BF,KAAMj3C,EAAWE,SAAS+2C,KAC1B2O,MAAO,SAASpkD,GACVxB,EAAWE,SAAS2lD,KAEtB7lD,EAAWE,SAAS2lD,KAAKrkD,GAChBA,EAAGqkD,MAEZrkD,EAAGqkD,MAEP,EACAC,WAAY,SAAStkD,GACnBqqC,GAAqBrqC,EACvB,EACAgI,KAAM,SAAUhI,GACd,IAAIyQ,EAAM+5B,GAAWxqC,EAAGoE,aACpBrF,EAAO0R,EAAI1R,KACXgxC,EAAW/vC,EAAGuB,QAAQxC,GAC1B8/B,EAAegD,mBAAmBoF,SAChC,IAAK,OAAQ8I,GAAU,GAAM,EACjC,EACAwU,SAAU,SAASvkD,EAAI0gD,GACrB,GAAKA,EAAOxE,WAAcvlB,GAAK+pB,EAAOxE,WAAtC,CAKA,IAAI54C,EAAQtD,EAAGsD,MAAMy0B,IACjBvS,EAAS,IAAIhnB,EAAWqxB,aAAa8G,GAAK+pB,EAAOxE,YACrD,OAAQ12B,EAAOo4B,MAAO,CACpBp4B,EAAOwJ,WAIP,IAAIg1B,EAAQx+B,EAAOllB,IAEnB,IAAKklB,EAAO/iB,MAAM,YAAY,GAE5B,YADAsnC,GAAY/pC,EAAI,qBAAuB0gD,EAAOxE,UAAUrX,UAAUmf,IAIpE,IAAIQ,EAAMh/B,EAAOrjB,OAEjB,GAAIqjB,EAAO/iB,MAAM,KAAK,GAAO,CAI3B,IAAK+iB,EAAO/iB,MAAM,YAAY,GAE5B,YADAsnC,GAAY/pC,EAAI,qBAAuB0gD,EAAOxE,UAAUrX,UAAUmf,IAIpE,IAAIS,EAAYD,EACZE,EAAal/B,EAAOrjB,OAGxB,KAAI47B,EAAY0mB,IAAc1mB,EAAY2mB,IACtC9nB,EAAY6nB,IAAc7nB,EAAY8nB,IAiBxC,YADA3a,GAAY/pC,EAAI,qBAAuBykD,EAAY,KAfnD,IAAI1hD,EAAQ0hD,EAAUE,WAAW,GAC7BC,EAASF,EAAWC,WAAW,GACnC,GAAI5hD,GAAS6hD,EAEX,YADA7a,GAAY/pC,EAAI,qBAAuB0gD,EAAOxE,UAAUrX,UAAUmf,IAOpE,IAAK,IAAIlvC,EAAI,EAAGA,GAAK8vC,EAAS7hD,EAAO+R,IAAK,CACxC,IAAI2e,EAAO1nB,OAAOuxB,aAAav6B,EAAQ+R,UAChCxR,EAAM+Q,MAAMof,EACrB,CAKJ,aAESnwB,EAAM+Q,MAAMmwC,EAEvB,CAvDA,MAFEza,GAAY/pC,EAAI,oBA0DpB,GAGEijC,GAAsB,IAAIgd,GAY9B,SAASkE,GAAUnkD,EAAIkkD,EAASpzB,EAAQgyB,EAAW/B,EAAS8D,EAAct0C,EACtEwlC,EAAa70B,GAEflhB,EAAGsD,MAAMy0B,IAAI+sB,QAAS,EACtB,IACIC,EAASC,EAAoBtxC,EAD7BqsC,GAAO,EAEX,SAASkF,IACPjlD,EAAG4N,UAAU,WACX,OAAQmyC,EACNv9B,IACArgB,IAEFm4C,GACF,EACF,CACA,SAAS93B,IACP,IAAIpiB,EAAOJ,EAAGK,SAASwkD,EAAa5kD,OAAQ4kD,EAAa3kD,MACrD+yB,EAAU7yB,EAAKoiB,QAAQjS,EAAOwlC,GAC9BmP,EAAuBL,EAAa3kD,KAAKnB,KAC7C8lD,EAAariC,QAAQyQ,GACrB+xB,EAAqBH,EAAa3kD,KAAKnB,KACvCgiD,GAAWiE,EAAqBE,EAChCxxC,EAASsxC,EAAqBE,CAChC,CACA,SAASC,IACP,IAAIC,EAAcL,GAAWva,GAAWqa,EAAa3kD,MACjDuC,EAAQoiD,EAAaj0C,WAIzB,OAHInO,IAAUA,EAAM,IAAM2iD,GAAe1lB,GAAYmlB,EAAa5kD,OAAQmlD,KACxE3iD,EAAQoiD,EAAaj0C,YAEhBnO,CACT,CACA,SAASN,IAGP,MAAMgjD,KACAzF,GAAUmF,EAAa5kD,OAAQ6iD,EAAW/B,GAC9C,GAAKjwB,GAAU+zB,EAAa5kD,OAAOlB,MAAQimD,GAAuBtxC,EAOlE,OAJA1T,EAAGoT,eAAeyxC,EAAa5kD,OAAQ,IACvCD,EAAGiI,aAAa48C,EAAa5kD,OAAQ4kD,EAAa3kD,MAClD6kD,EAAUF,EAAa5kD,YACvB8/C,GAAO,GAGTA,GAAO,CACT,CACA,SAASzF,EAAKxhC,GAGZ,GAFIA,GAASA,IACb9Y,EAAGygB,QACCskC,EAAS,CACX/kD,EAAGqG,UAAU0+C,GACb,IAAIhtB,EAAM/3B,EAAGsD,MAAMy0B,IACnBA,EAAI+sB,QAAS,EACb/sB,EAAI6I,SAAW7I,EAAI8I,UAAYkkB,EAAQ/lD,EACzC,CACIkiB,GAAYA,GAClB,CACA,SAASuoB,EAAgB18B,EAAGs4C,EAAQvsC,GAElCta,EAAWy2B,OAAOloB,GAClB,IAAIm9B,EAAU1rC,EAAW0rC,QAAQn9B,GACjC,OAAQm9B,GACN,IAAK,IACH1nB,IAAWrgB,IAAQ,MACrB,IAAK,IACHA,IAAQ,MACV,IAAK,IAGH,IAAImjD,EAAgBpkC,EACpBA,OAAWvP,EACX3R,EAAG4N,UAAUq3C,GACb/jC,EAAWokC,EACX,MACF,IAAK,IACH9iC,IAEF,IAAK,IACL,IAAK,MACL,IAAK,SACL,IAAK,SACH83B,EAAKxhC,GACL,MAGJ,OADIinC,GAAQzF,EAAKxhC,IACV,CACT,CAIA,GADA3W,KACI49C,EAIJ,OAAKmE,OAKL7a,GAAWrpC,EAAI,CACb8D,OAAQw+B,GAAI,OAAQ,gBAAiBA,GAAI,SAAUyT,GAAc,gBACjElhB,UAAW4U,KANXwb,SACI/jC,GAAYA,MALhB6oB,GAAY/pC,EAAI,kBAAoBuQ,EAAMmT,OAY9C,CAQA,SAASihB,GAAe3kC,GACtB,IAAI+3B,EAAM/3B,EAAGsD,MAAMy0B,IACf0J,EAAiB5C,EAAe4C,eAChC8jB,EAA2B1mB,EAAegD,mBAAmBQ,YAAY,KACzElC,EAAYsB,EAAetB,UAC3BqlB,EAAa/jB,EAAelB,sBAC3BJ,IACHngC,EAAGwF,IAAI,SAAU2wB,IACjB33B,EAAWgH,IAAIxF,EAAGoc,gBAAiB,UAAWg3B,MAE3CjT,GAAapI,EAAIgJ,iBAAmB,IAEvCyV,GAAex2C,EAAI+3B,EAAKA,EAAIgJ,iBAAmB,GAC3C,GACJhJ,EAAI2I,mBAAmBwH,eAAiBnQ,EAAIgJ,yBAEvChJ,EAAIgJ,iBACXhJ,EAAIC,YAAa,EACjBh4B,EAAGqG,UAAUrG,EAAGoE,YAAYrF,KAAMiB,EAAGoE,YAAYpF,GAAG,GACpDgB,EAAG26B,UAAU,SAAU,OACvB36B,EAAG26B,UAAU,gBAAgB,GAC7B36B,EAAGizC,iBAAgB,GAEnBsS,EAAyBve,QAAQwe,EAAWzlB,QAAQl6B,KAAK,KACzDrH,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,WAC5C6G,EAAerB,aACjBqlB,GAAoBhkB,EAExB,CAEA,SAASiC,GAAYU,GACnBlM,EAAcxjB,QAAQ0vB,EACxB,CAEA,SAAS4B,GAAW7N,EAAMtrB,EAAMgb,EAAMwpB,EAAM91B,GAC1C,IAAI6oB,EAAU,CAACjM,KAAMA,EAAMtrB,KAAMA,GAGjC,IAAK,IAAIuO,KAFTgpB,EAAQv3B,GAAQgb,EAChBuc,EAAQv3B,EAAO,QAAUwkC,EACT91B,EACd6oB,EAAQhpB,GAAOG,EAAMH,GACvBsoB,GAAYU,EACd,CAuBA,SAAS4O,GAAqBhzC,EAAI+3B,EAAK0J,EAAgBW,GACrD,IAAIxZ,EAAWiW,EAAegD,mBAAmBQ,YAAYD,GAC7D,GAAoB,KAAhBA,EAMF,OAJIxZ,EAASmc,UAAU,IACrB9B,GAAoB0C,eAAe3lC,EAAI4oB,EAASmc,UAAU,SAE5DtD,EAAetB,WAAY,GAG7B,IAAI4E,EAAYnc,EAASmc,UACrB2gB,EAAM,EACVjkB,EAAetB,WAAY,EAC3BsB,EAAepB,oBAAsBzX,EAAS2d,cAAc7kC,MAAM,GAClE,IAAK,IAAIqC,EAAI,EAAGA,EAAIghC,EAAU1lC,OAAQ0E,IAAK,CACzC,IACItB,EAAO2Y,EADPhb,EAAO2kC,EAAUhhC,GAErB,MAAO3D,EAOL,GAJAqC,EAAQ,oBAAsBqR,KAAK1T,GACnCgb,EAAM3Y,EAAM,GACZrC,EAAOA,EAAKykC,UAAUpiC,EAAMwkB,MAAQ7L,EAAI/b,QACxCq8B,EAAOyI,UAAUnkC,EAAIob,EAAK,SACtB2c,EAAIC,WAAY,CAClB,IAAI+H,EAAUnX,EAAS0d,kBAAkBof,KAAO3lB,QAChDlB,EAAe4C,eAAelB,sBAAsBR,QAChDA,EACJ4lB,GAAwB3lD,EAAI+/B,EAAS,GACrC4E,GAAe3kC,EACjB,CAEJ,CACAyhC,EAAetB,WAAY,CAC7B,CAEA,SAASqE,GAAO/C,EAAgBrmB,GAC9B,IAAIqmB,EAAetB,UAAnB,CACA,IAAIiC,EAAeX,EAAevB,eAC9BtX,EAAWiW,EAAegD,mBAAmBQ,YAAYD,GACzDxZ,GACFA,EAASqe,SAAS7rB,EAJoB,CAM1C,CAEA,SAASqqC,GAAoBhkB,GAC3B,IAAIA,EAAetB,UAAnB,CACA,IAAIiC,EAAeX,EAAevB,eAC9BtX,EAAWiW,EAAegD,mBAAmBQ,YAAYD,GACzDxZ,GAAYA,EAASse,uBACvBte,EAASse,sBAAsBzF,EAAelB,sBAJR,CAM1C,CAEA,SAASyJ,GAAevI,EAAgBlxB,GACtC,IAAIkxB,EAAetB,UAAnB,CACA,IAAIiC,EAAeX,EAAevB,eAC9BtX,EAAWiW,EAAegD,mBAAmBQ,YAAYD,GACzDxZ,GAAYA,EAASue,iBACvBve,EAASue,gBAAgB52B,EAJa,CAM1C,CAMA,SAAS4lB,GAASn2B,EAAI4lD,GACpB,IAAInkB,EAAiB5C,EAAe4C,eAChC+jB,EAAa/jB,EAAelB,sBAChC,IAAKkB,EAAetB,UAClB,MAAMylB,EAAW,CAEf,GADAJ,EAAWxlB,+BAAgC,EACvCwlB,EAAWK,YAAc,EAC3BL,EAAWK,mBACN,GAAwB,UAApBD,EAAUjgD,QAA0C,SAApBigD,EAAUjgD,aACzBgM,IAArBi0C,EAAUjgD,OAA4C,CAC3D,IAAImgD,EAAiB9lD,EAAGyE,iBAAiBpF,OACrCymD,EAAiB,IACnBN,EAAWK,YAAcC,GAC3B,IAAI1lD,EAAOwlD,EAAUxlD,KAAKyF,KAAK,MAC3B2/C,EAAWO,aACbP,EAAWzlB,QAAU,GACrBylB,EAAWO,YAAa,GAEtB3lD,IACEJ,EAAGsD,MAAM4vC,YAAc,KAAKzxC,KAAKrB,GACnColD,EAAWzlB,QAAQ3gC,KAAK,CAACgB,IAEzBolD,EAAWzlB,QAAQ3gC,KAAKgB,GAG9B,CAEAwlD,EAAYA,EAAUzjD,IACxB,CAEJ,CAKA,SAAS8zB,GAAiBj2B,GACxB,IAAI+3B,EAAM/3B,EAAGsD,MAAMy0B,IACnB,GAAIA,EAAIC,WAAY,CAElB,IAAIyJ,EAAiB5C,EAAe4C,eACpC,GAAIA,EAAetB,UAAa,OAChC,IAAIqlB,EAAa/jB,EAAelB,sBAC5BilB,EAAWxlB,8BACbwlB,EAAWxlB,+BAAgC,EAG3CwlB,EAAWO,YAAa,CAE5B,MAAY/lD,EAAGq7B,MAAMqK,SACnBsgB,GAAwBhmD,EAAI+3B,EAEhC,CACA,SAASiuB,GAAwBhmD,EAAI+3B,GACnC,IAAIjzB,EAAS9E,EAAGoE,UAAU,UACtBM,EAAO1E,EAAGoE,UAAU,QASxB,GAPI2zB,EAAIiJ,aAAehhC,EAAG4E,oBACxB8/B,GAAe1kC,GAAI,GACT+3B,EAAIiJ,YAAejJ,EAAIC,aAAch4B,EAAG4E,sBAClDmzB,EAAIiJ,YAAa,EACjBjJ,EAAIwB,YAAa,EACjB/6B,EAAWwa,OAAOhZ,EAAI,kBAAmB,CAAC46B,KAAM,YAE9C7C,EAAIiJ,WAAY,CAGlB,IAAIsX,EAAcnN,GAAezmC,EAAMI,GAAe,GAAJ,EAC9CyzC,EAAepN,GAAezmC,EAAMI,IAAW,EAAI,EACvDJ,EAAOo4B,GAAap4B,EAAM,EAAG4zC,GAC7BxzC,EAASg4B,GAAah4B,EAAQ,EAAGyzC,GACjCxgB,EAAI72B,IAAM,CACR4D,OAAQA,EACRJ,KAAMA,GAERwmC,GAAWlrC,EAAI+3B,EAAK,IAAK4T,GAAUjnC,EAAMI,IACzComC,GAAWlrC,EAAI+3B,EAAK,IAAK6T,GAAUlnC,EAAMI,GAC3C,MAAYizB,EAAIC,aAEdD,EAAI6I,SAAW5gC,EAAGoE,YAAYpF,GAElC,CAGA,SAAS6jC,GAAcqH,GACrBvyB,KAAKuyB,QAAUA,CACjB,CAOA,SAASkJ,GAAwBrmC,GAC/B,IAAI00B,EAAiB5C,EAAe4C,eAChC+jB,EAAa/jB,EAAelB,sBAC5B2J,EAAU1rC,EAAW0rC,QAAQn9B,GAEjC,SAASk5C,IAMP,OALIT,EAAWO,aACbP,EAAWzlB,QAAU,GACrBylB,EAAWO,YAAa,GAE1BP,EAAWzlB,QAAQ3gC,KAAK,IAAIyjC,GAAcqH,KACnC,CACT,CARKA,KAS6B,GAA9BA,EAAQz4B,QAAQ,YAAoD,GAAjCy4B,EAAQz4B,QAAQ,cACrDjT,EAAW0nD,UAAUhc,EAAS,aAAc+b,GAEhD,CAWA,SAASzP,GAAex2C,EAAI+3B,EAAK+O,EAAQqf,GACvC,IAAI1kB,EAAiB5C,EAAe4C,eACpCA,EAAetB,WAAY,EAC3B,IAAIimB,IAAaruB,EAAI4I,sBACjB0lB,EAAmBtuB,EAAIyI,WAC3B,SAAS8lB,IACHF,EACFnhB,EAAkBqD,cAActoC,EAAI+3B,EAAKA,EAAI4I,uBAE7CsE,EAAkByD,UAAU1oC,EAAI+3B,EAEpC,CACA,SAASwuB,EAAazf,GACpB,GAAIrF,EAAelB,sBAAsBR,QAAQ1gC,OAAS,EAAG,CAG3DynC,EAAU/O,EAAI4I,sBAA4BmG,EAAJ,EACtC,IAAI0f,EAAe/kB,EAAelB,sBAClColB,GAAwB3lD,EAAIwmD,EAAazmB,QAAS+G,EACpD,CACF,CAEA,GADA/O,EAAIyI,WAAazI,EAAI2I,mBACjB0lB,GAAYruB,EAAI4I,sBAAsBjH,sBAGxC,IAAK,IAAI31B,EAAI,EAAGA,EAAI+iC,EAAQ/iC,IAC1BuiD,IACAC,EAAa,QAGVJ,GAIHG,IAEFC,EAAazf,GAEf/O,EAAIyI,WAAa6lB,EACbtuB,EAAIC,aAAemuB,GAGrBxhB,GAAe3kC,GAEjByhC,EAAetB,WAAY,CAC7B,CAEA,SAASwlB,GAAwB3lD,EAAI+/B,EAAS+G,GAC5C,SAAS2f,EAAWC,GAMlB,MALsB,iBAAXA,EACTloD,EAAWE,SAASgoD,GAAS1mD,GAE7B0mD,EAAQ1mD,IAEH,CACT,CACA,IAAI0E,EAAO1E,EAAGoE,UAAU,QACpB6zB,EAAc4G,EAAe4C,eAAelB,sBAAsBtI,YAClEA,IAEFob,GAAgBrzC,EAAI0E,EAAMuzB,EAAc,GACxC6O,EAAS9mC,EAAGyE,iBAAiBpF,OAC7BW,EAAGqG,UAAU3B,IAEf,IAAK,IAAIX,EAAI,EAAGA,EAAI+iC,EAAQ/iC,IAAK,CAC3Bk0B,GACFj4B,EAAGqG,UAAUy2B,GAAap4B,EAAMX,EAAG,IAErC,IAAK,IAAI+Q,EAAI,EAAGA,EAAIirB,EAAQ1gC,OAAQyV,IAAK,CACvC,IAAIs8B,EAASrR,EAAQjrB,GACrB,GAAIs8B,aAAkBvO,GACpBrkC,EAAW0nD,UAAU9U,EAAOlH,QAAS,aAAcuc,QAC9C,GAAqB,iBAAVrV,EAChBpxC,EAAG+F,iBAAiBqrC,OACf,CACL,IAAIruC,EAAQ/C,EAAGoE,YACXpB,EAAM85B,GAAa/5B,EAAO,EAAGquC,EAAO,GAAG/xC,QAC3CW,EAAGS,aAAa2wC,EAAO,GAAIruC,EAAOC,GAClChD,EAAGqG,UAAUrD,EACf,CACF,CACF,CACIi1B,GACFj4B,EAAGqG,UAAUy2B,GAAap4B,EAAM,EAAG,GAEvC,CAGA,SAASiiD,GAAcrjD,GACrB,IAAI7D,EAAI,IAAI6D,EAAMsjD,YAelB,OAdA9iC,OAAOqU,KAAK70B,GAAOujD,QAAQ,SAASzrC,GAClC,IAAI0rC,EAAIxjD,EAAM8X,GACV+jB,MAAM4nB,QAAQD,GAChBA,EAAIA,EAAEplD,QACColD,GAAiB,iBAALA,GAAiBA,EAAEF,aAAe9iC,SACrDgjC,EAAIH,GAAcG,IACpBrnD,EAAE2b,GAAO0rC,CACX,GACIxjD,EAAMpC,MACRzB,EAAEyB,IAAM,CACNwD,KAAMpB,EAAMpC,IAAIwD,MAAQ8lC,GAAWlnC,EAAMpC,IAAIwD,MAC7CI,OAAQxB,EAAMpC,IAAI4D,QAAU0lC,GAAWlnC,EAAMpC,IAAI4D,UAG9CrF,CACT,CACA,SAAS4kC,GAAqBrkC,EAAIob,EAAKzV,GACrC,IAAIqhD,GAAY,EACZjvB,EAAM2D,EAAOiH,mBAAmB3iC,GAChCi4B,EAAcF,EAAIE,aAAeF,EAAIkvB,iBAErCC,EAAiBlnD,EAAGmnD,sBAOxB,GANIpvB,EAAIkvB,mBAAqBC,EAC3BnvB,EAAIkvB,kBAAmB,EACdC,GAAkBnvB,EAAIE,cAC9BF,EAAIkvB,kBAAmB,GAGf,SAAP7rC,GAAmB2c,EAAIC,YAAeD,EAAIiJ,aAAckmB,GAAgC,SAAdnvB,EAAIqvB,OAG3E,GAAInvB,IAAgBivB,GAAkBlnD,EAAGqnD,uBAC9CL,EAAYtrB,EAAOyI,UAAUnkC,EAAIob,EAAKzV,OACjC,CACL,IAAIsxB,EAAM0vB,GAAc5uB,GAExB/3B,EAAG4N,UAAU,WACX5N,EAAGq7B,MAAMqK,SAAU,EACnB1lC,EAAGsnD,iBAAiB,WAClB,IAAI5iD,EAAO1E,EAAGoE,UAAU,QACpBU,EAAS9E,EAAGoE,UAAU,UACtBk0C,EAAcnN,GAAezmC,EAAMI,GAAe,GAAJ,EAC9CyzC,EAAepN,GAAezmC,EAAMI,IAAW,EAAI,EACvDJ,EAAOo4B,GAAap4B,EAAM,EAAG4zC,GAC7BxzC,EAASg4B,GAAah4B,EAAQ,EAAGyzC,GACjCv4C,EAAGsD,MAAMy0B,IAAI72B,IAAIwD,KAAOA,EACxB1E,EAAGsD,MAAMy0B,IAAI72B,IAAI4D,OAASA,EAE1BkiD,EAAYtrB,EAAOyI,UAAUnkC,EAAIob,EAAKzV,GAClC3F,EAAGunD,mBACLvnD,EAAGsD,MAAMy0B,IAAM4uB,GAAc1vB,GAEjC,GACIj3B,EAAGq7B,MAAMljB,iBAAmB6uC,IAC9BhnD,EAAGq7B,MAAMljB,gBAAiB,GAC5BnY,EAAGsD,MAAMy0B,IAAMA,CACjB,GAAG,EACL,MA3BEwM,EAAgBvkC,GAgClB,OAHIgnD,GAAcjvB,EAAIiJ,YAAejJ,EAAIyvB,QAAUzvB,EAAIiJ,YAAchhC,EAAG4E,qBACtEohD,GAAwBhmD,EAAI+3B,GAEvBivB,CACT,CAGF,OA5ZExoD,EAAWmN,OAAOosB,IAAM,CACtBoD,OAAQC,EACRqsB,OAAQxsB,EACRlX,KAAMwX,GAgDRpY,EAAa,2BAA4B,IAAK,UAE9C3kB,EAAWmN,OAAO,cAAgB,CAGhC+7C,YAAa,CAAC,WACdvsB,OAAQC,EACRqsB,OAAQxsB,EACRlX,KAAMwX,GAGR/8B,EAAWmN,OAAO,eAAiB,CACjC,UAAa,aACb+7C,YAAa,CAAC,cACdvsB,OAAQC,EACRqsB,OAAQxsB,EACRlX,KAAMwX,GAuVR4F,IAEKzF,CACT,CAEA,SAASisB,EAAQC,GAEf,OADAA,EAAYC,IAAMhwB,EAAU+vB,GACrBA,EAAYC,GACrB,CAIIrpD,EAAWqpD,IAAMF,EAAQnpD,EAC3B,E,mBCr1LF,SAAUD,GAENA,EAAI,EAAQ,OAKf,EAPD,CAOG,SAASC,GACV,aACA,IAAIspD,EAAY,0BACZC,EAAe,wBAEnB,SAASC,EAAYhoD,EAAI+M,EAAGhP,GAC1B,IAAIkqD,EAAKxhD,SAASG,cAAc,OAQhC,SAAS6W,EAAS1Q,GAChB,IAAKk7C,EAAGpsC,WAAY,OAAOrd,EAAWgH,IAAIiB,SAAU,YAAagX,GACjE,IAAInO,EAAM5P,KAAKwe,IAAI,EAAGnR,EAAEm7C,QAAUD,EAAG1pC,aAAe,GAChD5P,EAAOjP,KAAKwe,IAAI,EAAGxe,KAAKC,IAAIoN,EAAEo7C,QAAU,EAAGF,EAAG9rC,cAAcG,YAAY2B,WAAagqC,EAAG9pC,cAC5F8pC,EAAGnhD,MAAMwI,IAAMA,EAAM,KACrB24C,EAAGnhD,MAAM6H,KAAOA,EAAO,IACzB,CAIA,OAjBAs5C,EAAGxrC,UAAY,gCAAkCzc,EAAG0X,QAAQ8E,MAC5DyrC,EAAGjhD,YAAYjJ,EAAQqqD,WAAU,IAC7BpoD,EAAGsD,MAAM+kD,KAAK3wC,QAAQ4wC,YACxBtoD,EAAGkgB,oBAAoBlZ,YAAYihD,GAEnCxhD,SAASyW,KAAKlW,YAAYihD,GAS5BzpD,EAAWyG,GAAGwB,SAAU,YAAagX,GACrCA,EAAS1Q,GACe,MAApBk7C,EAAGnhD,MAAMyhD,UAAiBN,EAAGnhD,MAAMyhD,QAAU,GAC1CN,CACT,CACA,SAASO,EAAG3rC,GACNA,EAAIhB,YAAYgB,EAAIhB,WAAWyG,YAAYzF,EACjD,CACA,SAAS4rC,EAAYR,GACdA,EAAGpsC,aACgB,MAApBosC,EAAGnhD,MAAMyhD,SAAiBC,EAAGP,GACjCA,EAAGnhD,MAAMyhD,QAAU,EACnBlvC,WAAW,WAAamvC,EAAGP,EAAK,EAAG,KACrC,CAEA,SAASS,EAAe1oD,EAAI+M,EAAGhP,EAASuhB,GACtC,IAAIqpC,EAAUX,EAAYhoD,EAAI+M,EAAGhP,GACjC,SAAS6qD,IACPpqD,EAAWgH,IAAI8Z,EAAM,WAAYspC,GAC7BD,IAAWF,EAAYE,GAAUA,EAAU,KACjD,CACA,IAAIE,EAAOC,YAAY,WACrB,GAAIH,EAAS,IAAK,IAAIlpD,EAAI6f,GAAO7f,EAAIA,EAAEoc,WAAY,CAEjD,GADIpc,GAAmB,IAAdA,EAAE0+C,WAAgB1+C,EAAIA,EAAEspD,MAC7BtpD,GAAKgH,SAASyW,KAAM,OACxB,IAAKzd,EAAG,CAAEmpD,IAAQ,KAAO,CAC3B,CACA,IAAKD,EAAS,OAAOK,cAAcH,EACrC,EAAG,KACHrqD,EAAWyG,GAAGqa,EAAM,WAAYspC,EAClC,CAEA,SAASK,EAAUjpD,EAAIkpD,EAAMC,GAM3B,IAAK,IAAI1wC,KALTd,KAAKwQ,OAAS,GACV+gC,aAAgBE,WAAUF,EAAO,CAACG,eAAgBH,IACjDA,IAAiB,IAATA,IAAeA,EAAO,CAAC,GACpCvxC,KAAKD,QAAU,CAAC,EAChBC,KAAK2xC,cAAgBJ,EAAKxxC,SAAW,CAAC,EACrB6xC,EAAU5xC,KAAKD,QAAQe,GAAQ8wC,EAAS9wC,GACzD,IAAK,IAAIA,KAAQywC,EACXK,EAAShkD,eAAekT,GACR,MAAdywC,EAAKzwC,KAAed,KAAKD,QAAQe,GAAQywC,EAAKzwC,IACxCywC,EAAKxxC,UACfC,KAAK2xC,cAAc7wC,GAAQywC,EAAKzwC,IAGpCd,KAAK6xC,QAAU,KACf7xC,KAAKwxC,UAAYA,EACjBxxC,KAAK8xC,YAAc,SAAS18C,GAAK08C,EAAYzpD,EAAI+M,EAAI,EACrD4K,KAAK+xC,WAAa,CACpB,CAEA,IAAIH,EAAW,CACbI,gBAAgB,EAChBC,UAAU,EACVC,MAAO,IACPC,cAAc,EACdT,eAAgB,KAChB/wC,OAAO,EACPgwC,YAAa,KACbyB,iBAAkB,KAClBC,gBAAiB,MAGnB,SAASC,EAAWjqD,GAClB,IAAIsD,EAAQtD,EAAGsD,MAAM+kD,KACjB/kD,EAAM6lD,WAAWnpD,EAAGkqD,YAAYpC,GAChCxkD,EAAMoU,QAAQiyC,gBAAgBQ,EAAgBnqD,GAClD,IAAK,IAAI+D,EAAI,EAAGA,EAAIT,EAAM6kB,OAAO9oB,SAAU0E,EACzCT,EAAM6kB,OAAOpkB,GAAGiR,QAClB1R,EAAM6kB,OAAO9oB,OAAS,CACxB,CAEA,SAAS8qD,EAAgBnqD,GACvBA,EAAGoqD,SAAS,SAASrrD,GACnB,IAAIsrD,EAAMtrD,EAAKurD,WAAa,+BAA+Bx2C,KAAK/U,EAAKurD,WACjED,GAAKrqD,EAAGuqD,gBAAgBxrD,EAAM,OAAQsrD,EAAI,GAChD,EACF,CAEA,SAASG,EAAWxqD,EAAIyqD,EAAQC,EAAUC,EAAUf,GAClD,IAAIgB,EAASnkD,SAASG,cAAc,OAAQsiB,EAAQ0hC,EAWpD,OAVAA,EAAOnuC,UAAY,iDAAmDiuC,EAClEC,IACFzhC,EAAQ0hC,EAAO5jD,YAAYP,SAASG,cAAc,QAClDsiB,EAAMzM,UAAY,0DAGJ,GAAZmtC,GAAmBprD,EAAWyG,GAAGikB,EAAO,YAAa,SAASnc,GAChE27C,EAAe1oD,EAAI+M,EAAG09C,EAAQvhC,EAChC,GAEO0hC,CACT,CAEA,SAASC,EAAehsD,EAAGC,GACzB,MAAS,SAALD,EAAqBA,EACbC,CACd,CAEA,SAASgsD,EAAYC,GAEnB,IADA,IAAI94C,EAAQ,GACHlO,EAAI,EAAGA,EAAIgnD,EAAY1rD,SAAU0E,EAAG,CAC3C,IAAIinD,EAAMD,EAAYhnD,GAAIhF,EAAOisD,EAAI/qD,KAAKlB,MACzCkT,EAAMlT,KAAUkT,EAAMlT,GAAQ,KAAKK,KAAK4rD,EAC3C,CACA,OAAO/4C,CACT,CAEA,SAASg5C,EAAkBD,GACzB,IAAIN,EAAWM,EAAIN,SACdA,IAAUA,EAAW,SAC1B,IAAIQ,EAAMzkD,SAASG,cAAc,OAOjC,OANAskD,EAAIzuC,UAAY,mDAAqDiuC,EACvC,oBAAnBM,EAAIG,YACbD,EAAIp3B,UAAYk3B,EAAIG,YAEpBD,EAAIlkD,YAAYP,SAASQ,eAAe+jD,EAAIt3B,UAEvCw3B,CACT,CAEA,SAASE,EAAUprD,EAAIqpD,GACrB,IAAI/lD,EAAQtD,EAAGsD,MAAM+kD,KACjBlqD,IAAOmF,EAAMomD,WACjB,SAAS2B,IACPltD,GAAM,EACN6B,EAAGwF,IAAI,SAAU6lD,EACnB,CACArrD,EAAGiF,GAAG,SAAUomD,GAChBhC,EAAerpD,EAAGsrD,WAAY,SAASP,EAAaQ,GAClDvrD,EAAGwF,IAAI,SAAU6lD,GACb/nD,EAAMomD,YAAcvrD,IACpBotD,GAAQR,aAAuBvsD,IAAYusD,EAAcQ,GAC7DvrD,EAAG4N,UAAU,WAAY49C,EAAcxrD,EAAI+qD,EAAY,GACzD,EAAGznD,EAAMgmD,cAAetpD,EAC1B,CAEA,SAASyrD,EAAazrD,GACpB,IAAIsD,EAAQtD,EAAGsD,MAAM+kD,KACrB,GAAK/kD,EAAL,CACA,IAAIoU,EAAUpU,EAAMoU,QAKhB2xC,EAAiB3xC,EAAQ2xC,gBAAkBrpD,EAAG0hB,UAAUljB,EAAWG,IAAI,EAAG,GAAI,QAClF,GAAK0qD,EACL,GAAI3xC,EAAQY,OAAS+wC,EAAe/wC,MAClC8yC,EAAUprD,EAAIqpD,OACT,CACL,IAAI0B,EAAc1B,EAAerpD,EAAGsrD,WAAYhoD,EAAMgmD,cAAetpD,GACrE,IAAK+qD,EAAa,OACdA,EAAY5pC,KAAM4pC,EAAY5pC,KAAK,SAASuqC,GAC9C1rD,EAAG4N,UAAU,WAAY49C,EAAcxrD,EAAI0rD,EAAO,EACpD,GACK1rD,EAAG4N,UAAU,WAAY49C,EAAcxrD,EAAI+qD,EAAY,EAC9D,CAjBkB,CAkBpB,CAEA,SAASS,EAAcxrD,EAAI2rD,GACzB,IAAIroD,EAAQtD,EAAGsD,MAAM+kD,KACrB,GAAK/kD,EAAL,CACA,IAAIoU,EAAUpU,EAAMoU,QACpBuyC,EAAWjqD,GAIX,IAFA,IAAI+qD,EAAcD,EAAYa,GAErB5sD,EAAO,EAAGA,EAAOgsD,EAAY1rD,SAAUN,EAAM,CACpD,IAAI6sD,EAAOb,EAAYhsD,GACvB,GAAK6sD,EAAL,CAKA,IAHA,IAAIC,EAAc,KACdC,EAAWxoD,EAAM6lD,WAAa1iD,SAASC,yBAElC3C,EAAI,EAAGA,EAAI6nD,EAAKvsD,SAAU0E,EAAG,CACpC,IAAIinD,EAAMY,EAAK7nD,GACX2mD,EAAWM,EAAIN,SACdA,IAAUA,EAAW,SAC1BmB,EAAchB,EAAegB,EAAanB,GAEtChzC,EAAQqyC,mBAAkBiB,EAAMtzC,EAAQqyC,iBAAiBiB,IACzD1nD,EAAM6lD,WAAW2C,EAAS9kD,YAAYikD,EAAkBD,IAExDA,EAAI9qD,IAAIoD,EAAM6kB,OAAO/oB,KAAKY,EAAGmV,SAAS61C,EAAI/qD,KAAM+qD,EAAI9qD,GAAI,CAC1Duc,UAAW,6CAA+CiuC,EAC1DqB,aAAcf,IAElB,CACI1nD,EAAM6lD,WACRnpD,EAAGgsD,gBAAgBjtD,EAAM+oD,EAAW0C,EAAWxqD,EAAI8rD,EAAUD,EAAaD,EAAKvsD,OAAS,EACzCqY,EAAQkyC,WAErDlyC,EAAQiyC,gBACV3pD,EAAGisD,aAAaltD,EAAM,OAAQgpD,EAAe8D,EAxB5B,CAyBrB,CACIn0C,EAAQsyC,iBAAiBtyC,EAAQsyC,gBAAgB2B,EAAsBZ,EAAa/qD,EAlCtE,CAmCpB,CAEA,SAASm2B,EAASn2B,GAChB,IAAIsD,EAAQtD,EAAGsD,MAAM+kD,KAChB/kD,IACLiW,aAAajW,EAAMkmD,SACnBlmD,EAAMkmD,QAAUnwC,WAAW,WAAWoyC,EAAazrD,EAAI,EAAGsD,EAAMoU,QAAQmyC,OAC1E,CAEA,SAASqC,EAAclsD,EAAI+qD,EAAah+C,GAGtC,IAFA,IAAI4F,EAAS5F,EAAE4F,QAAU5F,EAAEwT,WACvBooC,EAAUliD,SAASC,yBACd3C,EAAI,EAAGA,EAAIgnD,EAAY1rD,OAAQ0E,IAAK,CAC3C,IAAIinD,EAAMD,EAAYhnD,GACtB4kD,EAAQ3hD,YAAYikD,EAAkBD,GACxC,CACAtC,EAAe1oD,EAAI+M,EAAG47C,EAASh2C,EACjC,CAEA,SAAS82C,EAAYzpD,EAAI+M,GACvB,IAAI4F,EAAS5F,EAAE4F,QAAU5F,EAAEwT,WAC3B,GAAK,0BAA0B9e,KAAKkR,EAAO8J,WAA3C,CAKA,IAJA,IAAIgC,EAAM9L,EAAOiL,wBAAyBuuC,GAAK1tC,EAAI9P,KAAO8P,EAAIW,OAAS,EAAGwzB,GAAKn0B,EAAInP,IAAMmP,EAAIrX,QAAU,EACnGglD,EAAQpsD,EAAG4U,YAAY5U,EAAG4uC,WAAW,CAACjgC,KAAMw9C,EAAG78C,IAAKsjC,GAAI,WAExDmY,EAAc,GACThnD,EAAI,EAAGA,EAAIqoD,EAAM/sD,SAAU0E,EAAG,CACrC,IAAIinD,EAAMoB,EAAMroD,GAAGgoD,aACff,GAAKD,EAAY3rD,KAAK4rD,EAC5B,CACID,EAAY1rD,QAAQ6sD,EAAclsD,EAAI+qD,EAAah+C,EATM,CAU/D,CAEAvO,EAAW2kB,aAAa,QAAQ,EAAO,SAASnjB,EAAIqb,EAAK4b,GAUvD,GATIA,GAAOA,GAAOz4B,EAAWo9B,OAC3BquB,EAAWjqD,IACgC,IAAvCA,EAAGsD,MAAM+kD,KAAK3wC,QAAQoyC,cACxB9pD,EAAGwF,IAAI,SAAU2wB,GACnB33B,EAAWgH,IAAIxF,EAAGkgB,oBAAqB,YAAalgB,EAAGsD,MAAM+kD,KAAKoB,aAClElwC,aAAavZ,EAAGsD,MAAM+kD,KAAKmB,gBACpBxpD,EAAGsD,MAAM+kD,MAGdhtC,EAAK,CAEP,IADA,IAAIgxC,EAAUrsD,EAAGoL,UAAU,WAAYkhD,GAAgB,EAC9CvoD,EAAI,EAAGA,EAAIsoD,EAAQhtD,SAAU0E,EAAOsoD,EAAQtoD,IAAM+jD,IAAWwE,GAAgB,GACtF,IAAIhpD,EAAQtD,EAAGsD,MAAM+kD,KAAO,IAAIY,EAAUjpD,EAAIqb,EAAKixC,GAC/ChpD,EAAMoU,QAAQoyC,cAChB9pD,EAAGiF,GAAG,SAAUkxB,GACY,GAA1B7yB,EAAMoU,QAAQkyC,UAA+C,UAA1BtmD,EAAMoU,QAAQkyC,UACnDprD,EAAWyG,GAAGjF,EAAGkgB,oBAAqB,YAAa5c,EAAMmmD,aAE3DgC,EAAazrD,EACf,CACF,GAEAxB,EAAWka,gBAAgB,cAAe,WACxC+yC,EAAa9zC,KACf,EACF,E,qPC5RA,IAAI5Z,EAAU,EAAQ,OACnBA,EAAQC,aAAYD,EAAUA,EAAQE,SACnB,kBAAZF,IAAsBA,EAAU,CAAC,CAACG,EAAOC,GAAIJ,EAAS,MAC7DA,EAAQK,SAAQF,EAAOG,QAAUN,EAAQK,QAE5C,IAAIE,EAAM,WACGA,EAAI,WAAYP,GAAS,EAAM,CAAC,WAAY,EAAM,YAAa,G,yGCNxEuO,EAA0B,IAA4B,KAE1DA,EAAwBlN,KAAK,CAAClB,EAAOC,GAAI,0bAA2b,KAEpe,S,kBCJA,IAAIJ,EAAU,EAAQ,OACnBA,EAAQC,aAAYD,EAAUA,EAAQE,SACnB,kBAAZF,IAAsBA,EAAU,CAAC,CAACG,EAAOC,GAAIJ,EAAS,MAC7DA,EAAQK,SAAQF,EAAOG,QAAUN,EAAQK,QAE5C,IAAIE,EAAM,WACGA,EAAI,WAAYP,GAAS,EAAM,CAAC,WAAY,EAAM,YAAa,G,yGCNxEuO,EAA0B,IAA4B,KAE1DA,EAAwBlN,KAAK,CAAClB,EAAOC,GAAI,2mDAA4mD,KAErpD,S,mBCJA,SAAUI,GAENA,EAAI,EAAQ,OAKf,EAPD,CAOG,SAASC,GACV,IAAI+tD,EAAS,UAAU9qD,KAAKqZ,UAAU0xC,aACV,MAAzB/lD,SAASgmD,cAAwBhmD,SAASgmD,aAAe,GAExD9tD,EAAMH,EAAWG,IAEjB+tD,EAAW,CAAC,IAAK,KAAM,IAAK,KAAM,IAAK,KAAM,IAAK,KAAM,IAAK,KAAM,IAAK,KAAM,IAAK,KAAM,IAAK,MAElG,SAASzc,EAAahsB,GACpB,OAAOA,GAAUA,EAAOgsB,cAAgB,WAC1C,CAEA,SAAS1tC,EAAoBvC,EAAI2sD,EAAO1oC,GACtC,IAAIllB,EAAOiB,EAAG2jD,cAAcgJ,EAAM5tD,MAAOuB,EAAMqsD,EAAM3tD,GAAK,EACtD4tD,EAAc3oC,GAAUA,EAAO2oC,YAChB,MAAfA,IACFA,EAAc,0BAA0BnrD,KAAKzB,EAAGkgB,oBAAoBzD,YACtE,IAAIgH,EAAKwsB,EAAahsB,GAMlBxhB,GAAUmqD,GAAetsD,GAAO,GAAKmjB,EAAGhiB,KAAK1C,EAAKqB,KAAKgC,OAAO9B,KAASosD,EAAS3tD,EAAKqB,KAAKgC,OAAO9B,KACjGmjB,EAAGhiB,KAAK1C,EAAKqB,KAAKgC,OAAO9B,EAAM,KAAOosD,EAAS3tD,EAAKqB,KAAKgC,SAAS9B,IACtE,IAAKmC,EAAO,OAAO,KACnB,IAAI7B,EAAyB,KAAnB6B,EAAML,OAAO,GAAY,GAAK,EACxC,GAAI6hB,GAAUA,EAAOzhB,QAAW5B,EAAM,IAAON,GAAOqsD,EAAM3tD,IAAK,OAAO,KACtE,IAAI8H,EAAQ9G,EAAG+S,eAAepU,EAAIguD,EAAM5tD,KAAMuB,EAAM,IAEhDqQ,EAAQY,EAAevR,EAAIrB,EAAIguD,EAAM5tD,KAAMuB,GAAOM,EAAM,EAAI,EAAI,IAAKA,EAAKkG,EAAOmd,GACrF,OAAa,MAATtT,EAAsB,KACnB,CAAC1Q,KAAMtB,EAAIguD,EAAM5tD,KAAMuB,GAAMJ,GAAIyQ,GAASA,EAAMrQ,IAC/CmC,MAAOkO,GAASA,EAAM3R,IAAMyD,EAAML,OAAO,GAAIM,QAAS9B,EAAM,EACtE,CASA,SAAS2Q,EAAevR,EAAI2sD,EAAO/rD,EAAKkG,EAAOmd,GAQ7C,IAPA,IAAI4oC,EAAc5oC,GAAUA,EAAO6oC,mBAAsB,IACrDC,EAAgB9oC,GAAUA,EAAO8oC,cAAiB,IAElDtlD,EAAQ,GACRgc,EAAKwsB,EAAahsB,GAClB88B,EAAUngD,EAAM,EAAIlB,KAAKC,IAAIgtD,EAAM5tD,KAAOguD,EAAc/sD,EAAG8B,WAAa,GACpDpC,KAAKwe,IAAIle,EAAG4B,YAAc,EAAG+qD,EAAM5tD,KAAOguD,GACzDn3B,EAAS+2B,EAAM5tD,KAAM62B,GAAUmrB,EAASnrB,GAAUh1B,EAAK,CAC9D,IAAI7B,EAAOiB,EAAGuB,QAAQq0B,GACtB,GAAK72B,EAAL,CACA,IAAIuB,EAAMM,EAAM,EAAI,EAAI7B,EAAKM,OAAS,EAAG2D,EAAMpC,EAAM,EAAI7B,EAAKM,QAAU,EACxE,KAAIN,EAAKM,OAASwtD,GAElB,IADIj3B,GAAU+2B,EAAM5tD,OAAMuB,EAAMqsD,EAAM3tD,IAAM4B,EAAM,EAAI,EAAI,IACnDN,GAAO0C,EAAK1C,GAAOM,EAAK,CAC7B,IAAI5B,EAAKD,EAAKqD,OAAO9B,GACrB,GAAImjB,EAAGhiB,KAAKzC,UAAkB2S,IAAV7K,IACC9G,EAAG+S,eAAepU,EAAIi3B,EAAQt1B,EAAM,KAAO,MAAQwG,GAAS,KAAM,CACrF,IAAIrE,EAAQiqD,EAAS1tD,GACrB,GAAIyD,GAA6B,KAAnBA,EAAML,OAAO,IAAexB,EAAM,EAAI6G,EAAMrI,KAAKJ,OAC1D,KAAKyI,EAAMpI,OAAQ,MAAO,CAACiB,IAAK3B,EAAIi3B,EAAQt1B,GAAMtB,GAAIA,GACtDyI,EAAM5H,KAAK,CAClB,CACF,CAbmB,CAcrB,CACA,OAAO+1B,EAASh1B,IAAQA,EAAM,EAAIZ,EAAG8B,WAAa9B,EAAG4B,cAAuB,IAC9E,CAEA,SAASorD,EAAchtD,EAAIitD,EAAWhpC,GAKpC,IAHA,IAAIipC,EAAkBltD,EAAGsD,MAAM0pD,cAAcG,wBAA0B,IACrEC,EAAuBnpC,GAAUA,EAAOmpC,qBACtC/4C,EAAQ,GAAI/F,EAAStO,EAAGyE,iBACnBV,EAAI,EAAGA,EAAIuK,EAAOjP,OAAQ0E,IAAK,CACtC,IAAItB,EAAQ6L,EAAOvK,GAAGwJ,SAAWhL,EAAoBvC,EAAIsO,EAAOvK,GAAGW,KAAMuf,GACzE,GAAIxhB,IAAUA,EAAMA,QAAkC,IAAzB2qD,IAAmCptD,EAAGuB,QAAQkB,EAAMxC,KAAKlB,MAAMM,QAAU6tD,EAAiB,CACrH,IAAIpmD,EAAQrE,EAAMA,MAAQ,6BAA+B,gCACzD4R,EAAMjV,KAAKY,EAAGmV,SAAS1S,EAAMxC,KAAMtB,EAAI8D,EAAMxC,KAAKlB,KAAM0D,EAAMxC,KAAKjB,GAAK,GAAI,CAACyd,UAAW3V,KACpFrE,EAAMvC,IAAMF,EAAGuB,QAAQkB,EAAMvC,GAAGnB,MAAMM,QAAU6tD,GAClD74C,EAAMjV,KAAKY,EAAGmV,SAAS1S,EAAMvC,GAAIvB,EAAI8D,EAAMvC,GAAGnB,KAAM0D,EAAMvC,GAAGlB,GAAK,GAAI,CAACyd,UAAW3V,IACtF,CACF,CAEA,GAAIuN,EAAMhV,OAAQ,CAGZktD,GAAUvsD,EAAGsD,MAAM+pD,SAASrtD,EAAGygB,QAEnC,IAAIzL,EAAQ,WACVhV,EAAG4N,UAAU,WACX,IAAK,IAAI7J,EAAI,EAAGA,EAAIsQ,EAAMhV,OAAQ0E,IAAKsQ,EAAMtQ,GAAGiR,OAClD,EACF,EACA,IAAIi4C,EACC,OAAOj4C,EADGqE,WAAWrE,EAAO,IAEnC,CACF,CAEA,SAASs4C,EAAgBttD,GACvBA,EAAG4N,UAAU,WACP5N,EAAGsD,MAAM0pD,cAAcO,uBACzBvtD,EAAGsD,MAAM0pD,cAAcO,uBACvBvtD,EAAGsD,MAAM0pD,cAAcO,qBAAuB,MAEhDvtD,EAAGsD,MAAM0pD,cAAcO,qBAAuBP,EAAchtD,GAAI,EAAOA,EAAGsD,MAAM0pD,cAClF,EACF,CAEA,SAASQ,EAAiBxtD,GACpBA,EAAGsD,MAAM0pD,eAAiBhtD,EAAGsD,MAAM0pD,cAAcO,uBACnDvtD,EAAGsD,MAAM0pD,cAAcO,uBACvBvtD,EAAGsD,MAAM0pD,cAAcO,qBAAuB,KAElD,CAEA/uD,EAAW2kB,aAAa,iBAAiB,EAAO,SAASnjB,EAAIqb,EAAK4b,GAC5DA,GAAOA,GAAOz4B,EAAWo9B,OAC3B57B,EAAGwF,IAAI,iBAAkB8nD,GACzBttD,EAAGwF,IAAI,QAAS8nD,GAChBttD,EAAGwF,IAAI,OAAQgoD,GACfA,EAAiBxtD,IAEfqb,IACFrb,EAAGsD,MAAM0pD,cAA8B,iBAAP3xC,EAAkBA,EAAM,CAAC,EACzDrb,EAAGiF,GAAG,iBAAkBqoD,GACxBttD,EAAGiF,GAAG,QAASqoD,GACfttD,EAAGiF,GAAG,OAAQuoD,GAElB,GAEAhvD,EAAWka,gBAAgB,gBAAiB,WAAYs0C,EAAcr1C,MAAM,EAAM,GAClFnZ,EAAWka,gBAAgB,sBAAuB,SAASpY,EAAK2jB,EAAQwpC,GAUtE,OARIA,GAA8B,kBAAVxpC,KACjBwpC,GAGHA,EAAUjrD,OAASyhB,EACnBA,EAASwpC,GAHTxpC,EAASA,EAAS,CAACzhB,QAAQ,GAAQ,MAMhCD,EAAoBoV,KAAMrX,EAAK2jB,EACxC,GACAzlB,EAAWka,gBAAgB,iBAAkB,SAASpY,EAAKM,EAAKkG,EAAOmd,GACrE,OAAO1S,EAAeoG,KAAMrX,EAAKM,EAAKkG,EAAOmd,EAC/C,EACF,E","sources":["webpack://cluster-log-extension/./node_modules/codemirror/theme/base16-light.css?2ba3","webpack://cluster-log-extension/./node_modules/codemirror/keymap/emacs.js","webpack://cluster-log-extension/./node_modules/codemirror/addon/lint/lint.css","webpack://cluster-log-extension/./node_modules/codemirror/keymap/sublime.js","webpack://cluster-log-extension/./node_modules/codemirror/addon/hint/show-hint.js","webpack://cluster-log-extension/./node_modules/codemirror/addon/hint/anyword-hint.js","webpack://cluster-log-extension/./node_modules/codemirror/mode/javascript/javascript.js","webpack://cluster-log-extension/./node_modules/codemirror/mode/yaml/yaml.js","webpack://cluster-log-extension/./node_modules/codemirror/addon/search/searchcursor.js","webpack://cluster-log-extension/./node_modules/codemirror/addon/lint/yaml-lint.js","webpack://cluster-log-extension/./node_modules/codemirror/addon/dialog/dialog.js","webpack://cluster-log-extension/./node_modules/codemirror/addon/lint/lint.css?c388","webpack://cluster-log-extension/./node_modules/@rancher/shell/plugins/codemirror.js","webpack://cluster-log-extension/./node_modules/codemirror/theme/base16-dark.css","webpack://cluster-log-extension/./node_modules/codemirror/keymap/vim.js","webpack://cluster-log-extension/./node_modules/codemirror/addon/lint/lint.js","webpack://cluster-log-extension/./node_modules/codemirror/theme/base16-dark.css?9066","webpack://cluster-log-extension/./node_modules/codemirror/addon/hint/show-hint.css","webpack://cluster-log-extension/./node_modules/codemirror/addon/hint/show-hint.css?46e0","webpack://cluster-log-extension/./node_modules/codemirror/theme/base16-light.css","webpack://cluster-log-extension/./node_modules/codemirror/addon/edit/matchbrackets.js"],"sourcesContent":["// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./base16-light.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"21518f5a\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n  function posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\n  // Kill 'ring'\n\n  var killRing = [];\n  function addToRing(str) {\n    killRing.push(str);\n    if (killRing.length > 50) killRing.shift();\n  }\n  function growRingTop(str) {\n    if (!killRing.length) return addToRing(str);\n    killRing[killRing.length - 1] += str;\n  }\n  function getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\n  function popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\n  var lastKill = null;\n\n  // Internal generic kill function, used by several mapped kill \"family\" functions.\n  function _kill(cm, from, to, ring, text) {\n    if (text == null) text = cm.getRange(from, to);\n\n    if (ring == \"grow\" && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n      growRingTop(text);\n    else if (ring !== false)\n      addToRing(text);\n    cm.replaceRange(\"\", from, to, \"+delete\");\n\n    if (ring == \"grow\") lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n    else lastKill = null;\n  }\n\n  // Boundaries of various units\n\n  function byChar(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"char\", true);\n  }\n\n  function byWord(cm, pos, dir) {\n    return cm.findPosH(pos, dir, \"word\", true);\n  }\n\n  function byLine(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"line\", cm.doc.sel.goalColumn);\n  }\n\n  function byPage(cm, pos, dir) {\n    return cm.findPosV(pos, dir, \"page\", cm.doc.sel.goalColumn);\n  }\n\n  function byParagraph(cm, pos, dir) {\n    var no = pos.line, line = cm.getLine(no);\n    var sawText = /\\S/.test(dir < 0 ? line.slice(0, pos.ch) : line.slice(pos.ch));\n    var fst = cm.firstLine(), lst = cm.lastLine();\n    for (;;) {\n      no += dir;\n      if (no < fst || no > lst)\n        return cm.clipPos(Pos(no - dir, dir < 0 ? 0 : null));\n      line = cm.getLine(no);\n      var hasText = /\\S/.test(line);\n      if (hasText) sawText = true;\n      else if (sawText) return Pos(no, 0);\n    }\n  }\n\n  function bySentence(cm, pos, dir) {\n    var line = pos.line, ch = pos.ch;\n    var text = cm.getLine(pos.line), sawWord = false;\n    for (;;) {\n      var next = text.charAt(ch + (dir < 0 ? -1 : 0));\n      if (!next) { // End/beginning of line reached\n        if (line == (dir < 0 ? cm.firstLine() : cm.lastLine())) return Pos(line, ch);\n        text = cm.getLine(line + dir);\n        if (!/\\S/.test(text)) return Pos(line, ch);\n        line += dir;\n        ch = dir < 0 ? text.length : 0;\n        continue;\n      }\n      if (sawWord && /[!?.]/.test(next)) return Pos(line, ch + (dir > 0 ? 1 : 0));\n      if (!sawWord) sawWord = /\\w/.test(next);\n      ch += dir;\n    }\n  }\n\n  function byExpr(cm, pos, dir) {\n    var wrap;\n    if (cm.findMatchingBracket && (wrap = cm.findMatchingBracket(pos, {strict: true}))\n        && wrap.match && (wrap.forward ? 1 : -1) == dir)\n      return dir > 0 ? Pos(wrap.to.line, wrap.to.ch + 1) : wrap.to;\n\n    for (var first = true;; first = false) {\n      var token = cm.getTokenAt(pos);\n      var after = Pos(pos.line, dir < 0 ? token.start : token.end);\n      if (first && dir > 0 && token.end == pos.ch || !/\\w/.test(token.string)) {\n        var newPos = cm.findPosH(after, dir, \"char\");\n        if (posEq(after, newPos)) return pos;\n        else pos = newPos;\n      } else {\n        return after;\n      }\n    }\n  }\n\n  // Prefixes (only crudely supported)\n\n  function getPrefix(cm, precise) {\n    var digits = cm.state.emacsPrefix;\n    if (!digits) return precise ? null : 1;\n    clearPrefix(cm);\n    return digits == \"-\" ? -1 : Number(digits);\n  }\n\n  function repeated(cmd) {\n    var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n    return function(cm) {\n      var prefix = getPrefix(cm);\n      f(cm);\n      for (var i = 1; i < prefix; ++i) f(cm);\n    };\n  }\n\n  function findEnd(cm, pos, by, dir) {\n    var prefix = getPrefix(cm);\n    if (prefix < 0) { dir = -dir; prefix = -prefix; }\n    for (var i = 0; i < prefix; ++i) {\n      var newPos = by(cm, pos, dir);\n      if (posEq(newPos, pos)) break;\n      pos = newPos;\n    }\n    return pos;\n  }\n\n  function move(by, dir) {\n    var f = function(cm) {\n      cm.extendSelection(findEnd(cm, cm.getCursor(), by, dir));\n    };\n    f.motion = true;\n    return f;\n  }\n\n  function killTo(cm, by, dir, ring) {\n    var selections = cm.listSelections(), cursor;\n    var i = selections.length;\n    while (i--) {\n      cursor = selections[i].head;\n      _kill(cm, cursor, findEnd(cm, cursor, by, dir), ring);\n    }\n  }\n\n  function _killRegion(cm, ring) {\n    if (cm.somethingSelected()) {\n      var selections = cm.listSelections(), selection;\n      var i = selections.length;\n      while (i--) {\n        selection = selections[i];\n        _kill(cm, selection.anchor, selection.head, ring);\n      }\n      return true;\n    }\n  }\n\n  function addPrefix(cm, digit) {\n    if (cm.state.emacsPrefix) {\n      if (digit != \"-\") cm.state.emacsPrefix += digit;\n      return;\n    }\n    // Not active yet\n    cm.state.emacsPrefix = digit;\n    cm.on(\"keyHandled\", maybeClearPrefix);\n    cm.on(\"inputRead\", maybeDuplicateInput);\n  }\n\n  var prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\n  function maybeClearPrefix(cm, arg) {\n    if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n      clearPrefix(cm);\n  }\n\n  function clearPrefix(cm) {\n    cm.state.emacsPrefix = null;\n    cm.off(\"keyHandled\", maybeClearPrefix);\n    cm.off(\"inputRead\", maybeDuplicateInput);\n  }\n\n  function maybeDuplicateInput(cm, event) {\n    var dup = getPrefix(cm);\n    if (dup > 1 && event.origin == \"+input\") {\n      var one = event.text.join(\"\\n\"), txt = \"\";\n      for (var i = 1; i < dup; ++i) txt += one;\n      cm.replaceSelection(txt);\n    }\n  }\n\n  function maybeRemovePrefixMap(cm, arg) {\n    if (typeof arg == \"string\" && (/^\\d$/.test(arg) || arg == \"Ctrl-U\")) return;\n    cm.removeKeyMap(prefixMap);\n    cm.state.emacsPrefixMap = false;\n    cm.off(\"keyHandled\", maybeRemovePrefixMap);\n    cm.off(\"inputRead\", maybeRemovePrefixMap);\n  }\n\n  // Utilities\n\n  cmds.setMark = function (cm) {\n    cm.setCursor(cm.getCursor());\n    cm.setExtending(!cm.getExtending());\n    cm.on(\"change\", function() { cm.setExtending(false); });\n  }\n\n  function clearMark(cm) {\n    cm.setExtending(false);\n    cm.setCursor(cm.getCursor());\n  }\n\n  function makePrompt(msg) {\n    var fragment = document.createDocumentFragment();\n    var input = document.createElement(\"input\");\n    input.setAttribute(\"type\", \"text\");\n    input.style.width = \"10em\";\n    fragment.appendChild(document.createTextNode(msg + \": \"));\n    fragment.appendChild(input);\n    return fragment;\n  }\n\n  function getInput(cm, msg, f) {\n    if (cm.openDialog)\n      cm.openDialog(makePrompt(msg), f, {bottom: true});\n    else\n      f(prompt(msg, \"\"));\n  }\n\n  function operateOnWord(cm, op) {\n    var start = cm.getCursor(), end = cm.findPosH(start, 1, \"word\");\n    cm.replaceRange(op(cm.getRange(start, end)), start, end);\n    cm.setCursor(end);\n  }\n\n  function toEnclosingExpr(cm) {\n    var pos = cm.getCursor(), line = pos.line, ch = pos.ch;\n    var stack = [];\n    while (line >= cm.firstLine()) {\n      var text = cm.getLine(line);\n      for (var i = ch == null ? text.length : ch; i > 0;) {\n        var ch = text.charAt(--i);\n        if (ch == \")\")\n          stack.push(\"(\");\n        else if (ch == \"]\")\n          stack.push(\"[\");\n        else if (ch == \"}\")\n          stack.push(\"{\");\n        else if (/[\\(\\{\\[]/.test(ch) && (!stack.length || stack.pop() != ch))\n          return cm.extendSelection(Pos(line, i));\n      }\n      --line; ch = null;\n    }\n  }\n\n  // Commands. Names should match emacs function names (albeit in camelCase)\n  // except where emacs function names collide with code mirror core commands.\n\n  cmds.killRegion = function(cm) {\n    _kill(cm, cm.getCursor(\"start\"), cm.getCursor(\"end\"), true);\n  };\n\n  // Maps to emacs kill-line\n  cmds.killLineEmacs = repeated(function(cm) {\n    var start = cm.getCursor(), end = cm.clipPos(Pos(start.line));\n    var text = cm.getRange(start, end);\n    if (!/\\S/.test(text)) {\n      text += \"\\n\";\n      end = Pos(start.line + 1, 0);\n    }\n    _kill(cm, start, end, \"grow\", text);\n  });\n\n  cmds.killRingSave = function(cm) {\n    addToRing(cm.getSelection());\n    clearMark(cm);\n  };\n\n  cmds.yank = function(cm) {\n    var start = cm.getCursor();\n    cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n    cm.setSelection(start, cm.getCursor());\n  };\n\n  cmds.yankPop = function(cm) {\n    cm.replaceSelection(popFromRing(), \"around\", \"paste\");\n  };\n\n  cmds.forwardChar = move(byChar, 1);\n\n  cmds.backwardChar = move(byChar, -1)\n\n  cmds.deleteChar = function(cm) { killTo(cm, byChar, 1, false); };\n\n  cmds.deleteForwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, 1, false);\n  };\n\n  cmds.deleteBackwardChar = function(cm) {\n    _killRegion(cm, false) || killTo(cm, byChar, -1, false);\n  };\n\n  cmds.forwardWord = move(byWord, 1);\n\n  cmds.backwardWord = move(byWord, -1);\n\n  cmds.killWord = function(cm) { killTo(cm, byWord, 1, \"grow\"); };\n\n  cmds.backwardKillWord = function(cm) { killTo(cm, byWord, -1, \"grow\"); };\n\n  cmds.nextLine = move(byLine, 1);\n\n  cmds.previousLine = move(byLine, -1);\n\n  cmds.scrollDownCommand = move(byPage, -1);\n\n  cmds.scrollUpCommand = move(byPage, 1);\n\n  cmds.backwardParagraph = move(byParagraph, -1);\n\n  cmds.forwardParagraph = move(byParagraph, 1);\n\n  cmds.backwardSentence = move(bySentence, -1);\n\n  cmds.forwardSentence = move(bySentence, 1);\n\n  cmds.killSentence = function(cm) { killTo(cm, bySentence, 1, \"grow\"); };\n\n  cmds.backwardKillSentence = function(cm) {\n    _kill(cm, cm.getCursor(), bySentence(cm, cm.getCursor(), 1), \"grow\");\n  };\n\n  cmds.killSexp = function(cm) { killTo(cm, byExpr, 1, \"grow\"); };\n\n  cmds.backwardKillSexp = function(cm) { killTo(cm, byExpr, -1, \"grow\"); };\n\n  cmds.forwardSexp = move(byExpr, 1);\n\n  cmds.backwardSexp = move(byExpr, -1);\n\n  cmds.markSexp = function(cm) {\n    var cursor = cm.getCursor();\n    cm.setSelection(findEnd(cm, cursor, byExpr, 1), cursor);\n  };\n\n  cmds.transposeSexps = function(cm) {\n    var leftStart = byExpr(cm, cm.getCursor(), -1);\n    var leftEnd = byExpr(cm, leftStart, 1);\n    var rightEnd = byExpr(cm, leftEnd, 1);\n    var rightStart = byExpr(cm, rightEnd, -1);\n    cm.replaceRange(cm.getRange(rightStart, rightEnd) +\n                    cm.getRange(leftEnd, rightStart) +\n                    cm.getRange(leftStart, leftEnd), leftStart, rightEnd);\n  };\n\n  cmds.backwardUpList = repeated(toEnclosingExpr);\n\n  cmds.justOneSpace = function(cm) {\n    var pos = cm.getCursor(), from = pos.ch;\n    var to = pos.ch, text = cm.getLine(pos.line);\n    while (from && /\\s/.test(text.charAt(from - 1))) --from;\n    while (to < text.length && /\\s/.test(text.charAt(to))) ++to;\n    cm.replaceRange(\" \", Pos(pos.line, from), Pos(pos.line, to));\n  };\n\n  cmds.openLine = repeated(function(cm) {\n    cm.replaceSelection(\"\\n\", \"start\");\n  });\n\n  // maps to emacs 'transpose-chars'\n  cmds.transposeCharsRepeatable = repeated(function(cm) {\n    cm.execCommand(\"transposeChars\");\n  });\n\n  cmds.capitalizeWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) {\n      var letter = w.search(/\\w/);\n      if (letter == -1) return w;\n      return w.slice(0, letter) + w.charAt(letter).toUpperCase() +\n          w.slice(letter + 1).toLowerCase();\n    });\n  });\n\n  cmds.upcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toUpperCase(); });\n  });\n\n  cmds.downcaseWord = repeated(function(cm) {\n    operateOnWord(cm, function(w) { return w.toLowerCase(); });\n  });\n\n  // maps to emacs 'undo'\n  cmds.undoRepeatable = repeated(\"undo\");\n\n  cmds.keyboardQuit = function(cm) {\n    cm.execCommand(\"clearSearch\");\n    clearMark(cm);\n  }\n\n  cmds.newline = repeated(function(cm) { cm.replaceSelection(\"\\n\", \"end\"); });\n\n  cmds.gotoLine = function(cm) {\n    var prefix = getPrefix(cm, true);\n    if (prefix != null && prefix > 0) return cm.setCursor(prefix - 1);\n\n    getInput(cm, \"Goto line\", function(str) {\n      var num;\n      if (str && !isNaN(num = Number(str)) && num == (num|0) && num > 0)\n      cm.setCursor(num - 1);\n    });\n  };\n\n  cmds.indentRigidly = function(cm) {\n    cm.indentSelection(getPrefix(cm, true) || cm.getOption(\"indentUnit\"));\n  };\n\n  cmds.exchangePointAndMark = function(cm) {\n    cm.setSelection(cm.getCursor(\"head\"), cm.getCursor(\"anchor\"));\n  };\n\n  cmds.quotedInsertTab = repeated(\"insertTab\");\n\n  cmds.universalArgument = function addPrefixMap(cm) {\n    cm.state.emacsPrefixMap = true;\n    cm.addKeyMap(prefixMap);\n    cm.on(\"keyHandled\", maybeRemovePrefixMap);\n    cm.on(\"inputRead\", maybeRemovePrefixMap);\n  };\n\n  CodeMirror.emacs = {kill: _kill, killRegion: _killRegion, repeated: repeated};\n\n  // Actual keymap\n  var keyMap = CodeMirror.keyMap.emacs = CodeMirror.normalizeKeyMap({\n    \"Ctrl-W\": \"killRegion\",\n    \"Ctrl-K\": \"killLineEmacs\",\n    \"Alt-W\": \"killRingSave\",\n    \"Ctrl-Y\": \"yank\",\n    \"Alt-Y\": \"yankPop\",\n    \"Ctrl-Space\": \"setMark\",\n    \"Ctrl-Shift-2\": \"setMark\",\n    \"Ctrl-F\": \"forwardChar\",\n    \"Ctrl-B\": \"backwardChar\",\n    \"Right\": \"forwardChar\",\n    \"Left\": \"backwardChar\",\n    \"Ctrl-D\": \"deleteChar\",\n    \"Delete\": \"deleteForwardChar\",\n    \"Ctrl-H\": \"deleteBackwardChar\",\n    \"Backspace\": \"deleteBackwardChar\",\n    \"Alt-F\": \"forwardWord\",\n    \"Alt-B\": \"backwardWord\",\n    \"Alt-Right\": \"forwardWord\",\n    \"Alt-Left\": \"backwardWord\",\n    \"Alt-D\": \"killWord\",\n    \"Alt-Backspace\": \"backwardKillWord\",\n    \"Ctrl-N\": \"nextLine\",\n    \"Ctrl-P\": \"previousLine\",\n    \"Down\": \"nextLine\",\n    \"Up\": \"previousLine\",\n    \"Ctrl-A\": \"goLineStart\",\n    \"Ctrl-E\": \"goLineEnd\",\n    \"End\": \"goLineEnd\",\n    \"Home\": \"goLineStart\",\n    \"Alt-V\": \"scrollDownCommand\",\n    \"Ctrl-V\": \"scrollUpCommand\",\n    \"PageUp\": \"scrollDownCommand\",\n    \"PageDown\": \"scrollUpCommand\",\n    \"Ctrl-Up\": \"backwardParagraph\",\n    \"Ctrl-Down\": \"forwardParagraph\",\n    \"Alt-{\": \"backwardParagraph\",\n    \"Alt-}\": \"forwardParagraph\",\n    \"Alt-A\": \"backwardSentence\",\n    \"Alt-E\": \"forwardSentence\",\n    \"Alt-K\": \"killSentence\",\n    \"Ctrl-X Delete\": \"backwardKillSentence\",\n    \"Ctrl-Alt-K\": \"killSexp\",\n    \"Ctrl-Alt-Backspace\": \"backwardKillSexp\",\n    \"Ctrl-Alt-F\": \"forwardSexp\",\n    \"Ctrl-Alt-B\": \"backwardSexp\",\n    \"Shift-Ctrl-Alt-2\": \"markSexp\",\n    \"Ctrl-Alt-T\": \"transposeSexps\",\n    \"Ctrl-Alt-U\": \"backwardUpList\",\n    \"Alt-Space\": \"justOneSpace\",\n    \"Ctrl-O\": \"openLine\",\n    \"Ctrl-T\": \"transposeCharsRepeatable\",\n    \"Alt-C\": \"capitalizeWord\",\n    \"Alt-U\": \"upcaseWord\",\n    \"Alt-L\": \"downcaseWord\",\n    \"Alt-;\": \"toggleComment\",\n    \"Ctrl-/\": \"undoRepeatable\",\n    \"Shift-Ctrl--\": \"undoRepeatable\",\n    \"Ctrl-Z\": \"undoRepeatable\",\n    \"Cmd-Z\": \"undoRepeatable\",\n    \"Ctrl-X U\": \"undoRepeatable\",\n    \"Shift-Ctrl-Z\": \"redo\",\n    \"Shift-Alt-,\": \"goDocStart\",\n    \"Shift-Alt-.\": \"goDocEnd\",\n    \"Ctrl-S\": \"findPersistentNext\",\n    \"Ctrl-R\": \"findPersistentPrev\",\n    \"Ctrl-G\": \"keyboardQuit\",\n    \"Shift-Alt-5\": \"replace\",\n    \"Alt-/\": \"autocomplete\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Ctrl-J\": \"newline\",\n    \"Tab\": \"indentAuto\",\n    \"Alt-G G\": \"gotoLine\",\n    \"Ctrl-X Tab\": \"indentRigidly\",\n    \"Ctrl-X Ctrl-X\": \"exchangePointAndMark\",\n    \"Ctrl-X Ctrl-S\": \"save\",\n    \"Ctrl-X Ctrl-W\": \"save\",\n    \"Ctrl-X S\": \"saveAll\",\n    \"Ctrl-X F\": \"open\",\n    \"Ctrl-X K\": \"close\",\n    \"Ctrl-X H\": \"selectAll\",\n    \"Ctrl-Q Tab\": \"quotedInsertTab\",\n    \"Ctrl-U\": \"universalArgument\",\n    \"fallthrough\": \"default\"\n  });\n\n  var prefixMap = {\"Ctrl-G\": clearPrefix};\n  function regPrefix(d) {\n    prefixMap[d] = function(cm) { addPrefix(cm, d); };\n    keyMap[\"Ctrl-\" + d] = function(cm) { addPrefix(cm, d); };\n    prefixPreservingKeys[\"Ctrl-\" + d] = true;\n  }\n  for (var i = 0; i < 10; ++i) regPrefix(String(i));\n  regPrefix(\"-\");\n});\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../../css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../css-loader/dist/runtime/api.js\";\nimport ___CSS_LOADER_GET_URL_IMPORT___ from \"../../../css-loader/dist/runtime/getUrl.js\";\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_1___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_2___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_3___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_4___ = new URL(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\", import.meta.url);\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\nvar ___CSS_LOADER_URL_REPLACEMENT_3___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_3___);\nvar ___CSS_LOADER_URL_REPLACEMENT_4___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_4___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.CodeMirror-lint-markers{width:16px}.CodeMirror-lint-tooltip{background-color:#ffd;border:1px solid #000;border-radius:4px 4px 4px 4px;color:#000;font-family:monospace;font-size:10pt;overflow:hidden;padding:2px 5px;position:fixed;white-space:pre;white-space:pre-wrap;z-index:100;max-width:600px;opacity:0;transition:opacity .4s;-moz-transition:opacity .4s;-webkit-transition:opacity .4s;-o-transition:opacity .4s;-ms-transition:opacity .4s}.CodeMirror-lint-mark{background-position:0 100%;background-repeat:repeat-x}.CodeMirror-lint-mark-warning{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_0___})}.CodeMirror-lint-mark-error{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_1___})}.CodeMirror-lint-marker{background-position:50%;background-repeat:no-repeat;cursor:pointer;display:inline-block;height:16px;width:16px;vertical-align:middle;position:relative}.CodeMirror-lint-message{padding-left:18px;background-position:0 0;background-repeat:no-repeat}.CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_2___})}.CodeMirror-lint-marker-error,.CodeMirror-lint-message-error{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_3___})}.CodeMirror-lint-marker-multiple{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_4___});background-repeat:no-repeat;background-position:100% 100%;width:100%;height:100%}.CodeMirror-lint-line-error{background-color:rgba(183,76,81,.08)}.CodeMirror-lint-line-warning{background-color:rgba(255,211,0,.1)}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// A rough approximation of Sublime Text's keybindings\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/edit/matchbrackets\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/edit/matchbrackets\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var cmds = CodeMirror.commands;\n  var Pos = CodeMirror.Pos;\n\n  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.\n  function findPosSubword(doc, start, dir) {\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\n    var line = doc.getLine(start.line);\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\n    var state = \"start\", type, startPos = start.ch;\n    for (var pos = startPos, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\n      var cat = next != \"_\" && CodeMirror.isWordChar(next) ? \"w\" : \"o\";\n      if (cat == \"w\" && next.toUpperCase() == next) cat = \"W\";\n      if (state == \"start\") {\n        if (cat != \"o\") { state = \"in\"; type = cat; }\n        else startPos = pos + dir\n      } else if (state == \"in\") {\n        if (type != cat) {\n          if (type == \"w\" && cat == \"W\" && dir < 0) pos--;\n          if (type == \"W\" && cat == \"w\" && dir > 0) { // From uppercase to lowercase\n            if (pos == startPos + 1) { type = \"w\"; continue; }\n            else pos--;\n          }\n          break;\n        }\n      }\n    }\n    return Pos(start.line, pos);\n  }\n\n  function moveSubword(cm, dir) {\n    cm.extendSelectionsBy(function(range) {\n      if (cm.display.shift || cm.doc.extend || range.empty())\n        return findPosSubword(cm.doc, range.head, dir);\n      else\n        return dir < 0 ? range.from() : range.to();\n    });\n  }\n\n  cmds.goSubwordLeft = function(cm) { moveSubword(cm, -1); };\n  cmds.goSubwordRight = function(cm) { moveSubword(cm, 1); };\n\n  cmds.scrollLineUp = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, \"local\");\n      if (cm.getCursor().line >= visibleBottomLine)\n        cm.execCommand(\"goLineUp\");\n    }\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\n  };\n  cmds.scrollLineDown = function(cm) {\n    var info = cm.getScrollInfo();\n    if (!cm.somethingSelected()) {\n      var visibleTopLine = cm.lineAtHeight(info.top, \"local\")+1;\n      if (cm.getCursor().line <= visibleTopLine)\n        cm.execCommand(\"goLineDown\");\n    }\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\n  };\n\n  cmds.splitSelectionByLine = function(cm) {\n    var ranges = cm.listSelections(), lineRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      for (var line = from.line; line <= to.line; ++line)\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\n                           head: line == to.line ? to : Pos(line)});\n    }\n    cm.setSelections(lineRanges, 0);\n  };\n\n  cmds.singleSelectionTop = function(cm) {\n    var range = cm.listSelections()[0];\n    cm.setSelection(range.anchor, range.head, {scroll: false});\n  };\n\n  cmds.selectLine = function(cm) {\n    var ranges = cm.listSelections(), extended = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      extended.push({anchor: Pos(range.from().line, 0),\n                     head: Pos(range.to().line + 1, 0)});\n    }\n    cm.setSelections(extended);\n  };\n\n  function insertLine(cm, above) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    cm.operation(function() {\n      var len = cm.listSelections().length, newSelection = [], last = -1;\n      for (var i = 0; i < len; i++) {\n        var head = cm.listSelections()[i].head;\n        if (head.line <= last) continue;\n        var at = Pos(head.line + (above ? 0 : 1), 0);\n        cm.replaceRange(\"\\n\", at, null, \"+insertLine\");\n        cm.indentLine(at.line, null, true);\n        newSelection.push({head: at, anchor: at});\n        last = head.line + 1;\n      }\n      cm.setSelections(newSelection);\n    });\n    cm.execCommand(\"indentAuto\");\n  }\n\n  cmds.insertLineAfter = function(cm) { return insertLine(cm, false); };\n\n  cmds.insertLineBefore = function(cm) { return insertLine(cm, true); };\n\n  function wordAt(cm, pos) {\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\n  }\n\n  cmds.selectNextOccurrence = function(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      cm.setSelection(word.from, word.to);\n      fullWord = true;\n    } else {\n      var text = cm.getRange(from, to);\n      var query = fullWord ? new RegExp(\"\\\\b\" + text + \"\\\\b\") : text;\n      var cur = cm.getSearchCursor(query, to);\n      var found = cur.findNext();\n      if (!found) {\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\n        found = cur.findNext();\n      }\n      if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to())) return\n      cm.addSelection(cur.from(), cur.to());\n    }\n    if (fullWord)\n      cm.state.sublimeFindFullWord = cm.doc.sel;\n  };\n\n  cmds.skipAndSelectNextOccurrence = function(cm) {\n    var prevAnchor = cm.getCursor(\"anchor\"), prevHead = cm.getCursor(\"head\");\n    cmds.selectNextOccurrence(cm);\n    if (CodeMirror.cmpPos(prevAnchor, prevHead) != 0) {\n      cm.doc.setSelections(cm.doc.listSelections()\n          .filter(function (sel) {\n            return sel.anchor != prevAnchor || sel.head != prevHead;\n          }));\n    }\n  }\n\n  function addCursorToSelection(cm, dir) {\n    var ranges = cm.listSelections(), newRanges = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var newAnchor = cm.findPosV(\n          range.anchor, dir, \"line\", range.anchor.goalColumn);\n      var newHead = cm.findPosV(\n          range.head, dir, \"line\", range.head.goalColumn);\n      newAnchor.goalColumn = range.anchor.goalColumn != null ?\n          range.anchor.goalColumn : cm.cursorCoords(range.anchor, \"div\").left;\n      newHead.goalColumn = range.head.goalColumn != null ?\n          range.head.goalColumn : cm.cursorCoords(range.head, \"div\").left;\n      var newRange = {anchor: newAnchor, head: newHead};\n      newRanges.push(range);\n      newRanges.push(newRange);\n    }\n    cm.setSelections(newRanges);\n  }\n  cmds.addCursorToPrevLine = function(cm) { addCursorToSelection(cm, -1); };\n  cmds.addCursorToNextLine = function(cm) { addCursorToSelection(cm, 1); };\n\n  function isSelectedRange(ranges, from, to) {\n    for (var i = 0; i < ranges.length; i++)\n      if (CodeMirror.cmpPos(ranges[i].from(), from) == 0 &&\n          CodeMirror.cmpPos(ranges[i].to(), to) == 0) return true\n    return false\n  }\n\n  var mirror = \"(){}[]\";\n  function selectBetweenBrackets(cm) {\n    var ranges = cm.listSelections(), newRanges = []\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);\n      if (!opening) return false;\n      for (;;) {\n        var closing = cm.scanForBracket(pos, 1);\n        if (!closing) return false;\n        if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\n          var startPos = Pos(opening.pos.line, opening.pos.ch + 1);\n          if (CodeMirror.cmpPos(startPos, range.from()) == 0 &&\n              CodeMirror.cmpPos(closing.pos, range.to()) == 0) {\n            opening = cm.scanForBracket(opening.pos, -1);\n            if (!opening) return false;\n          } else {\n            newRanges.push({anchor: startPos, head: closing.pos});\n            break;\n          }\n        }\n        pos = Pos(closing.pos.line, closing.pos.ch + 1);\n      }\n    }\n    cm.setSelections(newRanges);\n    return true;\n  }\n\n  cmds.selectScope = function(cm) {\n    selectBetweenBrackets(cm) || cm.execCommand(\"selectAll\");\n  };\n  cmds.selectBetweenBrackets = function(cm) {\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\n  };\n\n  function puncType(type) {\n    return !type ? null : /\\bpunctuation\\b/.test(type) ? type : undefined\n  }\n\n  cmds.goToBracket = function(cm) {\n    cm.extendSelectionsBy(function(range) {\n      var next = cm.scanForBracket(range.head, 1, puncType(cm.getTokenTypeAt(range.head)));\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\n      var prev = cm.scanForBracket(range.head, -1, puncType(cm.getTokenTypeAt(Pos(range.head.line, range.head.ch + 1))));\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\n    });\n  };\n\n  cmds.swapLineUp = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\n                    head: Pos(range.head.line - 1, range.head.ch)});\n      if (range.to().ch == 0 && !range.empty()) --to;\n      if (from > at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = 0; i < linesToMove.length; i += 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        if (to > cm.lastLine())\n          cm.replaceRange(\"\\n\" + line, Pos(cm.lastLine()), null, \"+swapLine\");\n        else\n          cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.setSelections(newSels);\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.swapLineDown = function(cm) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\n      if (range.to().ch == 0 && !range.empty()) from--;\n      if (from < at) linesToMove.push(from, to);\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\n      at = to;\n    }\n    cm.operation(function() {\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\n        var from = linesToMove[i], to = linesToMove[i + 1];\n        var line = cm.getLine(from);\n        if (from == cm.lastLine())\n          cm.replaceRange(\"\", Pos(from - 1), Pos(from), \"+swapLine\");\n        else\n          cm.replaceRange(\"\", Pos(from, 0), Pos(from + 1, 0), \"+swapLine\");\n        cm.replaceRange(line + \"\\n\", Pos(to, 0), null, \"+swapLine\");\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.toggleCommentIndented = function(cm) {\n    cm.toggleComment({ indent: true });\n  }\n\n  cmds.joinLines = function(cm) {\n    var ranges = cm.listSelections(), joined = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], from = range.from();\n      var start = from.line, end = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\n        end = ranges[++i].to().line;\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\n    }\n    cm.operation(function() {\n      var offset = 0, ranges = [];\n      for (var i = 0; i < joined.length; i++) {\n        var obj = joined[i];\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\n        for (var line = obj.start; line <= obj.end; line++) {\n          var actual = line - offset;\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\n          if (actual < cm.lastLine()) {\n            cm.replaceRange(\" \", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\n            ++offset;\n          }\n        }\n        ranges.push({anchor: anchor || head, head: head});\n      }\n      cm.setSelections(ranges, 0);\n    });\n  };\n\n  cmds.duplicateLine = function(cm) {\n    cm.operation(function() {\n      var rangeCount = cm.listSelections().length;\n      for (var i = 0; i < rangeCount; i++) {\n        var range = cm.listSelections()[i];\n        if (range.empty())\n          cm.replaceRange(cm.getLine(range.head.line) + \"\\n\", Pos(range.head.line, 0));\n        else\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\n      }\n      cm.scrollIntoView();\n    });\n  };\n\n\n  function sortLines(cm, caseSensitive, direction) {\n    if (cm.isReadOnly()) return CodeMirror.Pass\n    var ranges = cm.listSelections(), toSort = [], selected;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      if (range.empty()) continue;\n      var from = range.from().line, to = range.to().line;\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\n        to = ranges[++i].to().line;\n      if (!ranges[i].to().ch) to--;\n      toSort.push(from, to);\n    }\n    if (toSort.length) selected = true;\n    else toSort.push(cm.firstLine(), cm.lastLine());\n\n    cm.operation(function() {\n      var ranges = [];\n      for (var i = 0; i < toSort.length; i += 2) {\n        var from = toSort[i], to = toSort[i + 1];\n        var start = Pos(from, 0), end = Pos(to);\n        var lines = cm.getRange(start, end, false);\n        if (caseSensitive)\n          lines.sort(function(a, b) { return a < b ? -direction : a == b ? 0 : direction; });\n        else\n          lines.sort(function(a, b) {\n            var au = a.toUpperCase(), bu = b.toUpperCase();\n            if (au != bu) { a = au; b = bu; }\n            return a < b ? -direction : a == b ? 0 : direction;\n          });\n        cm.replaceRange(lines, start, end);\n        if (selected) ranges.push({anchor: start, head: Pos(to + 1, 0)});\n      }\n      if (selected) cm.setSelections(ranges, 0);\n    });\n  }\n\n  cmds.sortLines = function(cm) { sortLines(cm, true, 1); };\n  cmds.reverseSortLines = function(cm) { sortLines(cm, true, -1); };\n  cmds.sortLinesInsensitive = function(cm) { sortLines(cm, false, 1); };\n  cmds.reverseSortLinesInsensitive = function(cm) { sortLines(cm, false, -1); };\n\n  cmds.nextBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      var current = marks.shift();\n      var found = current.find();\n      if (found) {\n        marks.push(current);\n        return cm.setSelection(found.from, found.to);\n      }\n    }\n  };\n\n  cmds.prevBookmark = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) while (marks.length) {\n      marks.unshift(marks.pop());\n      var found = marks[marks.length - 1].find();\n      if (!found)\n        marks.pop();\n      else\n        return cm.setSelection(found.from, found.to);\n    }\n  };\n\n  cmds.toggleBookmark = function(cm) {\n    var ranges = cm.listSelections();\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\n    for (var i = 0; i < ranges.length; i++) {\n      var from = ranges[i].from(), to = ranges[i].to();\n      var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);\n      for (var j = 0; j < found.length; j++) {\n        if (found[j].sublimeBookmark) {\n          found[j].clear();\n          for (var k = 0; k < marks.length; k++)\n            if (marks[k] == found[j])\n              marks.splice(k--, 1);\n          break;\n        }\n      }\n      if (j == found.length)\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\n    }\n  };\n\n  cmds.clearBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks;\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n    marks.length = 0;\n  };\n\n  cmds.selectBookmarks = function(cm) {\n    var marks = cm.state.sublimeBookmarks, ranges = [];\n    if (marks) for (var i = 0; i < marks.length; i++) {\n      var found = marks[i].find();\n      if (!found)\n        marks.splice(i--, 0);\n      else\n        ranges.push({anchor: found.from, head: found.to});\n    }\n    if (ranges.length)\n      cm.setSelections(ranges, 0);\n  };\n\n  function modifyWordOrSelection(cm, mod) {\n    cm.operation(function() {\n      var ranges = cm.listSelections(), indices = [], replacements = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) { indices.push(i); replacements.push(\"\"); }\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\n      }\n      cm.replaceSelections(replacements, \"around\", \"case\");\n      for (var i = indices.length - 1, at; i >= 0; i--) {\n        var range = ranges[indices[i]];\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\n        var word = wordAt(cm, range.head);\n        at = word.from;\n        cm.replaceRange(mod(word.word), word.from, word.to);\n      }\n    });\n  }\n\n  cmds.smartBackspace = function(cm) {\n    if (cm.somethingSelected()) return CodeMirror.Pass;\n\n    cm.operation(function() {\n      var cursors = cm.listSelections();\n      var indentUnit = cm.getOption(\"indentUnit\");\n\n      for (var i = cursors.length - 1; i >= 0; i--) {\n        var cursor = cursors[i].head;\n        var toStartOfLine = cm.getRange({line: cursor.line, ch: 0}, cursor);\n        var column = CodeMirror.countColumn(toStartOfLine, null, cm.getOption(\"tabSize\"));\n\n        // Delete by one character by default\n        var deletePos = cm.findPosH(cursor, -1, \"char\", false);\n\n        if (toStartOfLine && !/\\S/.test(toStartOfLine) && column % indentUnit == 0) {\n          var prevIndent = new Pos(cursor.line,\n            CodeMirror.findColumn(toStartOfLine, column - indentUnit, indentUnit));\n\n          // Smart delete only if we found a valid prevIndent location\n          if (prevIndent.ch != cursor.ch) deletePos = prevIndent;\n        }\n\n        cm.replaceRange(\"\", deletePos, cursor, \"+delete\");\n      }\n    });\n  };\n\n  cmds.delLineRight = function(cm) {\n    cm.operation(function() {\n      var ranges = cm.listSelections();\n      for (var i = ranges.length - 1; i >= 0; i--)\n        cm.replaceRange(\"\", ranges[i].anchor, Pos(ranges[i].to().line), \"+delete\");\n      cm.scrollIntoView();\n    });\n  };\n\n  cmds.upcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\n  };\n  cmds.downcaseAtCursor = function(cm) {\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\n  };\n\n  cmds.setSublimeMark = function(cm) {\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n  };\n  cmds.selectToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) cm.setSelection(cm.getCursor(), found);\n  };\n  cmds.deleteToSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      var from = cm.getCursor(), to = found;\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\n      cm.state.sublimeKilled = cm.getRange(from, to);\n      cm.replaceRange(\"\", from, to);\n    }\n  };\n  cmds.swapWithSublimeMark = function(cm) {\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\n    if (found) {\n      cm.state.sublimeMark.clear();\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\n      cm.setCursor(found);\n    }\n  };\n  cmds.sublimeYank = function(cm) {\n    if (cm.state.sublimeKilled != null)\n      cm.replaceSelection(cm.state.sublimeKilled, null, \"paste\");\n  };\n\n  cmds.showInCenter = function(cm) {\n    var pos = cm.cursorCoords(null, \"local\");\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\n  };\n\n  function getTarget(cm) {\n    var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n    if (CodeMirror.cmpPos(from, to) == 0) {\n      var word = wordAt(cm, from);\n      if (!word.word) return;\n      from = word.from;\n      to = word.to;\n    }\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\n  }\n\n  function findAndGoTo(cm, forward) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var query = target.query;\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\n\n    if (forward ? cur.findNext() : cur.findPrevious()) {\n      cm.setSelection(cur.from(), cur.to());\n    } else {\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\n                                              : cm.clipPos(Pos(cm.lastLine())));\n      if (forward ? cur.findNext() : cur.findPrevious())\n        cm.setSelection(cur.from(), cur.to());\n      else if (target.word)\n        cm.setSelection(target.from, target.to);\n    }\n  };\n  cmds.findUnder = function(cm) { findAndGoTo(cm, true); };\n  cmds.findUnderPrevious = function(cm) { findAndGoTo(cm,false); };\n  cmds.findAllUnder = function(cm) {\n    var target = getTarget(cm);\n    if (!target) return;\n    var cur = cm.getSearchCursor(target.query);\n    var matches = [];\n    var primaryIndex = -1;\n    while (cur.findNext()) {\n      matches.push({anchor: cur.from(), head: cur.to()});\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\n        primaryIndex++;\n    }\n    cm.setSelections(matches, primaryIndex);\n  };\n\n\n  var keyMap = CodeMirror.keyMap;\n  keyMap.macSublime = {\n    \"Cmd-Left\": \"goLineStartSmart\",\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-Left\": \"goSubwordLeft\",\n    \"Ctrl-Right\": \"goSubwordRight\",\n    \"Ctrl-Alt-Up\": \"scrollLineUp\",\n    \"Ctrl-Alt-Down\": \"scrollLineDown\",\n    \"Cmd-L\": \"selectLine\",\n    \"Shift-Cmd-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Cmd-Enter\": \"insertLineAfter\",\n    \"Shift-Cmd-Enter\": \"insertLineBefore\",\n    \"Cmd-D\": \"selectNextOccurrence\",\n    \"Shift-Cmd-Space\": \"selectScope\",\n    \"Shift-Cmd-M\": \"selectBetweenBrackets\",\n    \"Cmd-M\": \"goToBracket\",\n    \"Cmd-Ctrl-Up\": \"swapLineUp\",\n    \"Cmd-Ctrl-Down\": \"swapLineDown\",\n    \"Cmd-/\": \"toggleCommentIndented\",\n    \"Cmd-J\": \"joinLines\",\n    \"Shift-Cmd-D\": \"duplicateLine\",\n    \"F5\": \"sortLines\",\n    \"Shift-F5\": \"reverseSortLines\",\n    \"Cmd-F5\": \"sortLinesInsensitive\",\n    \"Shift-Cmd-F5\": \"reverseSortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Cmd-F2\": \"toggleBookmark\",\n    \"Shift-Cmd-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Cmd-K Cmd-D\": \"skipAndSelectNextOccurrence\",\n    \"Cmd-K Cmd-K\": \"delLineRight\",\n    \"Cmd-K Cmd-U\": \"upcaseAtCursor\",\n    \"Cmd-K Cmd-L\": \"downcaseAtCursor\",\n    \"Cmd-K Cmd-Space\": \"setSublimeMark\",\n    \"Cmd-K Cmd-A\": \"selectToSublimeMark\",\n    \"Cmd-K Cmd-W\": \"deleteToSublimeMark\",\n    \"Cmd-K Cmd-X\": \"swapWithSublimeMark\",\n    \"Cmd-K Cmd-Y\": \"sublimeYank\",\n    \"Cmd-K Cmd-C\": \"showInCenter\",\n    \"Cmd-K Cmd-G\": \"clearBookmarks\",\n    \"Cmd-K Cmd-Backspace\": \"delLineLeft\",\n    \"Cmd-K Cmd-1\": \"foldAll\",\n    \"Cmd-K Cmd-0\": \"unfoldAll\",\n    \"Cmd-K Cmd-J\": \"unfoldAll\",\n    \"Ctrl-Shift-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Shift-Down\": \"addCursorToNextLine\",\n    \"Cmd-F3\": \"findUnder\",\n    \"Shift-Cmd-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Cmd-[\": \"fold\",\n    \"Shift-Cmd-]\": \"unfold\",\n    \"Cmd-I\": \"findIncremental\",\n    \"Shift-Cmd-I\": \"findIncrementalReverse\",\n    \"Cmd-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"macDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.macSublime);\n\n  keyMap.pcSublime = {\n    \"Shift-Tab\": \"indentLess\",\n    \"Shift-Ctrl-K\": \"deleteLine\",\n    \"Alt-Q\": \"wrapLines\",\n    \"Ctrl-T\": \"transposeChars\",\n    \"Alt-Left\": \"goSubwordLeft\",\n    \"Alt-Right\": \"goSubwordRight\",\n    \"Ctrl-Up\": \"scrollLineUp\",\n    \"Ctrl-Down\": \"scrollLineDown\",\n    \"Ctrl-L\": \"selectLine\",\n    \"Shift-Ctrl-L\": \"splitSelectionByLine\",\n    \"Esc\": \"singleSelectionTop\",\n    \"Ctrl-Enter\": \"insertLineAfter\",\n    \"Shift-Ctrl-Enter\": \"insertLineBefore\",\n    \"Ctrl-D\": \"selectNextOccurrence\",\n    \"Shift-Ctrl-Space\": \"selectScope\",\n    \"Shift-Ctrl-M\": \"selectBetweenBrackets\",\n    \"Ctrl-M\": \"goToBracket\",\n    \"Shift-Ctrl-Up\": \"swapLineUp\",\n    \"Shift-Ctrl-Down\": \"swapLineDown\",\n    \"Ctrl-/\": \"toggleCommentIndented\",\n    \"Ctrl-J\": \"joinLines\",\n    \"Shift-Ctrl-D\": \"duplicateLine\",\n    \"F9\": \"sortLines\",\n    \"Shift-F9\": \"reverseSortLines\",\n    \"Ctrl-F9\": \"sortLinesInsensitive\",\n    \"Shift-Ctrl-F9\": \"reverseSortLinesInsensitive\",\n    \"F2\": \"nextBookmark\",\n    \"Shift-F2\": \"prevBookmark\",\n    \"Ctrl-F2\": \"toggleBookmark\",\n    \"Shift-Ctrl-F2\": \"clearBookmarks\",\n    \"Alt-F2\": \"selectBookmarks\",\n    \"Backspace\": \"smartBackspace\",\n    \"Ctrl-K Ctrl-D\": \"skipAndSelectNextOccurrence\",\n    \"Ctrl-K Ctrl-K\": \"delLineRight\",\n    \"Ctrl-K Ctrl-U\": \"upcaseAtCursor\",\n    \"Ctrl-K Ctrl-L\": \"downcaseAtCursor\",\n    \"Ctrl-K Ctrl-Space\": \"setSublimeMark\",\n    \"Ctrl-K Ctrl-A\": \"selectToSublimeMark\",\n    \"Ctrl-K Ctrl-W\": \"deleteToSublimeMark\",\n    \"Ctrl-K Ctrl-X\": \"swapWithSublimeMark\",\n    \"Ctrl-K Ctrl-Y\": \"sublimeYank\",\n    \"Ctrl-K Ctrl-C\": \"showInCenter\",\n    \"Ctrl-K Ctrl-G\": \"clearBookmarks\",\n    \"Ctrl-K Ctrl-Backspace\": \"delLineLeft\",\n    \"Ctrl-K Ctrl-1\": \"foldAll\",\n    \"Ctrl-K Ctrl-0\": \"unfoldAll\",\n    \"Ctrl-K Ctrl-J\": \"unfoldAll\",\n    \"Ctrl-Alt-Up\": \"addCursorToPrevLine\",\n    \"Ctrl-Alt-Down\": \"addCursorToNextLine\",\n    \"Ctrl-F3\": \"findUnder\",\n    \"Shift-Ctrl-F3\": \"findUnderPrevious\",\n    \"Alt-F3\": \"findAllUnder\",\n    \"Shift-Ctrl-[\": \"fold\",\n    \"Shift-Ctrl-]\": \"unfold\",\n    \"Ctrl-I\": \"findIncremental\",\n    \"Shift-Ctrl-I\": \"findIncrementalReverse\",\n    \"Ctrl-H\": \"replace\",\n    \"F3\": \"findNext\",\n    \"Shift-F3\": \"findPrev\",\n    \"fallthrough\": \"pcDefault\"\n  };\n  CodeMirror.normalizeKeyMap(keyMap.pcSublime);\n\n  var mac = keyMap.default == keyMap.macDefault;\n  keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// declare global: DOMRect\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  CodeMirror.defineExtension(\"closeHint\", function() {\n    if (this.state.completionActive) this.state.completionActive.close()\n  })\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    if (this.options.updateOnCursorActivity) {\n      var self = this;\n      cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n    }\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      if (this.options.updateOnCursorActivity) {\n        this.cm.off(\"cursorActivity\", this.activityFunc);\n      }\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i], self = this;\n      this.cm.operation(function() {\n        if (completion.hint)\n          completion.hint(self.cm, data, completion);\n        else\n          self.cm.replaceRange(getText(completion), completion.from || data.from,\n                               completion.to || data.to, \"complete\");\n        CodeMirror.signal(data, \"pick\", completion);\n        self.cm.scrollIntoView();\n      });\n      if (this.options.closeOnPick) {\n        this.close();\n      }\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var identStart = this.startPos;\n      if(this.data) {\n        identStart = this.data.from;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < identStart.ch || this.cm.somethingSelected() ||\n          (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return\n      var self = this, myTick = ++this.tick\n      fetchHints(this.options.hint, this.cm, this.options, function(data) {\n        if (self.tick == myTick) self.finishUpdate(data, first)\n      })\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n\n      this.data = data;\n\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n\n    var mac = /Mac/.test(navigator.platform);\n\n    if (mac) {\n      baseMap[\"Ctrl-P\"] = function() {handle.moveFocus(-1);};\n      baseMap[\"Ctrl-N\"] = function() {handle.moveFocus(1);};\n    }\n\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.id = \"cm-complete-\" + Math.floor(Math.random(1e6))\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n    var ownerDocument = cm.getInputField().ownerDocument;\n    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;\n\n    var hints = this.hints = ownerDocument.createElement(\"ul\");\n    hints.setAttribute(\"role\", \"listbox\")\n    hints.setAttribute(\"aria-expanded\", \"true\")\n    hints.id = this.id\n    var theme = completion.cm.options.theme;\n    hints.className = \"CodeMirror-hints \" + theme;\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(ownerDocument.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (i == this.selectedHint) elt.setAttribute(\"aria-selected\", \"true\")\n      elt.id = this.id + \"-\" + i\n      elt.setAttribute(\"role\", \"option\")\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var container = completion.options.container || ownerDocument.body;\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    var offsetLeft = 0, offsetTop = 0;\n    if (container !== ownerDocument.body) {\n      // We offset the cursor position because left and top are relative to the offsetParent's top left corner.\n      var isContainerPositioned = ['absolute', 'relative', 'fixed'].indexOf(parentWindow.getComputedStyle(container).position) !== -1;\n      var offsetParent = isContainerPositioned ? container : container.offsetParent;\n      var offsetParentPosition = offsetParent.getBoundingClientRect();\n      var bodyPosition = ownerDocument.body.getBoundingClientRect();\n      offsetLeft = (offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft);\n      offsetTop = (offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop);\n    }\n    hints.style.left = (left - offsetLeft) + \"px\";\n    hints.style.top = (top - offsetTop) + \"px\";\n\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);\n    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);\n    container.appendChild(hints);\n    cm.getInputField().setAttribute(\"aria-autocomplete\", \"list\")\n    cm.getInputField().setAttribute(\"aria-owns\", this.id)\n    cm.getInputField().setAttribute(\"aria-activedescendant\", this.id + \"-\" + this.selectedHint)\n\n    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();\n    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;\n\n    // Compute in the timeout to avoid reflow on init\n    var startScroll;\n    setTimeout(function() { startScroll = cm.getScrollInfo(); });\n\n    var overlapY = box.bottom - winH;\n    if (overlapY > 0) { // Does not fit below\n      var height = box.bottom - box.top, spaceAbove = box.top - (pos.bottom - pos.top) - 2\n      if (winH - box.top < spaceAbove) { // More room at the top\n        if (height > spaceAbove) hints.style.height = (height = spaceAbove) + \"px\";\n        hints.style.top = ((top = pos.top - height) - offsetTop) + \"px\";\n        below = false;\n      } else {\n        hints.style.height = (winH - box.top - 2) + \"px\";\n      }\n    }\n    var overlapX = box.right - winW;\n    if (scrolls) overlapX += cm.display.nativeBarWidth;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = Math.max(pos.left - overlapX - offsetLeft, 0)) + \"px\";\n    }\n    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)\n      node.style.paddingRight = cm.display.nativeBarWidth + \"px\"\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      if (!startScroll) startScroll = cm.getScrollInfo();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    // The first hint doesn't need to be scrolled to on init\n    var selectedHintRange = this.getSelectedHintRange();\n    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {\n      this.scrollToActive();\n    }\n\n    CodeMirror.signal(data, \"select\", completions[this.selectedHint], hints.childNodes[this.selectedHint]);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      if (this.hints.parentNode) this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var input = this.completion.cm.getInputField()\n      input.removeAttribute(\"aria-activedescendant\")\n      input.removeAttribute(\"aria-owns\")\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      if (node) {\n        node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n        node.removeAttribute(\"aria-selected\")\n      }\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      node.setAttribute(\"aria-selected\", \"true\")\n      this.completion.cm.getInputField().setAttribute(\"aria-activedescendant\", node.id)\n      this.scrollToActive()\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    scrollToActive: function() {\n      var selectedHintRange = this.getSelectedHintRange();\n      var node1 = this.hints.childNodes[selectedHintRange.from];\n      var node2 = this.hints.childNodes[selectedHintRange.to];\n      var firstNode = this.hints.firstChild;\n      if (node1.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;\n      else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    },\n\n    getSelectedHintRange: function() {\n      var margin = this.completion.options.scrollMargin || 0;\n      return {\n        from: Math.max(0, this.selectedHint - margin),\n        to: Math.min(this.data.list.length - 1, this.selectedHint + margin),\n      };\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function fetchHints(hint, cm, options, callback) {\n    if (hint.async) {\n      hint(cm, callback, options)\n    } else {\n      var result = hint(cm, options)\n      if (result && result.then) result.then(callback)\n      else callback(result)\n    }\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var resolved = function(cm, callback, options) {\n        var app = applicableHelpers(cm, helpers);\n        function run(i) {\n          if (i == app.length) return callback(null)\n          fetchHints(app[i], cm, options, function(result) {\n            if (result && result.list.length > 0) callback(result)\n            else run(i + 1)\n          })\n        }\n        run(0)\n      }\n      resolved.async = true\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur)\n    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur\n    if (token.start < cur.ch && /\\w/.test(token.string.charAt(cur.ch - token.start - 1))) {\n      term = token.string.substr(0, cur.ch - token.start)\n    } else {\n      term = \"\"\n      from = cur\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnPick: true,\n    closeOnUnfocus: true,\n    updateOnCursorActivity: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null,\n    paddingForScrollbar: true,\n    moveOnOverlap: true,\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var WORD = /[\\w$]+/, RANGE = 500;\n\n  CodeMirror.registerHelper(\"hint\", \"anyword\", function(editor, options) {\n    var word = options && options.word || WORD;\n    var range = options && options.range || RANGE;\n    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\n    var end = cur.ch, start = end;\n    while (start && word.test(curLine.charAt(start - 1))) --start;\n    var curWord = start != end && curLine.slice(start, end);\n\n    var list = options && options.list || [], seen = {};\n    var re = new RegExp(word.source, \"g\");\n    for (var dir = -1; dir <= 1; dir += 2) {\n      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\n      for (; line != endLine; line += dir) {\n        var text = editor.getLine(line), m;\n        while (m = re.exec(text)) {\n          if (line == cur.line && m[0] === curWord) continue;\n          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\n            seen[m[0]] = true;\n            list.push(m[0]);\n          }\n        }\n      }\n    }\n    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var trackScope = parserConfig.trackScope !== false\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\")\n    } else if (ch == \"<\" && stream.match(\"!--\") ||\n               (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n                     \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    if (!trackScope) return false\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (!trackScope) return\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  pushcontext.lex = pushblockcontext.lex = true\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(maybeexpression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n    if (type == \"quasi\") { return pass(quasiType, afterType); }\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont()\n    if (type == \",\" || type == \";\") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont()\n    }\n  }\n  function quasiType(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n    return cont(typeexpr, continueQuasiType);\n  }\n  function continueQuasiType(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasiType);\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+#?[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"!\") return cont(classfield)\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    if (type == \".\") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\nCodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"yaml\", function() {\n\n  var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];\n  var keywordRegex = new RegExp(\"\\\\b((\"+cons.join(\")|(\")+\"))$\", 'i');\n\n  return {\n    token: function(stream, state) {\n      var ch = stream.peek();\n      var esc = state.escaped;\n      state.escaped = false;\n      /* comments */\n      if (ch == \"#\" && (stream.pos == 0 || /\\s/.test(stream.string.charAt(stream.pos - 1)))) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (stream.match(/^('([^']|\\\\.)*'?|\"([^\"]|\\\\.)*\"?)/))\n        return \"string\";\n\n      if (state.literal && stream.indentation() > state.keyCol) {\n        stream.skipToEnd(); return \"string\";\n      } else if (state.literal) { state.literal = false; }\n      if (stream.sol()) {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        /* document start */\n        if(stream.match('---')) { return \"def\"; }\n        /* document end */\n        if (stream.match('...')) { return \"def\"; }\n        /* array list item */\n        if (stream.match(/\\s*-\\s+/)) { return 'meta'; }\n      }\n      /* inline pairs/lists */\n      if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n        if (ch == '{')\n          state.inlinePairs++;\n        else if (ch == '}')\n          state.inlinePairs--;\n        else if (ch == '[')\n          state.inlineList++;\n        else\n          state.inlineList--;\n        return 'meta';\n      }\n\n      /* list separator */\n      if (state.inlineList > 0 && !esc && ch == ',') {\n        stream.next();\n        return 'meta';\n      }\n      /* pairs separator */\n      if (state.inlinePairs > 0 && !esc && ch == ',') {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        stream.next();\n        return 'meta';\n      }\n\n      /* start of value of a pair */\n      if (state.pairStart) {\n        /* block literals */\n        if (stream.match(/^\\s*(\\||\\>)\\s*/)) { state.literal = true; return 'meta'; };\n        /* references */\n        if (stream.match(/^\\s*(\\&|\\*)[a-z0-9\\._-]+\\b/i)) { return 'variable-2'; }\n        /* numbers */\n        if (state.inlinePairs == 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?$/)) { return 'number'; }\n        if (state.inlinePairs > 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?(?=(,|}))/)) { return 'number'; }\n        /* keywords */\n        if (stream.match(keywordRegex)) { return 'keyword'; }\n      }\n\n      /* pairs (associative arrays) -> key */\n      if (!state.pair && stream.match(/^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^\\s,\\[\\]{}#&*!|>'\"%@`])[^#:]*(?=:($|\\s))/)) {\n        state.pair = true;\n        state.keyCol = stream.indentation();\n        return \"atom\";\n      }\n      if (state.pair && stream.match(/^:\\s*/)) { state.pairStart = true; return 'meta'; }\n\n      /* nothing found, continue */\n      state.pairStart = false;\n      state.escaped = (ch == '\\\\');\n      stream.next();\n      return null;\n    },\n    startState: function() {\n      return {\n        pair: false,\n        pairStart: false,\n        keyCol: 0,\n        inlinePairs: 0,\n        inlineList: 0,\n        literal: false,\n        escaped: false\n      };\n    },\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-yaml\", \"yaml\");\nCodeMirror.defineMIME(\"text/yaml\", \"yaml\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp, endMargin) {\n    var match, from = 0\n    while (from <= string.length) {\n      regexp.lastIndex = from\n      var newMatch = regexp.exec(string)\n      if (!newMatch) break\n      var end = newMatch.index + newMatch[0].length\n      if (end > string.length - endMargin) break\n      if (!match || end > match.index + match[0].length)\n        match = newMatch\n      from = newMatch.index + 1\n    }\n    return match\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpBackward(doc, regexp, start)\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunkSize && line >= first; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine : curLine + \"\\n\" + string\n      }\n      chunkSize *= 2\n\n      var match = lastMatchIn(string, regexp, endMargin)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.afterEmptyMatch = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n      if (this.afterEmptyMatch && this.atOccurrence) {\n        // do not return the same 0 width match twice\n        head = Pos(head.line, head.ch)\n        if (reverse) {\n          head.ch--;\n          if (head.ch < 0) {\n            head.line--;\n            head.ch = (this.doc.getLine(head.line) || \"\").length;\n          }\n        } else {\n          head.ch++;\n          if (head.ch > (this.doc.getLine(head.line) || \"\").length) {\n            head.ch = 0;\n            head.line++;\n          }\n        }\n        if (CodeMirror.cmpPos(head, this.doc.clipPos(head)) != 0) {\n           return this.atOccurrence = false\n        }\n      }\n      var result = this.matches(reverse, head)\n      this.afterEmptyMatch = result && CodeMirror.cmpPos(result.from, result.to) == 0\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\n// Depends on js-yaml.js from https://github.com/nodeca/js-yaml\n\n// declare global: jsyaml\n\nCodeMirror.registerHelper(\"lint\", \"yaml\", function(text) {\n  var found = [];\n  if (!window.jsyaml) {\n    if (window.console) {\n      window.console.error(\"Error: window.jsyaml not defined, CodeMirror YAML linting cannot run.\");\n    }\n    return found;\n  }\n  try { jsyaml.loadAll(text); }\n  catch(e) {\n      var loc = e.mark,\n          // js-yaml YAMLException doesn't always provide an accurate lineno\n          // e.g., when there are multiple yaml docs\n          // ---\n          // ---\n          // foo:bar\n          from = loc ? CodeMirror.Pos(loc.line, loc.column) : CodeMirror.Pos(0, 0),\n          to = from;\n      found.push({ from: from, to: to, message: e.message });\n  }\n  return found;\n});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.getWrapperElement();\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-bottom\";\n    else\n      dialog.className = \"CodeMirror-dialog CodeMirror-dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    CodeMirror.addClass(wrap, 'dialog-opened');\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        closed = true;\n        CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      inp.focus();\n\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) {\n          inp.select();\n        }\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n        if (e.keyCode == 13) callback(inp.value, e);\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(dialog, \"focusout\", function (evt) {\n        if (evt.relatedTarget !== null) close();\n      });\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks, options) {\n    closeNotification(this, null);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.on(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.on(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.on(b, \"focus\", function() { ++blurring; });\n    }\n  });\n\n  /*\n   * openNotification\n   * Opens a notification, that can be closed with an optional timer\n   * (default 5000ms timer) and always closes on click.\n   *\n   * If a notification is opened while another is opened, it will close the\n   * currently opened one and open the new one immediately.\n   */\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      CodeMirror.rmClass(dialog.parentNode, 'dialog-opened');\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n});\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./lint.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"55ede122\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","/*\n * NOTE: This isn't actually a real plugin anymore, it's is dynamically loaded in components/CodeMirror.vue\n * so that it doesn't all get loaded put into vendor.js\n */\n\nimport CodeMirror from 'codemirror';\n\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/mode/yaml/yaml.js';\nimport 'codemirror/mode/javascript/javascript.js';\n\nimport 'codemirror/theme/base16-light.css';\nimport 'codemirror/theme/base16-dark.css';\n\nimport 'codemirror/keymap/vim.js';\nimport 'codemirror/keymap/emacs.js';\nimport 'codemirror/keymap/sublime.js';\n\nimport 'codemirror/addon/lint/lint.css';\nimport 'codemirror/addon/lint/lint.js';\nimport 'codemirror/addon/lint/yaml-lint.js';\n\nimport 'codemirror/addon/fold/foldgutter.css';\nimport 'codemirror/addon/fold/foldgutter.js';\n\nimport 'codemirror/addon/hint/show-hint.css';\nimport 'codemirror/addon/hint/show-hint.js';\nimport 'codemirror/addon/hint/anyword-hint.js';\n\nimport { strPad } from '@shell/utils/string';\n\nfunction isLineComment(cm, lineNo) {\n  return /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0)));\n}\n\nfunction commentIndent(cm, lineNo) {\n  const text = cm.getLine(lineNo).substr(1);\n  const spaceTo = text.search(/\\S/);\n\n  if (spaceTo === -1 ) {\n    return -1;\n  }\n\n  const out = CodeMirror.countColumn(text, null, cm.getOption('tabSize'));\n\n  return out;\n}\n\n// Like the regular indent in codemirror, but treat a YAML array\n// item that's at the same level as the parent key as intented on level more\n//\n// foo:\n// - a\n// - b\nfunction lineIndent(cm, lineNo) {\n  let text = cm.getLine(lineNo);\n  const match = text.match(/(\\s*(-\\s+)?)(\\S.*)/);\n\n  if ( !match ) {\n    return -1;\n  }\n\n  const spaceTo = match[1].length;\n\n  text = strPad('', spaceTo) + match[3];\n\n  if ( /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1)))) {\n    return -1;\n  }\n\n  return CodeMirror.countColumn(text, null, cm.getOption('tabSize'));\n}\n\n// https://github.com/codemirror/CodeMirror/blob/master/addon/fold/indent-fold.js\nCodeMirror.registerHelper('fold', 'indent', (cm, start) => {\n  const myIndent = lineIndent(cm, start.line);\n\n  if (myIndent < 0) {\n    return;\n  }\n  let lastLineInFold = null;\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (let i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    const indent = lineIndent(cm, i);\n\n    if (indent === -1) {\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n  if (lastLineInFold) {\n    return {\n      from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n      to:   CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n    };\n  }\n});\n\nCodeMirror.defineExtension('foldLinesMatching', function(regex) {\n  this.operation(() => {\n    for (let i = this.firstLine(), e = this.lastLine(); i <= e; i++) {\n      const line = this.getLine(i);\n\n      if ( line.match(regex) ) {\n        this.foldCode(CodeMirror.Pos(i, 0), null, 'fold');\n      }\n    }\n  });\n});\n\nfunction countSpaces(line) {\n  for (let i = 0; i < line.length; i++) {\n    if (line[i] !== ' ') {\n      return i;\n    }\n  }\n\n  return line.length;\n}\n\nCodeMirror.defineExtension('foldYaml', function(path) {\n  this.operation(() => {\n    let elements = [];\n\n    for (let i = this.firstLine(), e = this.lastLine(); i <= e; i++) {\n      const line = this.getLine(i);\n      const index = countSpaces(line);\n      const trimmed = line.trim();\n\n      if (trimmed.endsWith(':') || trimmed.endsWith(': >-')) {\n        const name = trimmed.split(':')[0].substr(0, trimmed.length - 1);\n\n        // Remove all elements of the same are greater index\n        elements = elements.filter((e) => e.index < index);\n\n        // Add on this one\n        elements.push({\n          index,\n          name\n        });\n\n        const currentPath = elements.map((e) => e.name).join('.');\n\n        if (currentPath === path) {\n          this.foldCode(CodeMirror.Pos(i, 0), null, 'fold');\n        }\n      }\n    }\n  });\n});\n\nCodeMirror.registerHelper('fold', 'yamlcomments', (cm, start) => {\n  if ( !isLineComment(cm, start.line) ) {\n    return;\n  }\n\n  const myIndent = commentIndent(cm, start.line);\n\n  if (myIndent < 0) {\n    return;\n  }\n\n  let lastLineInFold = null;\n\n  // Go through lines until we find a line that definitely doesn't belong in\n  // the block we're folding, or to the end.\n  for (let i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    if ( !isLineComment(cm, i) ) {\n      break;\n    }\n\n    const indent = commentIndent(cm, i);\n\n    if (indent === -1) {\n      // empty?\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n\n  if (lastLineInFold) {\n    return {\n      from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n      to:   CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n    };\n  }\n});\n\n/**\n * It display a dot for each space character in the text;\n * used in combination with 'as-text-area' css properties in CodeMirror.vue to display line break markdowns\n */\nCodeMirror.defineOption('showMarkdownLineBreaks', false, (codeMirror) => {\n  codeMirror.addOverlay({\n    name:  'show-markdown-line-breaks',\n    token: (stream) => {\n      if (stream.string[stream.pos].match(/\\s/)) {\n        stream.next();\n\n        return stream.pos % 2 === 0 ? 'markdown-single-trailing-space-even' : 'markdown-single-trailing-space-odd';\n      }\n\n      stream.next();\n\n      return null;\n    }\n  });\n});\n\n/**\n * It enables the text color selection in CodeMirror.vue\n * references:\n *   demo:   https://codemirror.net/5/demo/markselection.html#\n *   add-on: https://codemirror.net/5/doc/manual.html#addon_mark-selection\n *   source: https://codemirror.net/5/addon/selection/mark-selection.js\n */\nCodeMirror.defineOption('styleSelectedText', false, (cm, val, old) => {\n  const prev = old && old !== CodeMirror.Init;\n\n  if (val && !prev) {\n    cm.state.markedSelection = [];\n    cm.state.markedSelectionStyle = typeof val === 'string' ? val : 'CodeMirror-selectedtext';\n    reset(cm);\n    cm.on('cursorActivity', onCursorActivity);\n    cm.on('change', onChange);\n  } else if (!val && prev) {\n    cm.off('cursorActivity', onCursorActivity);\n    cm.off('change', onChange);\n    clear(cm);\n    cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n  }\n});\n\nfunction onCursorActivity(cm) {\n  if (cm.state.markedSelection) {\n    cm.operation(() => {\n      update(cm);\n    });\n  }\n}\n\nfunction onChange(cm) {\n  if (cm.state.markedSelection && cm.state.markedSelection.length) {\n    cm.operation(() => {\n      clear(cm);\n    });\n  }\n}\n\nconst CHUNK_SIZE = 8;\nconst Pos = CodeMirror.Pos;\nconst cmp = CodeMirror.cmpPos;\n\nfunction coverRange(cm, from, to, addAt) {\n  if (cmp(from, to) === 0) {\n    return;\n  }\n  const array = cm.state.markedSelection;\n  const cls = cm.state.markedSelectionStyle;\n\n  for (let line = from.line;;) {\n    const start = line === from.line ? from : Pos(line, 0);\n    const endLine = line + CHUNK_SIZE; const atEnd = endLine >= to.line;\n    const end = atEnd ? to : Pos(endLine, 0);\n    const mark = cm.markText(start, end, { className: cls });\n\n    if (addAt === null || addAt === undefined) {\n      array.push(mark);\n    } else {\n      array.splice(addAt++, 0, mark);\n    }\n    if (atEnd) {\n      break;\n    }\n    line = endLine;\n  }\n}\n\nfunction clear(cm) {\n  const array = cm.state.markedSelection;\n\n  for (let i = 0; i < array.length; ++i) {\n    array[i].clear();\n  }\n  array.length = 0;\n}\n\nfunction reset(cm) {\n  clear(cm);\n  const ranges = cm.listSelections();\n\n  for (let i = 0; i < ranges.length; i++) {\n    coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n}\n\nfunction update(cm) {\n  if (!cm.somethingSelected()) {\n    return clear(cm);\n  }\n  if (cm.listSelections().length > 1) {\n    return reset(cm);\n  }\n\n  const from = cm.getCursor('start'); const to = cm.getCursor('end');\n\n  const array = cm.state.markedSelection;\n\n  if (!array.length) {\n    return coverRange(cm, from, to);\n  }\n\n  let coverStart = array[0].find(); let coverEnd = array[array.length - 1].find();\n\n  if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE ||\n      cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0) {\n    return reset(cm);\n  }\n\n  while (cmp(from, coverStart.from) > 0) {\n    array.shift().clear();\n    coverStart = array[0].find();\n  }\n  if (cmp(from, coverStart.from) < 0) {\n    if (coverStart.to.line - from.line < CHUNK_SIZE) {\n      array.shift().clear();\n      coverRange(cm, from, coverStart.to, 0);\n    } else {\n      coverRange(cm, from, coverStart.from, 0);\n    }\n  }\n\n  while (cmp(to, coverEnd.to) < 0) {\n    array.pop().clear();\n    coverEnd = array[array.length - 1].find();\n  }\n  if (cmp(to, coverEnd.to) > 0) {\n    if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n      array.pop().clear();\n      coverRange(cm, coverEnd.from, to);\n    } else {\n      coverRange(cm, coverEnd.to, to);\n    }\n  }\n}\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.cm-s-base16-dark.CodeMirror{background:#151515;color:#e0e0e0}.cm-s-base16-dark div.CodeMirror-selected{background:#303030}.cm-s-base16-dark .CodeMirror-line::selection,.cm-s-base16-dark .CodeMirror-line>span::selection,.cm-s-base16-dark .CodeMirror-line>span>span::selection{background:rgba(48,48,48,.99)}.cm-s-base16-dark .CodeMirror-line::-moz-selection,.cm-s-base16-dark .CodeMirror-line>span::-moz-selection,.cm-s-base16-dark .CodeMirror-line>span>span::-moz-selection{background:rgba(48,48,48,.99)}.cm-s-base16-dark .CodeMirror-gutters{background:#151515;border-right:0}.cm-s-base16-dark .CodeMirror-guttermarker{color:#ac4142}.cm-s-base16-dark .CodeMirror-guttermarker-subtle,.cm-s-base16-dark .CodeMirror-linenumber{color:#505050}.cm-s-base16-dark .CodeMirror-cursor{border-left:1px solid #b0b0b0}.cm-s-base16-dark .cm-animate-fat-cursor,.cm-s-base16-dark.cm-fat-cursor .CodeMirror-cursor{background-color:#8e8d8875!important}.cm-s-base16-dark span.cm-comment{color:#8f5536}.cm-s-base16-dark span.cm-atom,.cm-s-base16-dark span.cm-number{color:#aa759f}.cm-s-base16-dark span.cm-attribute,.cm-s-base16-dark span.cm-property{color:#90a959}.cm-s-base16-dark span.cm-keyword{color:#ac4142}.cm-s-base16-dark span.cm-string{color:#f4bf75}.cm-s-base16-dark span.cm-variable{color:#90a959}.cm-s-base16-dark span.cm-variable-2{color:#6a9fb5}.cm-s-base16-dark span.cm-def{color:#d28445}.cm-s-base16-dark span.cm-bracket{color:#e0e0e0}.cm-s-base16-dark span.cm-tag{color:#ac4142}.cm-s-base16-dark span.cm-link{color:#aa759f}.cm-s-base16-dark span.cm-error{background:#ac4142;color:#b0b0b0}.cm-s-base16-dark .CodeMirror-activeline-background{background:#202020}.cm-s-base16-dark .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","(function(mod) {\n    if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n      mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));\n    else if (typeof define == \"function\" && define.amd) // AMD\n      define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);\n    else // Plain browser env\n      mod(CodeMirror);\n  })(function(CodeMirror) {\n    'use strict';\n  // CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeymap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, ., :, /, _, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\nfunction initVim$1(CodeMirror) {\n\n  var Pos = CodeMirror.Pos;\n\n  function transformCursor(cm, range) {\n    var vim = cm.state.vim;\n    if (!vim || vim.insertMode) return range.head;\n    var head = vim.sel.head;\n    if (!head)  return range.head;\n\n    if (vim.visualBlock) {\n      if (range.head.line != head.line) {\n        return;\n      }\n    }\n    if (range.from() == range.anchor && !range.empty()) {\n      if (range.head.line == head.line && range.head.ch != head.ch)\n        return new Pos(range.head.line, range.head.ch - 1);\n    }\n\n    return range.head;\n  }\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: 'g<Up>', type: 'keyToKey', toKeys: 'gk' },\n    { keys: 'g<Down>', type: 'keyToKey', toKeys: 'gj' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'keyToKey', toKeys: 'i', context: 'normal'},\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    {keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\"},\n    {keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    {keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\"},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'gn', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: true }},\n    { keys: 'gN', type: 'motion', motion: 'findAndSelectNextInclusive', motionArgs: { forward: false }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-u>', type: 'operatorMotion', operator: 'delete', motion: 'moveToStartOfLine', context: 'insert' },\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    //ignore C-w in normal mode\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'vglobal', shortName: 'v' },\n    { name: 'global', shortName: 'g' }\n  ];\n\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n      if (highlightTimeout) clearTimeout(highlightTimeout);\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        cm.options.$customCursor = null;\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        if (cm.curOp) cm.curOp.selectionChanged = true;\n        cm.options.$customCursor = transformCursor;\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n      }\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = vimApi.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {Shift:'S',Ctrl:'C',Alt:'A',Cmd:'D',Mod:'A',CapsLock:''};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '_', '/']);\n    var upperCaseChars;\n    try { upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\"); }\n    catch (_) { upperCaseChars = /^[A-Z]$/; }\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return upperCaseChars.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            var template = dom('span', {class: 'cm-vim-message'}, 'recording @' + registerName);\n            this.onRecordingDone = cm.openDialog(template, null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      enterVimMode: enterVimMode,\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyway.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        return exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // Non-recursive map function.\n      // NOTE: This will not create mappings to key maps that aren't present\n      // in the default key map. See TODO at bottom of function.\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        // Look through all actual defaults to find a map candidate.\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            // Make a shallow copy of the original keymap entry.\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            // Modify it point to the new mapping with the proper context.\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            // Add it to the keymap with a higher priority than the original.\n            this._mapCommand(newMapping);\n            // Record the mapped contexts as complete.\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n      },\n      // Remove all user-defined mappings for the provided context.\n      mapclear: function(ctx) {\n        // Partition the existing keymap into user-defined and true defaults.\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          // If a specific context is being cleared, we need to keep mappings\n          // from all other contexts.\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                // `mapping` applies to all contexts so create keymap copies\n                // for each context except the one being cleared.\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      multiSelectHandleKey: multiSelectHandleKey,\n\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            if (vim.visualMode) {\n              // Get back to normal mode.\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              // Get back to normal mode.\n              exitInsertMode(cm);\n            } else {\n              // We're already in normal mode. Let '<Esc>' be handled normally.\n              return;\n            }\n            clearInputState(cm);\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            vimApi.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var mainKey = keysMatcher[2] || keysMatcher[1];\n          if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {\n            // multikey operators act linewise by repeating only the last character\n            mainKey = vim.inputState.operatorShortcut;\n          }\n          var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n          else if (match.type == 'clear') { clearInputState(cm); return true; }\n\n          vim.inputState.keyBuffer = '';\n          keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() { return true; };\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!vimApi.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        // The black hole register, \"_, means delete/yank to nowhere.\n        if (registerName === '_') return;\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character || character.length > 1) return {type: 'clear'};\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.keys.length > 1) {\n          inputState.operatorShortcut = command.keys;\n        }\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: '(JavaScript regexp)',\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n          clearInputState(cm);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      /**\n       * Find and select the next occurrence of the search query. If the cursor is currently\n       * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n       * appropriate direction.\n       *\n       * This differs from `findNext` in the following ways:\n       *\n       * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n       * 2. If the cursor is currently inside a search match, this selects the current match\n       *    instead of the next match.\n       * 3. If there is no associated operator, this will turn on visual mode.\n       */\n      findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n\n        if (!query) {\n          return;\n        }\n\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n\n        // next: [from, to] | null\n        var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);\n\n        // No matches.\n        if (!next) {\n          return;\n        }\n\n        // If there's an operator that will be executed, return the selection.\n        if (prevInputState.operator) {\n          return next;\n        }\n\n        // At this point, we know that there is no accompanying operator -- let's\n        // deal with visual mode in order to select an appropriate match.\n\n        var from = next[0];\n        // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n        // the resulting selection is extended by 1 char. Let's shrink it so that only the\n        // match is selected.\n        var to = new Pos(next[1].line, next[1].ch - 1);\n\n        if (vim.visualMode) {\n          // If we were in visualLine or visualBlock mode, get out of it.\n          if (vim.visualLine || vim.visualBlock) {\n            vim.visualLine = false;\n            vim.visualBlock = false;\n            CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n          }\n\n          // If we're currently in visual mode, we should extend the selection to include\n          // the search result.\n          var anchor = vim.sel.anchor;\n          if (anchor) {\n            if (state.isReversed()) {\n              if (motionArgs.forward) {\n                return [anchor, from];\n              }\n\n              return [anchor, to];\n            } else {\n              if (motionArgs.forward) {\n                return [anchor, to];\n              }\n\n              return [anchor, from];\n            }\n          }\n        } else {\n          // Let's turn visual mode on.\n          vim.visualMode = true;\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: \"\"});\n        }\n\n        return prev ? [to, from] : [from, to];\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return new Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        var posV = cm.findPosV(cur, (motionArgs.forward ? repeat : -repeat), 'line', vim.lastHSPos);\n        var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;\n        if (hasMarkedText) {\n          line = posV.line;\n          endCh = posV.ch;\n        }\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last){\n            return moveToEol(cm, head, motionArgs, vim, true);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(new Pos(line, endCh),'div').left;\n        return new Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        return moveToEol(cm, head, motionArgs, vim, false);\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return new Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          // Only include angle brackets in analysis if they are being matched.\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n          var matched = cm.findMatchingBracket(new Pos(line, ch), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return new Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return new Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      moveToStartOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineLeft\");\n        return cm.getCursor();\n      },\n      moveToEndOfDisplayLine: function(cm) {\n        cm.execCommand(\"goLineRight\");\n        var head = cm.getCursor();\n        if (head.sticky == \"before\") head.ch--;\n        return head;\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else if (character === 't') {\n          tmp = expandTagUnderCursor(cm, head, inclusive);\n        } else if (character === 's') {\n          // account for cursor on end of sentence symbol\n          var content = cm.getLine(head.line);\n          if (head.ch > 0 && isEndOfSentenceSymbol(content[head.ch])) {\n            head.ch -= 1;\n          }\n          var end = getSentence(cm, head, motionArgs.repeat, 1, inclusive);\n          var start = getSentence(cm, head, motionArgs.repeat, -1, inclusive);\n          // closer vim behaviour, 'a' only takes the space after the sentence if there is one before and after\n          if (isWhiteSpaceString(cm.getLine(start.line)[start.ch])\n              && isWhiteSpaceString(cm.getLine(end.line)[end.ch -1])) {\n            start = {line: start.line, ch: start.ch + 1};\n          }\n          tmp = {start: start, end: end};\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head);\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        if (cm.indentMore) {\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          for (var j = 0; j < repeat; j++) {\n            if (args.indentRight) cm.indentMore();\n            else cm.indentLess();\n          }\n        } else {\n          var startLine = ranges[0].anchor.line;\n          var endLine = vim.visualBlock ?\n            ranges[ranges.length - 1].anchor.line :\n            ranges[0].head.line;\n          // In visual mode, n> shifts the selection right n times, instead of\n          // shifting n lines right once.\n          var repeat = (vim.visualMode) ? args.repeat : 1;\n          if (args.linewise) {\n            // The only way to delete a newline is to delete until the start of\n            // the next line, so in linewise mode evalInput will include the next\n            // line. We don't want this in indent, so we go back a line.\n            endLine--;\n          }\n          for (var i = startLine; i <= endLine; i++) {\n            for (var j = 0; j < repeat; j++) {\n              cm.indentLine(i, args.indentRight);\n            }\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(new Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        switch (actionArgs.position) {\n          case 'center': y = charCoords.bottom - height / 2;\n            break;\n          case 'bottom':\n            var lineLastCharPos = new Pos(lineNum, cm.getLine(lineNum).length - 1);\n            var lineLastCharCoords = cm.charCoords(lineLastCharPos, 'local');\n            var lineHeight = lineLastCharCoords.bottom - y;\n            y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = new Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = new Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = new Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = new Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch, sel.anchor.ch) + 1);\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, new Pos(anchor.line, anchor.ch + repeat - 1));\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = new Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces\n            ? text.replace(/\\n\\r?/g, '')\n            : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = new Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', new Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n              text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = new Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  new Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, new Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = new Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = new Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = new Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = new Pos(cur.line, start);\n          var to = new Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur) {\n      var vim = cm.state.vim;\n      var includeLineBreak = vim.insertMode || vim.visualMode;\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return new Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return new Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(new Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = new Pos(i, selectionStart.ch);\n            var head = new Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = new Pos(selectionStart.line, 0);\n            selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            fromCh = anchor.ch,\n            bottom = Math.max(anchor.line, head.line),\n            toCh = head.ch;\n        if (fromCh < toCh) { toCh += 1; }\n        else { fromCh += 1; }        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: new Pos(top + i, fromCh),\n            head: new Pos(top + i, toCh)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      if (!vim.insertMode) CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n    }\n\n    /**\n     * Depends on the following:\n     *\n     * - editor mode should be htmlmixedmode / xml\n     * - mode/xml/xml.js should be loaded\n     * - addon/fold/xml-fold.js should be loaded\n     *\n     * If any of the above requirements are not true, this function noops.\n     *\n     * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n     * The following caveats apply (based off cursory testing, I'm sure there\n     * are other discrepancies):\n     *\n     * - Does not work inside comments:\n     *   ```\n     *   <!-- <div>broken</div> -->\n     *   ```\n     * - Does not work when tags have different cases:\n     *   ```\n     *   <div>broken</DIV>\n     *   ```\n     * - Does not work when cursor is inside a broken tag:\n     *   ```\n     *   <div><brok><en></div>\n     *   ```\n     */\n    function expandTagUnderCursor(cm, head, inclusive) {\n      var cur = head;\n      if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n        return { start: cur, end: cur };\n      }\n\n      var tags = CodeMirror.findMatchingTag(cm, head) || CodeMirror.findEnclosingTag(cm, head);\n      if (!tags || !tags.open || !tags.close) {\n        return { start: cur, end: cur };\n      }\n\n      if (inclusive) {\n        return { start: tags.open.from, end: tags.close.to };\n      }\n      return { start: tags.open.to, end: tags.close.from };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/^#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return new Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = new Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return new Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return new Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return new Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval= new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end=cm.clipPos(retval);\n      end.ch--;\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n      }\n      return retval;\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return new Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, new Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n  function getSentence(cm, cur, repeat, dir, inclusive /*includes whitespace*/) {\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the pos member to represent the\n    next valid position or sets the line to null if there are\n    no more valid positions.\n   */\n    function nextChar(curr) {\n      if (curr.pos + curr.dir < 0 || curr.pos + curr.dir >= curr.line.length) {\n          curr.line = null;\n        }\n      else {\n        curr.pos += curr.dir;\n      }\n    }\n    /*\n    Performs one iteration of traversal in forward direction\n    Returns an index object of the new location\n   */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        lastSentencePos = curr.pos;\n        if (isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: curr.pos + 1 };\n          } else {\n            nextChar(curr);\n            while (curr.line !== null ) {\n              if (isWhiteSpaceString(curr.line[curr.pos])) {\n                lastSentencePos = curr.pos;\n                nextChar(curr);\n              } else {\n                break;\n              }\n            }\n            return { ln: curr.ln, pos: lastSentencePos + 1, };\n          }\n        }\n        nextChar(curr);\n      }\n      return { ln: curr.ln, pos: lastSentencePos + 1 };\n    }\n\n    /*\n    Performs one iteration of traversal in reverse direction\n    Returns an index object of the new location\n   */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      if (curr.line === \"\") {\n        return { ln: curr.ln, pos: curr.pos };\n      }\n\n      var lastSentencePos = curr.pos;\n\n      // Move one step to skip character we start on\n      nextChar(curr);\n\n      while (curr.line !== null) {\n        if (!isWhiteSpaceString(curr.line[curr.pos]) && !isEndOfSentenceSymbol(curr.line[curr.pos])) {\n          lastSentencePos = curr.pos;\n        }\n\n        else if (isEndOfSentenceSymbol(curr.line[curr.pos]) ) {\n          if (!inclusive) {\n            return { ln: curr.ln, pos: lastSentencePos };\n          } else {\n              if (isWhiteSpaceString(curr.line[curr.pos + 1])) {\n                return { ln: curr.ln, pos: curr.pos + 1, };\n              } else {\n                return {ln: curr.ln, pos: lastSentencePos};\n              }\n          }\n        }\n\n        nextChar(curr);\n      }\n      curr.line = line;\n      if (inclusive && isWhiteSpaceString(curr.line[curr.pos])) {\n        return { ln: curr.ln, pos: curr.pos };\n      } else {\n        return { ln: curr.ln, pos: lastSentencePos };\n      }\n\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n\n    /*\n    Takes an index object\n    {\n    line: the line string,\n    ln: line number,\n    pos: index in line,\n    dir: direction of traversal (-1 or 1)\n    }\n    and modifies the line, ln, and pos members to represent the\n    next valid position or sets them to null if there are\n    no more valid positions.\n   */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        };\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos };\n          }\n\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return new Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belongs\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: new Pos(cur.line, start),\n        end: new Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t', '\\\\&':'&'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'im' : 'm');\n      return regexp;\n    }\n\n    /**\n     * dom - Document Object Manipulator\n     * Usage:\n     *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n     * Examples:\n     *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n     *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n     * Not supported:\n     *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n     */\n    function dom(n) {\n      if (typeof n === 'string') n = document.createElement(n);\n      for (var a, i = 1; i < arguments.length; i++) {\n        if (!(a = arguments[i])) continue;\n        if (typeof a !== 'object') a = document.createTextNode(a);\n        if (a.nodeType) n.appendChild(a);\n        else for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === '$') n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n      }\n      return n;\n    }\n\n    function showConfirm(cm, template) {\n      var pre = dom('div', {$color: 'red', $whiteSpace: 'pre', class: 'cm-vim-message'}, template);\n      if (cm.openNotification) {\n        cm.openNotification(pre, {bottom: true, duration: 5000});\n      } else {\n        alert(pre.innerText);\n      }\n    }\n\n    function makePrompt(prefix, desc) {\n      return dom(document.createDocumentFragment(),\n               dom('span', {$fontFamily: 'monospace', $whiteSpace: 'pre'},\n                 prefix,\n                 dom('input', {type: 'text', autocorrect: 'off',\n                               autocapitalize: 'off', spellcheck: 'false'})),\n               desc && dom('span', {$color: '#888'}, desc));\n    }\n\n    function showPrompt(cm, options) {\n      var template = makePrompt(options.prefix, options.desc);\n      if (cm.openDialog) {\n        cm.openDialog(template, options.onClose, {\n          onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n          bottom: true, selectValueOnOpen: false, value: options.value\n        });\n      }\n      else {\n        var shortText = '';\n        if (typeof options.prefix != \"string\" && options.prefix) shortText += options.prefix.textContent;\n        if (options.desc) shortText += \" \" + options.desc;\n        options.onClose(prompt(shortText, ''));\n      }\n    }\n\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    var highlightTimeout = 0;\n    function highlightSearchMatches(cm, query) {\n      clearTimeout(highlightTimeout);\n      highlightTimeout = setTimeout(function() {\n        if (!cm.state.vim) return;\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (!overlay || query != overlay.query) {\n          if (overlay) {\n            cm.removeOverlay(overlay);\n          }\n          overlay = searchOverlay(query);\n          cm.addOverlay(overlay);\n          if (cm.showMatchesOnScrollbar) {\n            if (searchState.getScrollbarAnnotate()) {\n              searchState.getScrollbarAnnotate().clear();\n            }\n            searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n          }\n          searchState.setOverlay(overlay);\n        }\n      }, 50);\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            var lastEndPos = prev ? cursor.from() : cursor.to();\n            found = cursor.find(prev);\n            if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n              if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n                found = cursor.find(prev);\n            }\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    /**\n     * Pretty much the same as `findNext`, except for the following differences:\n     *\n     * 1. Before starting the search, move to the previous search. This way if our cursor is\n     * already inside a match, we should return the current match.\n     * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n     */\n    function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n\n        // Go back one result to ensure that if the cursor is currently a match, we keep it.\n        var found = cursor.find(!prev);\n\n        // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n        if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n          cursor.find(!prev);\n        }\n\n        for (var i = 0; i < repeat; i++) {\n          found = cursor.find(prev);\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return [cursor.from(), cursor.to()];\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (typeof end == 'number') {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var done = cm.doc.history.done;\n      for (var i = done.length; i--;) {\n        if (done[i].changes) {\n          return copyCursor(done[i].changes[0].to);\n        }\n      }\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                vimApi.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e.toString());\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return true;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return true;\n            }\n          }\n        }\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n        }\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------\\n\\n';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '\\n';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '\\n';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = new Pos(lineStart, 0);\n        var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      vglobal: function(cm, params) {\n        // global inspects params.commandName\n        this.global(cm, params);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var inverted = params.commandName[0] === 'v';\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [];\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var line = cm.getLineHandle(i);\n          var matched = query.test(line.text);\n          if (matched !== inverted) {\n            matchedLines.push(cmd ? line : line.text);\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, matchedLines.join('\\n'));\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var line = matchedLines[index++];\n            var lineNum = cm.getLineNumber(line);\n            if (lineNum == null) {\n              nextCommand();\n              return;\n            }\n            var command = (lineNum + 1) + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using JavaScript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos, modifiedLineNumber, joined;\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        var unmodifiedLineNumber = searchCursor.to().line;\n        searchCursor.replace(newText);\n        modifiedLineNumber = searchCursor.to().line;\n        lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n        joined = modifiedLineNumber < unmodifiedLineNumber;\n      }\n      function findNextValidMatch() {\n        var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n        var match = searchCursor.findNext();\n        if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {\n          match = searchCursor.findNext();\n        }\n        return match;\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(findNextValidMatch() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: dom('span', 'replace with ', dom('strong', replaceWith), ' (y/n/a/q/l)'),\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        // Set up block selection again for repeating the changes.\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            cm.replaceSelection(change);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n            cm.setCursor(end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    // multiselect support\n    function cloneVimState(state) {\n      var n = new state.constructor();\n      Object.keys(state).forEach(function(key) {\n        var o = state[key];\n        if (Array.isArray(o))\n          o = o.slice();\n        else if (o && typeof o == \"object\" && o.constructor != Object)\n          o = cloneVimState(o);\n        n[key] = o;\n      });\n      if (state.sel) {\n        n.sel = {\n          head: state.sel.head && copyCursor(state.sel.head),\n          anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n        };\n      }\n      return n;\n    }\n    function multiSelectHandleKey(cm, key, origin) {\n      var isHandled = false;\n      var vim = vimApi.maybeInitVimState_(cm);\n      var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n      var wasMultiselect = cm.isInMultiSelectMode();\n      if (vim.wasInVisualBlock && !wasMultiselect) {\n        vim.wasInVisualBlock = false;\n      } else if (wasMultiselect && vim.visualBlock) {\n         vim.wasInVisualBlock = true;\n      }\n\n      if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect && vim.status == \"<Esc>\") {\n        // allow editor to exit multiselect\n        clearInputState(cm);\n      } else if (visualBlock || !wasMultiselect || cm.inVirtualSelectionMode) {\n        isHandled = vimApi.handleKey(cm, key, origin);\n      } else {\n        var old = cloneVimState(vim);\n\n        cm.operation(function() {\n          cm.curOp.isVimOp = true;\n          cm.forEachSelection(function() {\n            var head = cm.getCursor(\"head\");\n            var anchor = cm.getCursor(\"anchor\");\n            var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n            var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n            head = offsetCursor(head, 0, headOffset);\n            anchor = offsetCursor(anchor, 0, anchorOffset);\n            cm.state.vim.sel.head = head;\n            cm.state.vim.sel.anchor = anchor;\n\n            isHandled = vimApi.handleKey(cm, key, origin);\n            if (cm.virtualSelection) {\n              cm.state.vim = cloneVimState(old);\n            }\n          });\n          if (cm.curOp.cursorActivity && !isHandled)\n            cm.curOp.cursorActivity = false;\n          cm.state.vim = vim;\n        }, true);\n      }\n      // some commands may bring visualMode and selection out of sync\n      if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n        handleExternalSelection(cm, vim);\n      }\n      return isHandled;\n    }\n    resetVimGlobalState();\n\n  return vimApi;\n}\n\nfunction initVim(CodeMirror5) {\r\n  CodeMirror5.Vim = initVim$1(CodeMirror5);\r\n  return CodeMirror5.Vim;\r\n}\n\n\n\n    CodeMirror.Vim = initVim(CodeMirror);\n  });\n  ","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n  var LINT_LINE_ID = \"CodeMirror-lint-line-\";\n\n  function showTooltip(cm, e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip cm-s-\" + cm.options.theme;\n    tt.appendChild(content.cloneNode(true));\n    if (cm.state.lint.options.selfContain)\n      cm.getWrapperElement().appendChild(tt);\n    else\n      document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      var top = Math.max(0, e.clientY - tt.offsetHeight - 5);\n      var left = Math.max(0, Math.min(e.clientX + 5, tt.ownerDocument.defaultView.innerWidth - tt.offsetWidth));\n      tt.style.top = top + \"px\"\n      tt.style.left = left + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(cm, e, content, node) {\n    var tooltip = showTooltip(cm, e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n && n.nodeType == 11) n = n.host;\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, conf, hasGutter) {\n    this.marked = [];\n    if (conf instanceof Function) conf = {getAnnotations: conf};\n    if (!conf || conf === true) conf = {};\n    this.options = {};\n    this.linterOptions = conf.options || {};\n    for (var prop in defaults) this.options[prop] = defaults[prop];\n    for (var prop in conf) {\n      if (defaults.hasOwnProperty(prop)) {\n        if (conf[prop] != null) this.options[prop] = conf[prop];\n      } else if (!conf.options) {\n        this.linterOptions[prop] = conf[prop];\n      }\n    }\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n    this.waitingFor = 0\n  }\n\n  var defaults = {\n    highlightLines: false,\n    tooltips: true,\n    delay: 500,\n    lintOnChange: true,\n    getAnnotations: null,\n    async: false,\n    selfContain: null,\n    formatAnnotation: null,\n    onUpdateLinting: null\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    if (state.options.highlightLines) clearErrorLines(cm);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function clearErrorLines(cm) {\n    cm.eachLine(function(line) {\n      var has = line.wrapClass && /\\bCodeMirror-lint-line-\\w+\\b/.exec(line.wrapClass);\n      if (has) cm.removeLineClass(line, \"wrap\", has[0]);\n    })\n  }\n\n  function makeMarker(cm, labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(cm, e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!severity) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message CodeMirror-lint-message-\" + severity;\n    if (typeof ann.messageHTML != 'undefined') {\n      tip.innerHTML = ann.messageHTML;\n    } else {\n      tip.appendChild(document.createTextNode(ann.message));\n    }\n    return tip;\n  }\n\n  function lintAsync(cm, getAnnotations) {\n    var state = cm.state.lint\n    var id = ++state.waitingFor\n    function abort() {\n      id = -1\n      cm.off(\"change\", abort)\n    }\n    cm.on(\"change\", abort)\n    getAnnotations(cm.getValue(), function(annotations, arg2) {\n      cm.off(\"change\", abort)\n      if (state.waitingFor != id) return\n      if (arg2 && annotations instanceof CodeMirror) annotations = arg2\n      cm.operation(function() {updateLinting(cm, annotations)})\n    }, state.linterOptions, cm);\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    /*\n     * Passing rules in `options` property prevents JSHint (and other linters) from complaining\n     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.\n     */\n    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!getAnnotations) return;\n    if (options.async || getAnnotations.async) {\n      lintAsync(cm, getAnnotations)\n    } else {\n      var annotations = getAnnotations(cm.getValue(), state.linterOptions, cm);\n      if (!annotations) return;\n      if (annotations.then) annotations.then(function(issues) {\n        cm.operation(function() {updateLinting(cm, issues)})\n      });\n      else cm.operation(function() {updateLinting(cm, annotations)})\n    }\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    clearMarks(cm);\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!severity) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, anns.length > 1,\n                                                       options.tooltips));\n\n      if (options.highlightLines)\n        cm.addLineClass(line, \"wrap\", LINT_LINE_ID + maxSeverity);\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay);\n  }\n\n  function popupTooltips(cm, annotations, e) {\n    var target = e.target || e.srcElement;\n    var tooltip = document.createDocumentFragment();\n    for (var i = 0; i < annotations.length; i++) {\n      var ann = annotations[i];\n      tooltip.appendChild(annotationTooltip(ann));\n    }\n    showTooltipFor(cm, e, tooltip, target);\n  }\n\n  function onMouseOver(cm, e) {\n    var target = e.target || e.srcElement;\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n\n    var annotations = [];\n    for (var i = 0; i < spans.length; ++i) {\n      var ann = spans[i].__annotation;\n      if (ann) annotations.push(ann);\n    }\n    if (annotations.length) popupTooltips(cm, annotations, e);\n  }\n\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      if (cm.state.lint.options.lintOnChange !== false)\n        cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      clearTimeout(cm.state.lint.timeout);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, val, hasLintGutter);\n      if (state.options.lintOnChange)\n        cm.on(\"change\", onChange);\n      if (state.options.tooltips != false && state.options.tooltips != \"gutter\")\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  });\n\n  CodeMirror.defineExtension(\"performLint\", function() {\n    startLinting(this);\n  });\n});\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./base16-dark.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"10dd2426\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../../css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../../css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.CodeMirror-hints{position:absolute;z-index:10;overflow:hidden;list-style:none;margin:0;padding:2px;box-shadow:2px 3px 5px rgba(0,0,0,.2);border-radius:3px;border:1px solid silver;background:#fff;font-size:90%;font-family:monospace;max-height:20em;overflow-y:auto;box-sizing:border-box}.CodeMirror-hint{margin:0;padding:0 4px;border-radius:2px;white-space:pre;color:#000;cursor:pointer}li.CodeMirror-hint-active{background:#08f;color:#fff}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../css-loader/dist/cjs.js??clonedRuleSet-14.use[1]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[2]!../../../postcss-loader/dist/cjs.js??clonedRuleSet-14.use[3]!./show-hint.css\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"0299c970\", content, true, {\"sourceMap\":false,\"shadowMode\":false});","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.cm-s-base16-light.CodeMirror{background:#f5f5f5;color:#202020}.cm-s-base16-light div.CodeMirror-selected{background:#e0e0e0}.cm-s-base16-light .CodeMirror-line::selection,.cm-s-base16-light .CodeMirror-line>span::selection,.cm-s-base16-light .CodeMirror-line>span>span::selection{background:#e0e0e0}.cm-s-base16-light .CodeMirror-line::-moz-selection,.cm-s-base16-light .CodeMirror-line>span::-moz-selection,.cm-s-base16-light .CodeMirror-line>span>span::-moz-selection{background:#e0e0e0}.cm-s-base16-light .CodeMirror-gutters{background:#f5f5f5;border-right:0}.cm-s-base16-light .CodeMirror-guttermarker{color:#ac4142}.cm-s-base16-light .CodeMirror-guttermarker-subtle,.cm-s-base16-light .CodeMirror-linenumber{color:#b0b0b0}.cm-s-base16-light .CodeMirror-cursor{border-left:1px solid #505050}.cm-s-base16-light span.cm-comment{color:#8f5536}.cm-s-base16-light span.cm-atom,.cm-s-base16-light span.cm-number{color:#aa759f}.cm-s-base16-light span.cm-attribute,.cm-s-base16-light span.cm-property{color:#90a959}.cm-s-base16-light span.cm-keyword{color:#ac4142}.cm-s-base16-light span.cm-string{color:#f4bf75}.cm-s-base16-light span.cm-variable{color:#90a959}.cm-s-base16-light span.cm-variable-2{color:#6a9fb5}.cm-s-base16-light span.cm-def{color:#d28445}.cm-s-base16-light span.cm-bracket{color:#202020}.cm-s-base16-light span.cm-tag{color:#ac4142}.cm-s-base16-light span.cm-link{color:#aa759f}.cm-s-base16-light span.cm-error{background:#ac4142;color:#505050}.cm-s-base16-light .CodeMirror-activeline-background{background:#dddcdc}.cm-s-base16-light .CodeMirror-matchingbracket{color:#f5f5f5!important;background-color:#6a9fb5!important}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\"};\n\n  function bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/\n  }\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n    var re = bracketRegex(config)\n\n    // A cursor is defined as between two characters, but in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)]) ||\n        re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = bracketRegex(config)\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined ||\n                            (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))) {\n          var match = matching[ch];\n          if (match && (match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000,\n      highlightNonMatching = config && config.highlightNonMatching;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textarea whenever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  function clearHighlighted(cm) {\n    if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n      cm.state.matchBrackets.currentlyHighlighted();\n      cm.state.matchBrackets.currentlyHighlighted = null;\n    }\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      cm.off(\"focus\", doMatchBrackets)\n      cm.off(\"blur\", clearHighlighted)\n      clearHighlighted(cm);\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n      cm.on(\"focus\", doMatchBrackets)\n      cm.on(\"blur\", clearHighlighted)\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n"],"names":["content","__esModule","default","module","id","locals","exports","add","mod","CodeMirror","cmds","commands","Pos","posEq","a","b","line","ch","killRing","addToRing","str","push","length","shift","growRingTop","getFromRing","n","Math","min","popFromRing","pop","lastKill","_kill","cm","from","to","ring","text","getRange","pos","isClean","gen","replaceRange","changeGeneration","byChar","dir","findPosH","byWord","byLine","findPosV","doc","sel","goalColumn","byPage","byParagraph","no","getLine","sawText","test","slice","fst","firstLine","lst","lastLine","clipPos","hasText","bySentence","sawWord","next","charAt","byExpr","wrap","findMatchingBracket","strict","match","forward","first","token","getTokenAt","after","start","end","string","newPos","getPrefix","precise","digits","state","emacsPrefix","clearPrefix","Number","repeated","cmd","f","execCommand","prefix","i","findEnd","by","move","extendSelection","getCursor","motion","killTo","cursor","selections","listSelections","head","_killRegion","somethingSelected","selection","anchor","addPrefix","digit","on","maybeClearPrefix","maybeDuplicateInput","prefixPreservingKeys","arg","emacsPrefixMap","hasOwnProperty","off","event","dup","origin","one","join","txt","replaceSelection","maybeRemovePrefixMap","removeKeyMap","prefixMap","clearMark","setExtending","setCursor","makePrompt","msg","fragment","document","createDocumentFragment","input","createElement","setAttribute","style","width","appendChild","createTextNode","getInput","openDialog","bottom","prompt","operateOnWord","op","toEnclosingExpr","stack","setMark","getExtending","killRegion","killLineEmacs","killRingSave","getSelection","yank","setSelection","yankPop","forwardChar","backwardChar","deleteChar","deleteForwardChar","deleteBackwardChar","forwardWord","backwardWord","killWord","backwardKillWord","nextLine","previousLine","scrollDownCommand","scrollUpCommand","backwardParagraph","forwardParagraph","backwardSentence","forwardSentence","killSentence","backwardKillSentence","killSexp","backwardKillSexp","forwardSexp","backwardSexp","markSexp","transposeSexps","leftStart","leftEnd","rightEnd","rightStart","backwardUpList","justOneSpace","openLine","transposeCharsRepeatable","capitalizeWord","w","letter","search","toUpperCase","toLowerCase","upcaseWord","downcaseWord","undoRepeatable","keyboardQuit","newline","gotoLine","num","isNaN","indentRigidly","indentSelection","getOption","exchangePointAndMark","quotedInsertTab","universalArgument","addKeyMap","emacs","kill","keyMap","normalizeKeyMap","regPrefix","d","String","___CSS_LOADER_URL_IMPORT_0___","URL","___CSS_LOADER_URL_IMPORT_1___","___CSS_LOADER_URL_IMPORT_2___","___CSS_LOADER_URL_IMPORT_3___","___CSS_LOADER_URL_IMPORT_4___","___CSS_LOADER_EXPORT___","___CSS_LOADER_URL_REPLACEMENT_0___","___CSS_LOADER_URL_REPLACEMENT_1___","___CSS_LOADER_URL_REPLACEMENT_2___","___CSS_LOADER_URL_REPLACEMENT_3___","___CSS_LOADER_URL_REPLACEMENT_4___","findPosSubword","type","startPos","e","cat","isWordChar","moveSubword","extendSelectionsBy","range","display","extend","empty","insertLine","above","isReadOnly","Pass","operation","len","newSelection","last","at","indentLine","setSelections","wordAt","word","addCursorToSelection","ranges","newRanges","newAnchor","newHead","cursorCoords","left","newRange","isSelectedRange","cmpPos","goSubwordLeft","goSubwordRight","scrollLineUp","info","getScrollInfo","visibleBottomLine","lineAtHeight","top","clientHeight","scrollTo","defaultTextHeight","scrollLineDown","visibleTopLine","splitSelectionByLine","lineRanges","singleSelectionTop","scroll","selectLine","extended","insertLineAfter","insertLineBefore","selectNextOccurrence","fullWord","sublimeFindFullWord","query","RegExp","cur","getSearchCursor","found","findNext","addSelection","skipAndSelectNextOccurrence","prevAnchor","prevHead","filter","addCursorToPrevLine","addCursorToNextLine","mirror","selectBetweenBrackets","opening","scanForBracket","closing","indexOf","puncType","undefined","sortLines","caseSensitive","direction","selected","toSort","lines","sort","au","bu","modifyWordOrSelection","indices","replacements","replaceSelections","getTarget","findAndGoTo","target","findPrevious","selectScope","goToBracket","getTokenTypeAt","prev","swapLineUp","linesToMove","newSels","scrollIntoView","swapLineDown","toggleCommentIndented","toggleComment","indent","joinLines","joined","offset","obj","actual","exec","duplicateLine","rangeCount","reverseSortLines","sortLinesInsensitive","reverseSortLinesInsensitive","nextBookmark","marks","sublimeBookmarks","current","find","prevBookmark","unshift","toggleBookmark","findMarksAt","findMarks","j","sublimeBookmark","clear","k","splice","markText","clearWhenEmpty","clearBookmarks","selectBookmarks","smartBackspace","cursors","indentUnit","toStartOfLine","column","countColumn","deletePos","prevIndent","findColumn","delLineRight","upcaseAtCursor","downcaseAtCursor","setSublimeMark","sublimeMark","setBookmark","selectToSublimeMark","deleteToSublimeMark","tmp","sublimeKilled","swapWithSublimeMark","sublimeYank","showInCenter","findUnder","findUnderPrevious","findAllUnder","matches","primaryIndex","macSublime","pcSublime","mac","macDefault","sublime","HINT_ELEMENT_CLASS","ACTIVE_HINT_ELEMENT_CLASS","Completion","options","this","widget","debounce","tick","startLen","updateOnCursorActivity","self","activityFunc","cursorActivity","showHint","getHints","async","newOpts","hint","prop","defineExtension","parseOptions","supportsSelection","completionActive","close","completion","signal","update","requestAnimationFrame","window","fn","setTimeout","cancelAnimationFrame","clearTimeout","editor","hintOptions","out","defaultOptions","resolve","getText","buildKeyMap","handle","baseMap","Up","moveFocus","Down","PageUp","menuSize","PageDown","Home","setFocus","End","Enter","pick","Tab","Esc","navigator","platform","custom","customKeys","ourMap","addBinding","key","val","bound","extra","extraKeys","getHintElement","hintsElement","el","nodeName","parentNode","Widget","data","floor","random","picked","ownerDocument","getInputField","parentWindow","defaultView","hints","theme","className","selectedHint","completions","list","elt","render","displayText","hintId","container","body","alignWithWord","below","offsetLeft","offsetTop","isContainerPositioned","getComputedStyle","position","offsetParent","offsetParentPosition","getBoundingClientRect","bodyPosition","scrollLeft","scrollTop","winW","innerWidth","max","offsetWidth","documentElement","winH","innerHeight","offsetHeight","startScroll","box","moveOnOverlap","DOMRect","scrolls","paddingForScrollbar","scrollHeight","overlapY","height","spaceAbove","closingOnBlur","overlapX","right","nativeBarWidth","node","firstChild","nextSibling","paddingRight","avoidWrap","changeActive","screenAmount","closeOnUnfocus","onBlur","onFocus","onScroll","curScroll","getWrapperElement","newTop","point","pageYOffset","t","srcElement","completeOnSingleClick","focus","selectedHintRange","getSelectedHintRange","scrollToActive","childNodes","applicableHelpers","helpers","result","fetchHints","callback","then","resolveAutoHints","words","getHelpers","resolved","app","run","getHelper","fromList","anyword","prototype","active","closeOnPick","identStart","closeCharacters","disable","myTick","finishUpdate","completeSingle","removeChild","removeAttribute","replace","node1","node2","firstNode","margin","scrollMargin","registerHelper","term","substr","autocomplete","auto","defineOption","WORD","RANGE","curLine","curWord","seen","re","source","endLine","m","lastIndexOf","Object","call","defineMode","config","parserConfig","statementIndent","jsonldMode","jsonld","jsonMode","json","trackScope","isTS","typescript","wordRE","wordCharacters","keywords","kw","A","B","C","D","operator","atom","isOperatorChar","isJsonldKeyword","readRegexp","stream","escaped","inSet","ret","tp","cont","tokenBase","tokenize","tokenString","eat","tokenComment","skipToEnd","expressionAllowed","tokenQuasi","peek","eatWhile","lexical","lastType","propertyIsEnumerable","quote","maybeEnd","brackets","findFatArrow","fatArrowAt","arrow","index","depth","sawSomething","bracket","atomicTypes","JSLexical","indented","align","inScope","varname","v","localVars","name","cx","context","vars","parseJS","cc","marked","combinator","expression","statement","lex","pass","arguments","apply","inList","register","block","newContext","registerVarScoped","Var","globalVars","inner","Context","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","outer","poplex","expect","wanted","exp","value","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","enumdef","typename","typeexpr","pattern","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","me","expr","property","backUp","continueQuasi","targetNoComma","maybeTypeArgs","_","getterSetter","afterprop","maybetype","what","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","isInterface","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","isContinuedStatement","textAfter","startState","basecolumn","sol","indentation","eatSpace","firstChar","c","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","blockCommentContinue","lineComment","fold","closeBrackets","helperType","skipExpression","StringStream","defineMIME","cons","keywordRegex","esc","literal","keyCol","pair","pairStart","inlinePairs","inlineList","doFold","noFold","regexpFlags","regexp","flags","ignoreCase","global","multiline","ensureFlags","maybeMultiline","searchRegexpForward","lastIndex","searchRegexpForwardMultiline","chunk","before","split","inside","startLine","startCh","lastMatchIn","endMargin","newMatch","searchRegexpBackward","searchRegexpBackwardMultiline","chunkSize","adjustPos","orig","folded","foldFunc","mid","searchStringForward","caseFold","cutFrom","endString","searchStringBackward","topString","SearchCursor","atOccurrence","afterEmptyMatch","reverse","normalize","newText","splitLines","defineDocExtension","jsyaml","console","error","loadAll","loc","mark","message","dialogDiv","template","dialog","innerHTML","addClass","closeNotification","newVal","currentNotificationClose","closed","inp","rmClass","onClose","button","getElementsByTagName","selectValueOnOpen","select","onInput","onKeyUp","onKeyDown","keyCode","closeOnEnter","blur","e_stop","closeOnBlur","evt","relatedTarget","callbacks","buttons","blurring","e_preventDefault","doneTimer","duration","isLineComment","lineNo","commentIndent","spaceTo","lineIndent","countSpaces","onCursorActivity","markedSelection","onChange","myIndent","lastLineInFold","regex","foldCode","path","elements","trimmed","trim","endsWith","currentPath","map","codeMirror","addOverlay","old","markedSelectionStyle","reset","CHUNK_SIZE","cmp","coverRange","addAt","array","cls","atEnd","coverStart","coverEnd","initVim$1","transformCursor","vim","insertMode","visualBlock","defaultKeymap","keys","toKeys","action","motionArgs","linewise","toJumplist","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","matchIndent","sameLine","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","fullLine","exitVisualBlock","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","enterVimMode","setOption","mode","maybeInitVimState","getOnPasteFn","leaveVimMode","highlightTimeout","detachVimMap","$customCursor","attach","attachVimMap","curOp","selectionChanged","cmKey","vimKey","cmKeyToVimKey","vimApi","findKey","Init","modifiers","Shift","Ctrl","Alt","Cmd","Mod","CapsLock","specialKeys","Backspace","Delete","Insert","pieces","lastPiece","hasCharacter","piece","isUpperCase","onPasteFn","offsetCursor","actions","enterInsertMode","numberRegex","wordCharTest","bigWordCharTest","makeKeyRange","size","fromCharCode","upperCaseChars","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","isLowerCase","isMatchableSymbol","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","defaultValue","aliases","Error","cfg","option","scope","local","vimGlobalState","lastInsertModeKeyTimer","createCircularJumpList","pointer","tail","buffer","Array","oldCur","newCur","curMark","useNextSlot","trashMark","markPos","cursorEqual","inc","oldPointer","cachedCursor","createInsertModeChanges","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","insertModeRepeat","visualMode","lastSelection","lastPastedText","resetVimGlobalState","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","exitMacroRecordMode","enterMacroRecordMode","registerName","getRegister","dom","class","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","newMapping","_mapCommand","mappedCtxs","mapclear","userKeymap","contexts","defineEx","func","exCommands","commandMap_","handleKey","command","multiSelectHandleKey","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","substring","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","here","handleKeyNonInsertMode","keysMatcher","mainKey","operatorShortcut","pushRepeatDigit","isVimOp","processCommand","handleEx","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","reason","Register","insertModeChanges","searchQueries","registers","unnamedRegister","historyBuffer","iterator","initialPrefix","getRepeat","repeat","parseInt","setText","pushText","pushInsertModeChanges","pushSearchQuery","toString","isValidRegister","append","shiftNumericRegisters_","nextMatch","up","element","pushInput","bestMatch","commandMatches","full","partial","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","handleQuery","showPrompt","onPromptClose","desc","onPromptKeyUp","onPromptKeyDown","expandWordUnderCursor","isKeyword","escapeRegex","smartCase","updateSearchQuery","showConfirm","logSearchQuery","parsedQuery","keyName","selectionEnd","selectionStart","clearSearchHighlight","exArgs","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","lineLength","expandSelectionToLine","clipToLine","exclusive","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","moveToBottomLine","expandToLine","_cm","isReversed","highlightSearchMatches","findAndSelectNextInclusive","prevInputState","findNextFromAndToInclusive","subMode","goToMark","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","posV","hasMarkedText","moveToStartOfLine","charCoords","res","hitSide","lastCharCoords","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","lineText","matched","bracketRegex","moveToLineOrEdgeOfDocument","lineNum","moveToStartOfDisplayLine","moveToEndOfDisplayLine","sticky","textObjectManipulation","mirroredPairs","selfPaired","selectCompanionObject","findBeginningAndEnd","expandTagUnderCursor","getSentence","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fillArray","times","change","args","finalHead","MAX_VALUE","replacement","lastState","prevLineEnd","wasLastLine","newlineAndIndent","indentMore","indentLess","indentAuto","_args","changeCase","getSelections","swapped","toSwap","endPos","jumpListWalk","lineHeight","delta","ceil","newBottom","scrollToCursor","y","lineLastCharPos","lineLastCharCoords","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","getLastEditPos","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","lastCh","extendLineToColumn","undo","repeatFn","redo","setRegister","markName","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","baseStr","base","number","zeroPadding","repeatLastEdit","includeLineBreak","maxCh","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","cur3","cur1before2","cur2before3","s","isClipped","curHead","primIndex","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","headOffset","anchorOffset","fromCh","toCh","getHead","moveHead","firstNonWS","_forward","noSymbol","wordStart","findMatchingTag","findEnclosingTag","tags","open","symbolToMode","findSymbolModes","isComplete","nextCh","symb","reverseSymb","section","init","curMoveThrough","comment","method","preprocess","lineCount","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","eodCh","shortCircuit","firstWord","lastWord","keepHPos","retval","charIdxInLine","includeChar","isEmpty","isBoundary","any","nextChar","curr","ln","lastSentencePos","curr_index","last_valid","skip_empty_lines","bracketRegexp","openSym","curChar","chars","firstIndex","SearchState","searchState_","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","specialComesNext","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","output","eol","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","nodeType","pre","$color","$whiteSpace","openNotification","alert","innerText","$fontFamily","autocorrect","autocapitalize","spellcheck","shortText","textContent","regexEqual","r1","r2","props","rawQuery","matchSol","searchState","removeOverlay","showMatchesOnScrollbar","lastEndPos","isInRange","scrollInfo","occludeToleranceTop","occludeToleranceBottom","bottomY","done","history","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","forceGet","optionIsBoolean","oldValue","setOptionReturn","setlocal","setglobal","regArgs","regInfo","unique","parseArgs","opts","decimal","hex","octal","err","lineStart","radix","numPart","textPart","matchPart","comparePatternFn","compareFn","textOld","anum","bnum","vglobal","inverted","matchedLines","getLineHandle","nextCommand","getLineNumber","substitute","trailing","count","replacePart","confirm","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","lastPos","modifiedLineNumber","replaceAll","unmodifiedLineNumber","findNextValidMatch","lastMatchTo","_value","savedCallback","insertModeChangeRegister","lastChange","logInsertModeChange","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","onKeyFound","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","cloneVimState","constructor","forEach","o","isArray","isHandled","wasInVisualBlock","wasMultiselect","isInMultiSelectMode","status","inVirtualSelectionMode","forEachSelection","virtualSelection","insert","detach","fallthrough","initVim","CodeMirror5","Vim","GUTTER_ID","LINT_LINE_ID","showTooltip","tt","clientY","clientX","cloneNode","lint","selfContain","opacity","rm","hideTooltip","showTooltipFor","tooltip","hide","poll","setInterval","host","clearInterval","LintState","conf","hasGutter","Function","getAnnotations","linterOptions","defaults","timeout","onMouseOver","waitingFor","highlightLines","tooltips","delay","lintOnChange","formatAnnotation","onUpdateLinting","clearMarks","clearGutter","clearErrorLines","eachLine","has","wrapClass","removeLineClass","makeMarker","labels","severity","multiple","marker","getMaxSeverity","groupByLine","annotations","ann","annotationTooltip","tip","messageHTML","lintAsync","abort","getValue","arg2","updateLinting","startLinting","issues","annotationsNotSorted","anns","maxSeverity","tipLabel","__annotation","setGutterMarker","addLineClass","popupTooltips","x","spans","gutters","hasLintGutter","ie_lt8","userAgent","documentMode","matching","where","afterCursor","maxScanLen","maxScanLineLength","maxScanLines","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","highlightNonMatching","focused","doMatchBrackets","currentlyHighlighted","clearHighlighted","oldConfig"],"ignoreList":[],"sourceRoot":""}